using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP.CLR_Basics
{
    class CodeExecutionModelInCLR
    {
        public static void main()
        {
            // Компиляция исходного кода в управляемые модули
            // CLR(Common Language Runtime) - общеязыковая среда выполнения
            // 1. соответствующий компилятор проверяет синтаксис и анализирует исходный код программы
            // 2. Вне зависимости от типа используемого компилятора результатом компиляции будет являться управляемый модуль (managed module) — стандартный переносимый исполняемый (portable executable, PE) файл 32-разрядной (PE32) или 64-разрядной Windows (PE32+), который требует для своего выполнения CLR.
            
            // Управляемые сборки всегда используют преимущества функции безопасности «предотвращения выполнения данных» (DEP, Data Execution Prevention) и технологию ASLR (Address Space Layout Optimization), применение этих технологий повышает информационную безопасность всей системы.
            // IL-код иногда называют управляемым (managed code), потому что CLR управляет его выполнением.

            // Части управляемого модуля
            // 1) Заголовок PE32 или PE32+ - Стандартный заголовок PE-файла Windows, аналогичный заголовку Common Object File Format (COFF).
            // Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64‑разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран.
            // 2) Заголовок CLR - Содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль в управляемый. Заголовок включает нужную версию CLR, некоторые флаги, метку метаданных MethodDef точки входа в управляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр.
            // 3) Метаданные - Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены, определенные в исходном коде, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки в исходном коде
            // 4) Код Intermediate Language (IL) - Код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды

            // метаданные — это набор таблиц данных, описывающих то, что определено в модуле, например типы и их члены.
            // В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены.
            // Метаданные расширяют возможности таких старых технологий, как библиотеки типов COM и файлы IDL (Interface Definition Language, язык описания интерфейсов).
            // - Метаданные устраняют необходимость в заголовочных и библиотечных файлах при компиляции, так как все сведения об упоминаемых типах/членах содержатся в файле с реализующим их IL-кодом. Компиляторы могут читать метаданные прямо из управляемых модулей.
            // - Среда Microsoft Visual Studio использует метаданные для облегчения написания кода. Ее функция IntelliSense анализирует метаданные и сообщает, какие методы, свойства, события и поля предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
            // - В процессе верификации кода CLR использует метаданные, чтобы убедиться, что код совершает только «безопасные по отношению к типам» операции.
            // - Метаданные позволяют сериализовать поля объекта, а затем передать эти данные по сети на удаленный компьютер и там провести процесс десериализации,восстановив объект и его состояние на удаленном компьютере.
            // - Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может определить тип объектов и узнать, какие именно поля в них ссылаются на другие объекты.


            // Объединение управляемых модулей в сборку
            // Сборка (assembly) обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов ресурсов.
            // это наименьшая единица многократного использования, безопасности и управления версиями.
            // В контексте среды CLR сборкой называется то, что мы обычно называем компонентом.

            // программа создает единственный файл PE32(+), который обеспечивает логическую группировку файлов.
            // При этом в файл PE32(+) включаетсяч блок данных, называемый манифестом (manifest). Манифест представляет собой обычный набор таблиц метаданных.
            // Другими словами, среда CLR может определить все прямые зависимости данной сборки, необходимые для ее выполнения.


            // Загрузка CLR
            // Каждая создаваемая сборка представляет собой либо исполняемое приложение, либо библиотеку DLL, содержащую набор типов для использования в исполняемом приложении.
            // В исключительно редких случаях разработчикам приходится писать код, совместимый только с какой-то конкретной версией Windows. Обычно это требуется при работе с небезопасным кодом (unsafe code) или для взаимодействия с неуправляемым кодом, ориентированным на конкретную процессорную архитектуру 
            // Если платформа не указана, компилятор задействует значение по умолчанию anycpu, которое означает, что сборка может выполняться в любой версии Windows.
            // После анализа заголовка EXE-файла для выяснения того, какой процесс необходимо запустить — 32- или 64-разрядный, — Windows загружает в адресное пространство процесса соответствующую версию библиотеки MSCorEE.dllю
            // Далее основной поток вызывает определенный в библиотеке MSCorEE.dll метод, который инициализирует CLR, загружает сборку EXE, а затем вызывает ее метод Main, в котором содержится точка входа.
            // Когда неуправляемое приложение вызывает функцию Win32 LoadLibrary для загрузки управляемой сборки, Windows автоматически загружает и инициализирует CLR (если это еще не сделано) для обработки содержащегося в сборке кода.


            // Исполнение кода сборки
            // IL можно рассматривать как объектно-ориентированный машинный язык.
            // во многих проектах стоит серьезно задуматься об использовании одновременно нескольких языков, поддерживаемых CLR.
            // Для выполнения какого-либо метода его IL-код должен быть преобразован в машинные команды. Этим занимается JIT-компилятор (Just-In-Time) среды CLR.
            // Непосредственно перед исполнением метода Main среда CLR находит все типы данных, на которые ссылается программный код метода Main. При этом CLR выделяет внутренние структуры данных, используемые для управления доступом к типам, на которые есть ссылки.
            // Каждая запись содержит адрес, по которому можно найти реализацию метода.
            // Снижение производительности наблюдается только при первом вызове метода. Все последующие обращения выполняются «на максимальной скорости», потому что повторная верификация и компиляция не производятся.
            // JIT-компилятор хранит машинные команды в динамической памяти. Это значит, что скомпилированный код уничтожается по завершении работы приложения. Для повторного вызова приложения или для параллельного запуска его второго экземпляра (в другом процессе операционной системы) JIT‑компилятору придется заново скомпилировать IL-код в машинные команды.

            // Есть два параметра компилятора C#, влияющих на оптимизацию кода, /optimize и /debug
            // В управляемой среде компиляция кода состоит из двух фаз.
            // Перечислим некоторые возможности повышения производительности управляемого кода по сравнению с неуправляемым:
            // - JIT-компилятор может определить, что приложение выполняется на процессоре Intel Pentium 4, и сгенерировать машинный код со специальными командами, поддерживаемыми Pentium 4. Обычно неуправляемые приложения компилируются с самым общим набором команд и не используют специальные команды, способные повысить эффективность приложения.
            // - JIT-компилятор может определить, что некоторое условие на том компьютере, на котором он выполняется, всегда оказывается ложным.
            // - CLR может профилировать выполняемую программу и перекомпилировать IL в машинный код в процессе выполнения.

            // Также при анализе производительности может пригодиться класс System.Runtime.ProfileOptimization. Он заставляет CLR сохранить (в файле) информацию о том, какие методы проходят JIT-компиляцию во время выполнения приложения.


            // IL-код и верификация
            // В процессе компиляции IL в машинные инструкции CLR выполняется процедура, называемая верификацией — анализ высокоуровневого кода IL и проверка безопасности всех операций.
            // Это означает, что вы можете запустить несколько управляемых приложений в одном виртуальном адресном пространстве Windows.


            // Небезопасный код
            // компилятор C# требует, чтобы все методы, содержащие небезопасный код, помечались ключевым словом unsafe, а при компиляции исходного кода использовался параметр компилятора /unsafe.
            

            // IL и защита интеллектуальной собственности


            // NGen.exe
            // компиляции IL-кода в машинный код при установке приложения на машине пользователя.
            // - Ускорение запуска приложения.
            // - Сокращение рабочего набора приложения.


            // Библиотека FCL
            // Framework Class Library - набор сборок в формате DLL, содержащих несколько тысяч определений типов, каждый из которых предоставляет некоторую функциональность.
            // - Веб-службы. Технологии Microsoft ASP.NET XML Web Service и Windows Communication Foundation (WCF) позволяют очень легко создавать методы для обработки сообщений, передаваемых по Интернету.
            // - Приложения Web Forms/приложения MVC на базе HTML. ASP.NET
            // - Приложения Windows с расширенным графическим интерфейсом. Windows Store, WPF (Windows Presentation Foundation) и Windows Forms.
            // - Консольные приложения Windows.
            // - Службы Windows. Да, теперь стало возможным построение служб (services), управляемых через Windows SCM (Service Control Manager) с использованием .NET Framework.
            // - Хранимые процедуры баз данных. Серверы баз данных Microsoft SQL Server, IBM DB2 и Oracle дают возможность разработчикам писать свои хранимые процедуры с использованием .NET Framework.
            // - Библиотеки компонентов.

            // пространства имен FCL
            // - System - Все базовые типы, используемые в приложениях
            // - System.Data - Типы для взаимодействия с базами данных и обработки данных
            // - System.IO - Типы потокового ввода-вывода, обхода дерева каталогов и файлов
            // - System.Net - Типы для низкоуровневых сетевых коммуникаций и использования распространенных протоколов Интернета
            // - System.Runtime.InteropServices - Типы, позволяющие управляемому коду работать с неуправляемыми платформенными средствами (компонентами COM, функциями Win32 и DLL-библиотек)
            // - System.Security - Типы защиты данных и ресурсов
            // - System.Text - Типы для работы с разными кодировками (такими, как ANSI и Юникод)
            // - System.Threading - Типы асинхронных операций и синхронизации доступа к ресурсам
            // - System.Xml - Типы для обработки схем и данных XML


            // CTS
            // Microsoft разработала формальную спецификацию CTS (Common Type System), которая описывает способ определения и поведение типов.
            // Согласно спецификации CTS, тип может содержать нуль и более членов.

        }
    }
}
