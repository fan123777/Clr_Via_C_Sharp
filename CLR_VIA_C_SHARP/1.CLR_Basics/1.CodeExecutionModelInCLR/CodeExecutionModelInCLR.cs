using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP.CLR_Basics
{
    using Testing;

    class CodeExecutionModelInCLR
    {
        public static void main()
        {
            // Компиляция исходного кода в управляемые модули
            // CLR(Common Language Runtime) - общеязыковая среда выполнения
            // 1. соответствующий компилятор проверяет синтаксис и анализирует исходный код программы
            // 2. Вне зависимости от типа используемого компилятора результатом компиляции будет являться управляемый модуль (managed module) — стандартный переносимый исполняемый (portable executable, PE) файл 32-разрядной (PE32) или 64-разрядной Windows (PE32+), который требует для своего выполнения CLR.
            
            // Управляемые сборки всегда используют преимущества функции безопасности «предотвращения выполнения данных» (DEP, Data Execution Prevention) и технологию ASLR (Address Space Layout Optimization), применение этих технологий повышает информационную безопасность всей системы.
            // IL-код иногда называют управляемым (managed code), потому что CLR управляет его выполнением.

            // Части управляемого модуля
            // 1) Заголовок PE32 или PE32+ - Стандартный заголовок PE-файла Windows, аналогичный заголовку Common Object File Format (COFF).
            // Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64‑разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран.
            // 2) Заголовок CLR - Содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль в управляемый. Заголовок включает нужную версию CLR, некоторые флаги, метку метаданных MethodDef точки входа в управляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр.
            // 3) Метаданные - Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены, определенные в исходном коде, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки в исходном коде
            // 4) Код Intermediate Language (IL) - Код, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует IL в машинные команды

            // метаданные — это набор таблиц данных, описывающих то, что определено в модуле, например типы и их члены.
            // В метаданных также есть таблицы, указывающие, на что ссылается управляемый модуль, например на импортируемые типы и их члены.
            // Метаданные расширяют возможности таких старых технологий, как библиотеки типов COM и файлы IDL (Interface Definition Language, язык описания интерфейсов).
            // - Метаданные устраняют необходимость в заголовочных и библиотечных файлах при компиляции, так как все сведения об упоминаемых типах/членах содержатся в файле с реализующим их IL-кодом. Компиляторы могут читать метаданные прямо из управляемых модулей.
            // - Среда Microsoft Visual Studio использует метаданные для облегчения написания кода. Ее функция IntelliSense анализирует метаданные и сообщает, какие методы, свойства, события и поля предпочтительны в данном случае и какие именно параметры требуются конкретным методам.
            // - В процессе верификации кода CLR использует метаданные, чтобы убедиться, что код совершает только «безопасные по отношению к типам» операции.
            // - Метаданные позволяют сериализовать поля объекта, а затем передать эти данные по сети на удаленный компьютер и там провести процесс десериализации,восстановив объект и его состояние на удаленном компьютере.
            // - Метаданные позволяют сборщику мусора отслеживать жизненный цикл объектов. При помощи метаданных сборщик мусора может определить тип объектов и узнать, какие именно поля в них ссылаются на другие объекты.


            // Объединение управляемых модулей в сборку
            // Сборка (assembly) обеспечивает логическую группировку одного или нескольких управляемых модулей или файлов ресурсов.
            // это наименьшая единица многократного использования, безопасности и управления версиями.
            // В контексте среды CLR сборкой называется то, что мы обычно называем компонентом.

            // программа создает единственный файл PE32(+), который обеспечивает логическую группировку файлов.
            // При этом в файл PE32(+) включаетсяч блок данных, называемый манифестом (manifest). Манифест представляет собой обычный набор таблиц метаданных.
            // Другими словами, среда CLR может определить все прямые зависимости данной сборки, необходимые для ее выполнения.


            // Загрузка CLR
            // Каждая создаваемая сборка представляет собой либо исполняемое приложение, либо библиотеку DLL, содержащую набор типов для использования в исполняемом приложении.
            // В исключительно редких случаях разработчикам приходится писать код, совместимый только с какой-то конкретной версией Windows. Обычно это требуется при работе с небезопасным кодом (unsafe code) или для взаимодействия с неуправляемым кодом, ориентированным на конкретную процессорную архитектуру 
            // Если платформа не указана, компилятор задействует значение по умолчанию anycpu, которое означает, что сборка может выполняться в любой версии Windows.
            // После анализа заголовка EXE-файла для выяснения того, какой процесс необходимо запустить — 32- или 64-разрядный, — Windows загружает в адресное пространство процесса соответствующую версию библиотеки MSCorEE.dllю
            // Далее основной поток вызывает определенный в библиотеке MSCorEE.dll метод, который инициализирует CLR, загружает сборку EXE, а затем вызывает ее метод Main, в котором содержится точка входа.
            // Когда неуправляемое приложение вызывает функцию Win32 LoadLibrary для загрузки управляемой сборки, Windows автоматически загружает и инициализирует CLR (если это еще не сделано) для обработки содержащегося в сборке кода.


            // Исполнение кода сборки
            // IL можно рассматривать как объектно-ориентированный машинный язык.
            // во многих проектах стоит серьезно задуматься об использовании одновременно нескольких языков, поддерживаемых CLR.
            // Для выполнения какого-либо метода его IL-код должен быть преобразован в машинные команды. Этим занимается JIT-компилятор (Just-In-Time) среды CLR.
            // Непосредственно перед исполнением метода Main среда CLR находит все типы данных, на которые ссылается программный код метода Main. При этом CLR выделяет внутренние структуры данных, используемые для управления доступом к типам, на которые есть ссылки.
            // Каждая запись содержит адрес, по которому можно найти реализацию метода.
            // Снижение производительности наблюдается только при первом вызове метода. Все последующие обращения выполняются «на максимальной скорости», потому что повторная верификация и компиляция не производятся.
            // JIT-компилятор хранит машинные команды в динамической памяти. Это значит, что скомпилированный код уничтожается по завершении работы приложения. Для повторного вызова приложения или для параллельного запуска его второго экземпляра (в другом процессе операционной системы) JIT‑компилятору придется заново скомпилировать IL-код в машинные команды.

            // Есть два параметра компилятора C#, влияющих на оптимизацию кода, /optimize и /debug
            // В управляемой среде компиляция кода состоит из двух фаз.
            // Перечислим некоторые возможности повышения производительности управляемого кода по сравнению с неуправляемым:
            // - JIT-компилятор может определить, что приложение выполняется на процессоре Intel Pentium 4, и сгенерировать машинный код со специальными командами, поддерживаемыми Pentium 4. Обычно неуправляемые приложения компилируются с самым общим набором команд и не используют специальные команды, способные повысить эффективность приложения.
            // - JIT-компилятор может определить, что некоторое условие на том компьютере, на котором он выполняется, всегда оказывается ложным.
            // - CLR может профилировать выполняемую программу и перекомпилировать IL в машинный код в процессе выполнения.

            // Также при анализе производительности может пригодиться класс System.Runtime.ProfileOptimization. Он заставляет CLR сохранить (в файле) информацию о том, какие методы проходят JIT-компиляцию во время выполнения приложения.


            // IL-код и верификация
            // В процессе компиляции IL в машинные инструкции CLR выполняется процедура, называемая верификацией — анализ высокоуровневого кода IL и проверка безопасности всех операций.
            // Это означает, что вы можете запустить несколько управляемых приложений в одном виртуальном адресном пространстве Windows.


            // Небезопасный код
            // компилятор C# требует, чтобы все методы, содержащие небезопасный код, помечались ключевым словом unsafe, а при компиляции исходного кода использовался параметр компилятора /unsafe.
            

            // IL и защита интеллектуальной собственности


            // NGen.exe
            // компиляции IL-кода в машинный код при установке приложения на машине пользователя.
            // - Ускорение запуска приложения.
            // - Сокращение рабочего набора приложения.


            // Библиотека FCL
            // Framework Class Library - набор сборок в формате DLL, содержащих несколько тысяч определений типов, каждый из которых предоставляет некоторую функциональность.
            // - Веб-службы. Технологии Microsoft ASP.NET XML Web Service и Windows Communication Foundation (WCF) позволяют очень легко создавать методы для обработки сообщений, передаваемых по Интернету.
            // - Приложения Web Forms/приложения MVC на базе HTML. ASP.NET
            // - Приложения Windows с расширенным графическим интерфейсом. Windows Store, WPF (Windows Presentation Foundation) и Windows Forms.
            // - Консольные приложения Windows.
            // - Службы Windows. Да, теперь стало возможным построение служб (services), управляемых через Windows SCM (Service Control Manager) с использованием .NET Framework.
            // - Хранимые процедуры баз данных. Серверы баз данных Microsoft SQL Server, IBM DB2 и Oracle дают возможность разработчикам писать свои хранимые процедуры с использованием .NET Framework.
            // - Библиотеки компонентов.

            // пространства имен FCL
            // - System - Все базовые типы, используемые в приложениях
            // - System.Data - Типы для взаимодействия с базами данных и обработки данных
            // - System.IO - Типы потокового ввода-вывода, обхода дерева каталогов и файлов
            // - System.Net - Типы для низкоуровневых сетевых коммуникаций и использования распространенных протоколов Интернета
            // - System.Runtime.InteropServices - Типы, позволяющие управляемому коду работать с неуправляемыми платформенными средствами (компонентами COM, функциями Win32 и DLL-библиотек)
            // - System.Security - Типы защиты данных и ресурсов
            // - System.Text - Типы для работы с разными кодировками (такими, как ANSI и Юникод)
            // - System.Threading - Типы асинхронных операций и синхронизации доступа к ресурсам
            // - System.Xml - Типы для обработки схем и данных XML


            // CTS
            // Microsoft разработала формальную спецификацию CTS (Common Type System), которая описывает способ определения и поведение типов.
            // Согласно спецификации CTS, тип может содержать нуль и более членов.
            // Поле — переменная, являющаяся частью состояния объекта. Поля идентифицируются именем и типом.
            // Метод — функция, выполняющая операцию с объектом, часто с изменением его состояния. Метод обладает именем, сигнатурой и модификаторами.
            // Свойство — с точки зрения вызывающей стороны выглядит как поле, но в реализации типа представляет собой метод (или два). Свойства позволяют организовать проверку параметров или состояния объекта перед обращением к значению и/или вычислять его значение только при необходимости.
            // Событие — используется для создания механизма оповещения между объектом и другими заинтересованными объектами.
            
            // CTS также задает правила видимости типов и доступа к членам типа.
            // помечая тип как открытый (ключевое слово public), вы тем самым экспортируете этот тип, делая его видимым и доступным для любой сборки.
            // пометка типа на уровне сборки (ключевое слово internal в C#) делает его видимым и доступным для кода той же сборки.
            // варианты ограничения доступа к членам типа:
            // - Закрытый (приватный) доступ — член типа доступен только для других членов того же типа.
            // - Доступ в семействе — член типа доступен для производных типов независимо от того, принадлежат ли они той же сборке или нет. Обратите внимание: во многих языках (таких, как C# и C++) доступ в семействе обозначается ключевым словом protected.
            // - Доступ в семействе и сборке — член типа доступен для производных типов, но только в том случае, если они определяются в той же сборке. Многие языки (на- пример, C# и Visual Basic) не поддерживают этот уровень доступа. Разумеется, в IL-коде он поддерживается.
            // - Доступ в сборке — член типа доступен для любого кода, входящего в ту же сборку. Во многих языках доступ в сборке обозначается ключевым словом internal.
            // - Доступ в семействе или сборке — член типа доступен для производных типов из любой сборки, а также для любых типов в той же сборке. В C# этот вариант доступа обозначается ключевыми словами protected internal.
            // - Открытый доступ — член типа доступен для любого кода в любой сборке.
            
            // Кроме того, CTS определяет правила, управляющие наследованием, работой виртуальных методов, сроком жизни объектов и т. д.
            // язык и поведение кода лучше рассматривать как две разные сущности.
            // синтаксис определения типа зависит от выбранного языка, но поведение типа остается неизменным, потому что оно определяется спецификацией CTS.
            // CTS позволяет типу быть производным только от одного базового класса. И хотя язык C++ поддерживает возможность наследования от нескольких базовых типов, CTS не примет такие классы и не будет работать с ними. Обнаружив попытку создания управляемого кода с типом, производным от нескольких базовых типов, компилятор Microsoft C++/CLI выдает сообщение об ошибке.
            // все типы должны быть производными (прямо или опосредованно) от предопределенного типа System.Object (то есть от типа Object из пространства имен System)
            // System.Object позволяет сделать следующее:
            // - сравнить два экземпляра на равенство;
            // - получить хеш-код экземпляра;
            // - запросить фактический тип экземпляра;
            // - выполнить поверхностное (поразрядное) копирование экземпляра;
            // - получить строковое представление текущего состояния экземпляра.


            // CLS
            // Модель COM позволяет объектам, написанным на разных языках, взаимодействовать друг с другом. С другой стороны, среда CLR интегрирует все языки и обеспечивает возможность равноправного использования объектов, написанных на одном языке, в коде на совершенно другом языке.
            // Такая интеграция стала возможной благодаря стандартному набору типов CLR, метаданным (самодокументирующей информацией о типах) и общей исполнительной среде.
            // спецификацию CLS(Common Language Speciication)
            // минимальный набор возможностей, которые должны поддерживаться компилятором для генерирования типов, совместимых с другими компонентами, написанными на других CLS-совместимых языках на базе CLR.
            // Если вы проектируете тип на одном языке и собираетесь использовать его в другом языке, не размещайте никакие возможности, выходящие за пределы CLS, в его открытых и защищенных членах.
            // SomeLibrary
            // В этом коде атрибут [assembly:CLSCompliant(true)] применяется к сборке. Этот атрибут приказывает компилятору следить за тем, чтобы тип с открытым уровнем доступа не содержал конструкций, препятствующих его использованию в другом языке программирования.
            // Первое выдается из-за того, что метод Abc возвращает целое без знака; некоторые языки программирования не умеют работать с беззнаковыми целыми числами.
            // Второе предупреждение выдается из-за того, что тип содержит два открытых метода, различающихся только регистром и типом возвращаемого значения: Abc и abc. В Visual Basic и некоторых других языках вызов обоих методов невозможен.
            // Если удалить ключевое слово public перед sealed class SomeLibraryType и перекомпилировать код, оба предупреждения пропадают.
            // Дело в том, что тип SomeLibraryType по умолчанию рассматривается как internal, а следовательно, становится недоступным за пределами сборки.

            // правила CLS в предельно упрощенном виде
            // В CLR каждый член типа является либо полем (данные), либо методом (поведение).
            // Для упрощения программирования языки обычно предоставляют дополнительные абстракции, упрощающие реализацию этих стандартных паттернов — перечисления, массивы, свойства, индексаторы, делегаты, события, конструкторы, финализаторы, перегрузки операторов, операторы преобразования и т. д. Когда компилятор встречает эти абстракции в исходном коде, он должен преобразовать их в поля и методы, чтобы сделать их доступными для CLR и любых других языков программирования.


            // Взаимодействие с неуправляемым кодом
            // CLR поддерживает три сценария взаимодействий:
            // - Управляемый код может вызывать неуправляемые функции из DLL с использованием механизма P/Invoke (сокращение от «Platform Invoke»).
            // Например, приложение C# может вызвать функцию CreateSemaphore, экспортируемую библиотекой Kernel32.dll.
            // - Управляемый код может использовать готовые компоненты COM. Многие компании уже реализовали большое количество неуправляемых компонентов COM. На основе библиотек типов из этих компонентов можно создать управляемую сборку с описанием компонента COM. Управляемый код обращается к типу из управляемой сборки точно так же, как к любому другому управляемому типу. За дополнительной информацией обращайтесь к описанию программы TlbImp.exe, входящей в поставку .NET Framework SDK.
            // - Неуправляемый код может использовать управляемый тип.
            // Большая часть существующего неуправляемого кода требует наличия компонента COM. Такие компоненты гораздо проще реализуются с управляемым кодом, что позволяет избежать служебного кода, связанного с подсчетом ссылок и интерфейсами. Например, на C# можно написать элемент управления ActiveX или расширение командного процессора. За дополнительной информацией обращайтесь к описанию программ TlbExp.exe и RegAsm.exe, входящих в поставку .NET Framework SDK.
            // В Windows 8 компания Microsoft ввела новый интерфейс прикладного программирования, называемый Windows Runtime (WinRT). Его внутренняя реализация базируется на компонентах COM, но вместо библиотеки типов компоненты COM описывают свой API в стандарте метаданных ECMA, созданном рабочей группой .NET Framework.


            // !!! +
            // - Свойство + 
            //TestProperty();
            // - Событие +
            // TestEvent();
            // - Internal +
            // - Protected Internal +
            // TestInternal();
            // - Индексатор +
            // TestIndexator();
        }

        public static void TestProperty()
        {
            // Свойства объединяют функции полей и методов.Для объекта, использующего какой-либо объект, свойство является полем, поэтому для доступа к свойству требуется тот же синтаксис, что и для поля.Для средства реализации класса свойство является одним или двумя блоками кода, представляющими метод доступа get и/или метод доступа set.Блок кода для метода доступа get выполняется, когда осуществляется чтение свойства; блок кода для метода доступа set выполняется, когда свойству присваивается новое значение.Свойство без метода доступа set считается доступным только для чтения. Свойство без метода доступа get считается доступным только для записи. Свойство с обоими методами доступа доступно для чтения и для записи.
            // В отличие от полей свойства не классифицируются как переменные.Поэтому свойство нельзя передать в качестве параметра ref (Справочник по C#) или out (Справочник по C#).
            // Свойства имеют множество применений: с их помощью можно проверить данные перед разрешением изменения, они могут прозрачно представлять данные в классе, куда эти данные извлекаются из какого-либо другого источника, например базы данных, они могут выполнять действие при изменении данных, например вызов события или изменение значения в других полях.
            // Свойства объявляются в блоке класса с помощью последовательного указания уровня доступа для поля, типа свойства, имени свойства и блока кода, в котором объявляется метод доступа get и/или set. Например:
            Date date = new Date();
            date.Month = 8;
            System.Console.WriteLine(date.Month);
            // Свойства могут быть объявлены как public, private, protected, internal или protected internal. Эти модификаторы доступа определяют порядок доступа к свойству для пользователей класса.Методы доступа get и set могут иметь различные модификаторы доступа для одного свойства.
            // Свойство можно объявить как статическое свойство при помощи ключевого слова static.
            // Свойство можно пометить как виртуальное свойство при помощи ключевого слова virtual. Это позволяет производным классам переопределять поведение свойства при помощи ключевого слова override.
            // Свойство, переопределяющее виртуальное свойство, может также быть sealed, что указывает на то, что для производных классов оно более не является виртуальным.И наконец, свойство можно объявить как abstract.Это означает, что в классе отсутствует реализация, поэтому производные классы должны создавать свою собственную реализацию.
            Employee.NumberOfEmployees = 107;
            Employee e1 = new Employee();
            e1.Name = "Claude Vige";

            System.Console.WriteLine("Employee number: {0}", Employee.Counter);
            System.Console.WriteLine("Employee name: {0}", e1.Name);

            Manager m1 = new Manager();
            // Derived class property.
            m1.Name = "John";

            ((Employee)m1).Name = "Mary";
            System.Console.WriteLine("Name in the derived class is: {0}", m1.Name);
            System.Console.WriteLine("Name in the base class is: {0}", ((Employee)m1).Name);

            // Input the side:
            System.Console.Write("Enter the side: ");
            double side = double.Parse(System.Console.ReadLine());

            // Compute the areas:
            Square s = new Square(side);
            Cube c = new Cube(side);

            // Display the results:
            System.Console.WriteLine("Area of the square = {0:F2}", s.Area);
            System.Console.WriteLine("Area of the cube = {0:F2}", c.Area);
            System.Console.WriteLine();

            // Input the area:
            System.Console.Write("Enter the area: ");
            double area = double.Parse(System.Console.ReadLine());

            // Compute the sides:
            s.Area = area;
            c.Area = area;

            // Display the results:
            System.Console.WriteLine("Side of the square = {0:F2}", s.side);
            System.Console.WriteLine("Side of the cube = {0:F2}", c.side);
        }

        public static void TestEvent()
        {
            // Событие, это не что иное, как ситуация, при возникновении которой, произойдет действие или несколько действий. Говоря языком программного моделирования, Событие — это именованный делегат, при вызове которого, будут запущены все подписавшиеся на момент вызова события методы заданной сигнатуры.
            // Эта трактовка хоть и раскрывает всю суть структуры события, но не только сбивает с толку начинающих «шарп-прогеров», но и не дает возможность рационально представить в программистской голове весь смысл. 

            // пределено три класса. Первый класс будет считать до 100, используя цикл. Два других класса будут ждать, когда в первом классе счетчик досчитает, например, до 71, и после этого каждый выведет в консоль фразу «Пора действовать, ведь уже 71!». Проще говоря, при обнаружении значения 71, вызовутся по методу, соответственно для каждого класса. Разложим все по полкам.
            // события (event) основаны на делегатах (delegate), а делегат, говоря очень простым языком — «переменная, хранящая ссылку на метод». 
            // Далее, мы создаем событие при помощи ключевого слова event и связываем его с этим делегатом (MethodContainer), а, следовательно, c методами, имеющими сигнатуру void (void). Событие должно быть public, т.к. его должны использовать разные классы, которым нужно как-то отреагировать (классы Handler_I и Handler_II). 

            ClassCounter Counter = new ClassCounter();
            Handler_I Handler1 = new Handler_I();
            Handler_II Handler2 = new Handler_II();

            //Подписались на событие
            Counter.onCount += Handler1.Message;
            Counter.onCount += Handler2.Message;

            //Запустили счетчик
            Counter.Count();

            // Класс, в котором вы создаете событие (генерируете) называется классом-издателем, а классы, чьи методы подписываются на это событие при помощи "+=" — классами-подписчиками.
            // Вы всегда можете отписаться, используя оператор "-="
            // Преимущество Событий очевидно: классу-издателю, генерирующему событие не нужно знать, сколько классов-подписчиков подпишется или отпишется. Он создал событие для определенных методов, ограничив их делегатом по определенной сигнатуре. События широко используются для составления собственных компонентов управления (кнопок, панелей, и т.д.).

            // Пару слов о .NET-событиях. Microsoft упростила задачу конструирования делегатов: .NET предлагает готовый делегат EventHandler и т.н. «пакет» входных параметров EventArgs. Желаете событие? Берете готовый EventHandler, определяетесь в параметрах, «запихиваете» их в класс, а класс наследуете от EventArgs. А дальше — как по расписанию)
            
            // EventHandler<TEventArgs> - делегат
            // Represents the method that will handle an event when the event provides data.
            // [SerializableAttribute]
            // public delegate void EventHandler<TEventArgs>(
	        //      object sender,
	        //      TEventArgs e
            // )
            // sender - The source of the event.
            // e - Type: TEventArgs. An object that contains the event data.
            // TEventArgs - The type of the event data generated by the event.
            // The event model in the .NET Framework is based on having an event delegate that connects an event with its handler.To raise an event, two elements are needed:
            // - A delegate that refers to a method that provides the response to the event.
            // - Optionally, a class that holds the event data, if the event provides data.
            // The advantage of using EventHandler<TEventArgs> is that you do not need to code your own custom delegate if your event generates event data.You simply provide the type of the event data object as the generic parameter.

            Counter c = new Counter(new Random().Next(10));
            c.ThresholdReached += c_ThresholdReached;

            Console.WriteLine("press 'a' key to increase total");
            while (Console.ReadKey(true).KeyChar == 'a')
            {
                Console.WriteLine("adding one");
                c.Add(1);
            }

            // All events in the .NET Framework class library are based on the EventHandler delegate, which is defined as follows:
            // public delegate void EventHandler(object sender, EventArgs e);
            // To publish events based on the EventHandler pattern

            MyPublisher pub = new MyPublisher();
            Subscriber sub1 = new Subscriber("sub1", pub);
            Subscriber sub2 = new Subscriber("sub2", pub);

            // Call the method that raises the event.
            pub.DoSomething();

            // Keep the console window open
            Console.WriteLine("Press Enter to close this window.");
            Console.ReadLine();
        }

        static void c_ThresholdReached(object sender, ThresholdReachedEventArgs e)
        {
            Console.WriteLine("The threshold of {0} was reached at {1}.", e.Threshold, e.TimeReached);
        }

        public static void TestInternal()
        {
            // The internal keyword is an access modifier for types and type members.Internal types or members are accessible only within files in the same assembly.
            // Types or members that have access modifier protected internal can be accessed from the current assembly or from types that are derived from the containing class.
        }

        public static void TestIndexator()
        {
            // Индексаторы позволяют индексировать экземпляры класса или структуры точно так же, как и массивы.Индексаторы напоминают свойства за исключением того, что их методы доступа принимают параметры.
            
            // Declare an instance of the SampleCollection type.
            SampleCollection<string> stringCollection = new SampleCollection<string>();

            // Use [] notation on the type.
            stringCollection[0] = "Hello, World";
            System.Console.WriteLine(stringCollection[0]);
        }
    }
}
