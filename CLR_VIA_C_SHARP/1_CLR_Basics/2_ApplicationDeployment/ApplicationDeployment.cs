using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._1_CLR_Basics._2_ApplicationDeployment
{
    class ApplicationDeployment
    {
        public static void main()
        {
            // Задачи развертывания в .NET Framework
            // Например, в отличие от модели COM информацию о компонентах уже не нужно сохранять в реестре.


            // Компоновка типов в модуль
            MyProgram.main();
            // MSCorLib.dll — специальный файл, в котором находятся все основные типы:
            // Byte, Char, String, Int32 и т. д.

            // Файл параметров
            // При использовании параметра /reference для ссылки на какую-либо сборку можно указать полный путь к конкретному файлу. Однако если такой путь не указать, компилятор будет искать нужный файл в следующих местах (в указанном порядке).
            // - Рабочий каталог. %SystemRoot%\Microsoft.NET\Framework\v4.0.#####.
            // - Все каталоги, указанные с использованием параметра /lib компилятора.
            // - Все каталоги, указанные в переменной окружения LIB.

            // Несколько слов о метаданных
            // Что же именно находится в файле Program.exe? Управляемый PE-файл состоит из 4-х частей: заголовка PE32(+), заголовка CLR, метаданных и кода на промежуточном языке (intermediate language, IL).
            // Заголовок PE32(+) хранит стандартную информацию, ожидаемую Windows. Заголовок CLR — это небольшой блок информации, специфичной для модулей, требующих CLR (управляемых модулей). В него входит старший и младший номера версии CLR, для которой скомпонован модуль, ряд флагов и маркер MethodDef (о нем — чуть позже), указывающий метод точки входа в модуль, если это исполняемый файл CUI, GUI или Windows Store, а также необязательную сигнатуру строгого имени (она рассмотрена в главе 3).
            // Наконец, заголовок содержит размер и смещение некоторых таблиц метаданных, расположенных в модуле.
            // Метаданные — это блок двоичных данных, состоящий из нескольких таблиц.
            // Существуют три категории таблиц: определений, ссылок и манифестов.

            // Основные таблицы определений в метаданных
            // ModuleDef - Всегда содержит одну запись, идентифицирующую модуль. Запись включает имя файла модуля с расширением (без указания пути к файлу) и идентификатор версии модуля (в виде сгенерированного компилятором кода GUID). Это позволяет переименовывать файл, не теряя сведений о его исходном имени. Однако настоятельно рекомендуется не переименовывать файл, иначе среда CLR может не найти сборку во время выполнения
            // TypeDef - Содержит по одной записи для каждого типа, определенного в модуле. Каждая запись включает имя типа, базовый тип, флаги сборки (public, private и т. д.) и указывает на записи таблиц MethodDef, PropertyDef и EventDef, содержащие соответственно сведения о методах, свойствах и событиях этого типа
            // MethodDef - Содержит по одной записи для каждого метода, определенного в модуле. Каждая строка включает имя метода, флаги (private, public, virtual, abstract, static, final и т. д.), сигнатуру и смещение в модуле, по которому находится соответствующий IL-код. Каждая запись также может ссылаться на запись в таблице ParamDef, где хранятся дополнительные сведения о параметрах метода
            // FieldDef - Содержит по одной записи для каждого поля, определенного в модуле. Каждая запись состоит из флагов (например, private, public и т. д.) и типа поля
            // ParamDef - Содержит по одной записи для каждого параметра, определенного в модуле. Каждая запись состоит из флагов (in, out, retval и т. д.), типа и имени
            // PropertyDef - Содержит по одной записи для каждого свойства, определенного в модуле. Каждая запись включает имя, флаги, тип и вспомогательное поле (оно может быть пустым)
            // EventDef - Содержит по одной записи для каждого события, определенного в модуле. Каждая запись включает имя и флаги

            // Общие таблицы ссылок, входящие в метаданные
            // AssemblyRef - ателя и идентифицирующий издателя сборки, на которую ссылается модуль). Каждая запись также содержит несколько флагов и хеш-код, который должен служить контрольной суммой битов сборки. Среда CLR полностью игнорирует этот хеш-код и, вероятно, будет игнорировать его в будущем 
            // ModuleRef - Содержит по одной записи для каждого PE-модуля, реализующего типы, на которые он ссылается. Каждая запись включает имя файла сборки и его расширение (без указания пути). Эта таблица служит для привязки модуля вызывающей сборки к типам, реализованным в других модулях 
            // TypeRef - Содержит по одной записи для каждого типа, на который ссылается модуль. Каждая запись включает имя типа и ссылку, по которой можно его найти. Если этот тип реализован внутри другого типа, запись содержит ссылку на соответствующую запись таблицы TypeRef. Если тип реализован в том же модуле, приводится ссылка на запись таблицы ModuleDef. Если тип реализован в другом модуле вызывающей сборки, приводится ссылка на запись таблицы ModuleRef. Если тип реализован в другой сборке, приводится ссылка на запись в таблице AssemblyRef
            // MemberRef - Содержит по одной записи для каждого члена типа (поля, метода, а также свойства или метода события), на который ссылается модуль. Каждая запись включает имя и сигнатуру члена и указывает на запись таблицы TypeRef, содержащую сведения о типе, определяющим этот член
            // Метаданные управляемого PE-файла можно изучать при помощи различных инструментов.


            // Объединение модулей для создания сборки
            // Файл Program.exe — это не просто PE-файл с метаданными, а еще и сборка (assembly), то есть совокупность одного или нескольких файлов с определениями типов и файлов ресурсов.
            // Один из файлов сборки выбирается для хранения ее манифеста. Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном содержат имена файлов, составляющих сборку
            // Некоторые характеристики сборки стоит запомнить:
            // - в сборке определены многократно используемые типы;
            // - сборке назначается номер версии;
            // - со сборкой может быть связана информация безопасности.
            // Наверное, проще представлять себе сборку как «логический» EXE- или DLL-файл.
            // три аргумента в пользу применения многофайловых сборок:
            // - Можно распределять типы по нескольким файлам, допуская избирательную загрузку необходимых файлов из Интернета, а также частично упаковывать и развертывать типы, варьируя функциональность приложения.
            // - Можно добавлять к сборке файлы с ресурсами и данными. Допустим, имеется тип для расчета некоторой страховой суммы. Ему может потребоваться доступ к актуарным таблицам. Вместо встраивания актуарных таблиц в исходный код можно включить соответствующий файл с данными в состав сборки (например, с помощью компоновщика сборок AL.exe, который рассмотрен далее). В сборки можно включать данные в любом формате: в текстовом, в виде таблиц Microsoft Excel или Microsoft Word, а также в любом другом при условии, что приложение способно разобрать данные в этом формате.
            // - Сборки могут состоять из типов, написанных на разных языках программирования. Одна часть типов может быть написана на C#, другая — на Visual Basic, остальные — на других языках программирования. При компиляции исходного текста на языке C# компилятор создает один модуль, а при компиляции исходного текста на Visual Basic — другой. Затем при помощи соответствующего инструмента все эти модули объединяются в одну сборку. Использующие такую сборку разработчики увидят в ней лишь набор типов. Разработчики даже не заметят, что применялись разные языки программирования. Кстати, при желании с помощью ILDasm.exe можно получить файлы с исходным текстом всех модулей на языке IL. После этого можно запустить утилиту ILAsm.exe и передать ей полученные файлы, и утилита выдаст файл, содержащий все типы. Для этого компилятор исходного текста должен генерировать только IL-код.

            // сборка — это единица многократного использования, управления версиями и безопасности типов.
            // При работе со многими типами, совместно использующими одну версию и набор параметров безопасности, по соображениям производительности рекомендуется размещать все типы в одном файле, не распределяя их по нескольким файлам, не говоря уже о разных сборках. На загрузку каждого файла или сборки CLR и Windows тратят значительное время: на поиск сборки, ее загрузку и инициализацию. Чем меньше файлов и сборок, тем быстрее загрузка, потому уменьшение числа сборок способствует сокращению рабочего пространства и степени фрагментации адресного пространства процесса. Ну, и наконец, nGen.exe лучше оптимизирует код, если обрабатываемые файлы больше по размеру.
            
            // таблицы метаданных манифеста, наличие которых превращает управляемый модуль в сборку.
            // AssemblyDef - Состоит из единственной записи, если модуль идентифицирует сборку. Запись включает имя сборки (без расширения и пути), сведения о версии (старший и младший номера версии, номер компоновки и редакции), региональные стандарты, флаги, алгоритм хеширования и открытый ключ издателя (это поле может быть пустым — null)
            // FileDef - Содержит по одной записи для каждого PE-файла и файла ресурсов, входящих в состав сборки (кроме файла, содержащего манифест). В каждой записи содержится имя и расширение файла (без указания пути), хеш-код и флаги. Если сборка состоит из одного файла, таблица FileDef пуста 
            // ManifestResourceDef - Содержит по одной записи для каждого ресурса, включенного в сборку. Каждая запись включает имя ресурса, флаги (public или private), а также индекс для таблицы FileDef, указывающий файл или поток с ресурсом. Если ресурс не является отдельным файлом (например, JPEG- или GIF-файлом), он хранится в виде потока в составе PE-файла. В случае встроенного ресурса запись также содержит смещение, указывающее начало потока ресурса в PE-файле
            // ExportedTypesDef - Содержит записи для всех открытых типов, экспортируемых всеми PE-модулями сборки. В каждой записи указано имя типа, индекс для таблицы FileDef (указывающий файл сборки, в котором реализован этот тип), а также индекс для таблицы TypeDef. Примечание: для экономии файлового пространства типы, экспортируемые из файла, содержащего манифест, не повторяются в этой таблице, потому что информация типов доступна через таблицы TypeDef метаданных 
            // Обратите внимание, что в файле, который содержит манифест, находится также информация о том, какие файлы составляют сборку, но отдельные файлы «не знают», что они включены в сборку.
            // Файл сборки, содержащий манифест, содержит также таблицу AssemblyRef. В ней хранятся записи с описанием всех сборок, на которые ссылаются файлы данной сборки. Это позволяет инструментам, открыв манифест сборки, сразу увидеть весь набор сборок, на которые ссылается эта сборка, не открывая другие файлы сборки. И в этом случае данные AssemblyRef призваны сделать сборку самоописываемой.
            // К сожалению, в интегрированной среде разработки (Integrated Development Environment, IDE) Microsoft Visual Studio нет встроенной поддержки создания многофайловых сборок — для этого приходится использовать инструменты командной строки.

            // Допустим, есть два файла с исходным текстом:
            // - файл RUT.cs содержит редко используемые типы;
            // - файл FUT.cs содержит часто используемые типы.
            // На самом деле в таблицах метаданных манифеста не описаны типы, экспортируемые PE-файлом, в котором находится манифест. Цель этой оптимизации — уменьшить число байт, необходимое для хранения данных манифеста в PE-файле. Таким образом, утверждения вроде «таблицы метаданных манифеста включают все открытые типы, экспортируемые MultiFileLibrary.dll и RUT.netmodule», верны лишь отчасти. Однако это утверждение вполне точно отражает логический набор экспортируемых типов.
            // Для любопытных: размер маркеров метаданных — 4 байта. Старший байт указывает тип маркера (0x01=TypeRef, 0x02=TypeDef, 0x26=FileRef, 0x27=ExportedType). Полный список типов маркеров см. в перечислимом типе CorTokenType в заголовочном файле CorHdr.h из . NET Framework SDK. Три младших байта маркера просто идентифицируют запись в соответствующей таблице метаданных. Например, маркер реализации 0x26000001 ссылается на первую строку таблицы FileRef (в большинстве таблиц нумерация строк начинается с 1, а не с 0). Кстати, в TypeDef нумерация строк начинается с 2.
            // Это означает, что при построении новой сборки должны присутствовать все файлы, на которые она ссылается.


            // Добавление сборок в проект в среде Visual Studio
            // Add Reference -> Reference Manager
            // Раздел COM в диалоговом окне Reference Manager позволяет получить доступ к неуправляемому COM-серверу из управляемого кода через класс-представитель, автоматически генерируемый Visual Studio.
            
            // Использование утилиты Assembly Linker
            // Вместо компилятора C# для создания сборки можно задействовать компоновщик сборок (assembly linker) AL.exe.

            // Включение в сборку файлов ресурсов
            // В Visual Studio файл ресурсов добавляют в сборку на вкладке Application в диалоговом окне свойств проекта.

            // Ресурсы со сведениями о версии сборки
            // Для получения этой информации из программы служит статический метод GetVersionInfo типа System.Diagnostics.FileVersionInfo.
            // using System.Reflection;
            // // Информация версии поля FileDescription:
            // [assembly: AssemblyTitle("MultiFileLibrary.dll")]
            // // Информация версии поля Comments:
            // [assembly: AssemblyDescription("This assembly contains MultiFileLibrary's types")]
            // // Информация версии поля CompanyName:
            // [assembly: AssemblyCompany("Wintellect")]
            // // Информация версии поля ProductName:
            // [assembly: AssemblyProduct("Wintellect (R) MultiFileLibrary's Type Library")]
            // // Информация версии поля LegalCopyright:
            // [assembly: AssemblyCopyright("Copyright (c) Wintellect 2013")]
            // // Информация версии поля LegalTrademarks:
            // [assembly:AssemblyTrademark("MultiFileLibrary is a registered trademark
            // of Wintellect")]
            // // Информация версии поля AssemblyVersion:
            // [assembly: AssemblyVersion("3.0.0.0")]
            // // Информация версии поля FILEVERSION/FileVersion:
            // [assembly: AssemblyFileVersion("1.0.0.0")]
            // // Информация версии поля PRODUCTVERSION/ProductVersion:
            // [assembly: AssemblyInformationalVersion("2.0.0.0")]
            // // Задать поле Language (см. далее раздел "Региональные стандарты")
            // [assembly:AssemblyCulture("")]
            // Обратите внимание на отсутствие аналогичных параметров у компилятора C#; поэтому сведения о версии обычно задают, применяя специализированные атрибуты.
            
            // Поля ресурса со сведениями о версии и соответствующие. им параметры AL.exe и пользовательские атрибуты
            // FILEVERSION - /fileversion - System.Reflection.AssemblyFileVersionAttribute
            // PRODUCTVERSION - /productversion - System.Reflection.AssemblyInformational - VersionAttribute
            // FILEFLAGSMASK - Нет - Всегда задается равным VS_FFI_FILEFLAGSMASK (определяется в WinVer.h как 0x0000003F)
            // FILEFLAGS - Нет - Всегда равен 0
            // FILEOS - Нет - В настоящее время всегда равен VOS__WINDOWS32
            // FILETYPE - /target - Задается равным VFT_APP, если задан параметр /target:exe или /target:winexe. При наличии параметра /target:library приравнивается VFT_DLL 
            // FILESUBTYPE - Нет - Всегда задается равным VFT2_UNKNOWN (это поле не имеет значения для VFT_APP и VFT_DLL)
            // AssemblyVersion - /version - System.Reflection.AssemblyVersionAttribute
            // Comments - /description - System.Reflection.AssemblyDescriptionAttribute
            // CompanyName - /company - System.Reflection.AssemblyCompanyAttribute
            // FileDescription - /title - System.Reflection.AssemblyTitleAttribute
            // FileVersion - /version - System.Reflection.AssemblyVersionAttribute
            // InternalName - /out - Задается равным заданному имени выходного файла (без расширения)
            // LegalCopyright - /copyright - System.Reflection.AssemblyCopyrightAttribute
            // LegalTrademarks - /trademark - System.Reflection.AssemblyTrademarkAttribute
            // OriginalFilename - /out - Задается равным заданному имени выходного файла (без пути)
            // PrivateBuild - Нет - Всегда остается пустым
            // ProductName - /product - System.Reflection.AssemblyProductAttribute
            // ProductVersion - /productversion - System.Reflection.AssemblyInformational - VersionAttribute
            // SpecialBuild - Нет - Всегда остается пустым
            // При создании нового проекта C# в Visual Studio файл AssemblyInfo.cs генерируется автоматически. Он содержит все атрибуты сборки, описанные в этом разделе, а также несколько дополнительных — о них речь идет в главе 3. Можно просто открыть файл AssemblyInfo.cs и изменить относящиеся к конкретной сборке сведения. Visual Studio также предоставляет диалоговое окно для редактирования информации о версии сборки

            // Номера версии
            // Формат номеров версии:
            // Старший номер.Младший номер.Номер компоновки.Номер редакции
            // AssemblyFileVersion - этот номер версии хранится в ресурсе версии Win32 и предназначен лишь для информации, CLR его полностью игнорирует. Обычно устанавливают старший и младший номера версии, определяющие отображаемый номер версии. Далее при каждой компоновке увеличивают номер компоновки и редакции. Теоретически инструмент от компании Microsoft (например, CSC.exe или AL.exe) должен автоматически обновлять номера компоновки и редакции (в зависимости от даты и времени на момент компоновки), но этого не происходит. Этот номер версии отображается Проводником Windows и служит для определения точного времени компоновки сборки.
            // AssemblyInformationalVersion — этот номер версии также хранится в ресурсе версии Win32 и, как и предыдущий, предназначен лишь для информации; CLR его игнорирует. Этот номер служит для указания версии продукта, в который входит сборка. Например, продукт версии 2.0 может состоять из нескольких сборок. Одна из них может отмечаться как версия 1.0, если это новая сборка, не входившая в комплект поставки продукта версии 1.0. Обычно отображаемый номер версии формируется из старшего и младшего номеров версии. Затем номера компоновки и редакции увеличивают при каждой упаковке всех сборок готового продукта.
            // AssemblyVersion — этот номер версии хранится в манифесте, в таблице метаданных AssemblyDef. CLR использует этот номер версии для привязки к сборкам, имеющим строгие имена (о них рассказано в главе 3). Этот номер версии чрезвычайно важен, так как он однозначно идентифицирует сборку. Начиная разработку сборки, следует задать старший и младший номера версии, а также номера компоновки и редакции; не меняйте их, пока не будете готовы начать работу над следующей версией сборки, пригодной для развертывания. При создании сборки, ссылающейся на другую, этот номер версии включается в нее в виде записи таблицы AssemblyRef. Это значит, что сборка знает, с какой версией она была построена и протестирована. CLR может загрузить другую версию, используя механизм перенаправления привязки, описанный в главе 3.


            // Региональные стандарты
            // Помимо номера версии, сборки идентифицируют региональными стандартами (culture).
            // Основной тег - Вспомогательный тег - Региональные стандарты
            // В общем случае сборкам с кодом не назначают региональные стандарты, так как код обычно не содержит зависящих от них встроенных параметров. Сборку, для которой не определен региональный стандарт, называют сборкой с нейтральными региональными стандартами (culture neutral).
            // После этого можно создать одну или несколько отдельных сборок, содержащих только ресурсы, зависящие от региональных стандартов, и никакого программного кода. Сборки, помеченные для применения в определенных региональных стандартах, называют сопутствующими (satellite assemblies).
            // Рекомендуется создавать отдельную сопутствующую сборку для каждого регионального стандарта, который вы намерены поддерживать.
            // Во время выполнения доступ к ресурсам сопутствующей сборки осуществляют через класс System.Resources.ResourceManager.


            // Развертывание простых приложений (закрытое развертывание сборок)
            // Для приложений Windows Store устанавливаются исключительно жесткие правила упаковки сборок.
            // Windows устанавливает сборки в разные каталоги, чтобы несколько версий одного приложения могли одновременно существовать на одной машине.
            // Пакетный файл или подобная простая «установочная программа» скопирует приложение на машину пользователя, однако для создания ярлыков на рабочем столе, в меню Пуск (Start) и на панели быстрого запуска понадобится программа посложнее. Кроме того, скопировать, восстановить или переместить приложение с одной машины на другую легко, но ссылки и ярлыки потребуют специального обращения.
            // Естественно, в Visual Studio есть встроенные механизмы, которые можно задействовать для публикации приложений, — это делается на вкладке Publish страницы 90 свойств проекта.
            // Сборки, развертываемые в том же каталоге, что и приложение, называют сборками с закрытым развертыванием (privately deployed assemblies), так как файлы сборки не используются совместно другими приложениями (если только другие приложения не развертывают в том же каталоге).

            // Простое средство администрирования (конфигурационный файл)
            // Конфигурационные файлы содержат XML-теги и могут ассоциироваться с приложением или с компьютером. Использование отдельного файла (вместо параметров, хранимых в реестре) позволяет легко создать резервную копию файла, а администратору — без труда копировать файлы с машины на машину: достаточно скопировать нужные файлы — в результате будет также скопирована административная политика.
            // Желаемая структура каталогов с файлами выглядит следующим образом:
            //Каталог AppDir (содержит файлы сборки приложения)
            //Program.exe
            //Program.exe.config (обсуждается ниже)
            //Подкаталог AuxFiles (содержит файлы сборки MultiFileLibrary)
            //MultiFileLibrary.dll
            //FUT.netmodule
            //RUT.netmodule
            // Имя этого файла должно совпадать с именем главного файла сборки и иметь расширение config, в данном случае — Program.exe.config. Содержимое этого конфигурационного файла должно выглядеть примерно следующим образом:
            //<configuration>
            //<runtime>
            //<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
            //<probing privatePath="AuxFiles" />
            //</assemblyBinding>
            //</runtime>
            //</configuration>

            // Алгоритм поиска файлов сборки
            // Порядок при поиске сборки с нейтральными региональными стандартами таков
            //AppDir\AsmName.dll
            //AppDir\AsmName\AsmName.dll
            //AppDir\firstPrivatePath\AsmName.dll
            //AppDir\firstPrivatePath\AsmName\AsmName.dll
            //AppDir\secondPrivatePath\AsmName.dll
            //AppDir\secondPrivatePath\AsmName\AsmName.dll
            // Как видите, CLR ищет файлы с расширением EXE или DLL. Поскольку поиск может занимать значительное время (особенно когда CLR пытается найти файлы в сети), в конфигурационном XML-файле можно указать один или несколько элементов региональных стандартов culture, чтобы ограничить круг проверяемых каталогов при поиске сопутствующих сборок.
            // - Для исполняемых приложений (EXE) конфигурационный файл должен располагаться в базовом каталоге приложения. У него должно быть то же имя, что и у EXE-файла, но с расширением config.
            // - Для приложений Microsoft ASP.NET Web Form конфигурационный файл всегда должен находиться в виртуальном корневом каталоге веб-приложения и называться Web.config. Кроме того, в каждом вложенном каталоге может быть собственный файл Web.config с унаследованными параметрами конфигурации.


            // !!!
            // - sealed +
            SealedTesting();
            // - ildasm
        }

        public static void SealedTesting()
        {
            // При применении к классу, модификатор sealed запрещает другим классам наследовать от этого класса. В приведенном примере класс B наследует от класса A, но никакие классы не могут наследовать от класса B.
            // Модификатор sealed можно использовать для метода или свойства, которое переопределяет виртуальный метод или свойство в базовом классе. Это позволяет классам наследовать от вашего класса, запрещая им при этом переопределять определенные виртуальные методы или свойства.
            // Чтобы предотвратить переопределение производных классов при определении новых методов или свойств, не назначайте их в качестве виртуальных (virtual).
            // Нельзя использовать модификатор abstract с sealed-классом, поскольку абстрактный класс должен наследоваться классом, реализующим абстрактные методы или свойства.
            // При применении sealed модификатора к методу или свойству его необходимо всегда использовать с override.
            // Поскольку структуры неявно запечатаны, их нельзя наследовать.
        }
    }
}
