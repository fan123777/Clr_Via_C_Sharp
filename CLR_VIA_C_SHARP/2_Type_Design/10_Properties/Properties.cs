using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._10_Properties
{
    class Properties
    {
        public static void main()
        {
            test_properties_without_parameters();
            test_tuple();
            test_indexer();
        }

        public sealed class Employee
        {
            public String Name; // Имя сотрудника
            public Int32 Age; // Возраст сотрудника
        }

        public sealed class Employee1
        {
            private String m_Name; // Поле стало закрытым
            private Int32 m_Age; // Поле стало закрытым
            public String GetName()
            {
                return (m_Name);
            }
            public void SetName(String value)
            {
                m_Name = value;
            }
            public Int32 GetAge()
            {
                return (m_Age);
            }
            public void SetAge(Int32 value)
            {
                // if (value < 0)
                //     throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
                m_Age = value;
            }
        }

        public sealed class Employee2
        {
            private String m_Name;
            private Int32 m_Age;
            public String Name
            {
                get { return (m_Name); }
                set { m_Name = value; } // Ключевое слово value
            } // идентифицирует новое значение

            public Int32 Age
            {
                get { return (m_Age); }
                set
                {
                    // if (value < 0) // Ключевое слово value всегда идентифицирует новое значение
                    //     throw new ArgumentOutOfRangeException("value", value.ToString(), "The value must be greater than or equal to 0");
                    m_Age = value;
                }
            }

            // Это свойство является автоматически реализуемым
            public String AIP { get; set; }
        }

        private static void test_properties_without_parameters()
        {
            Employee e = new Employee();
            e.Name = "Jeffrey Richter"; // Задаем имя сотрудника
            e.Age = 48; // Задаем возраст сотрудника
            Console.WriteLine(e.Name); // Выводим на экран "Jeffrey Richter"

            Employee1 e1 = new Employee1();
            e1.SetName("Jeffrey Richter"); // Обновление имени сотрудника
            String EmployeeName = e1.GetName(); // Получение возраста сотрудника
            e1.SetAge(41); // Обновление возраста сотрудника
            e1.SetAge(-5); // Выдача исключения
            // ArgumentOutOfRangeException
            Int32 EmployeeAge = e1.GetAge(); // Получение возраста сотрудника

            Employee2 e2 = new Employee2();
            e2.Name = "Jeffrey Richter"; // "Задать" имя сотрудника
            String EmployeeName2 = e2.Name; // "Получить" имя сотрудника
            e2.Age = 41; // "Задать" возраст сотрудника
            e2.Age = -5; // Вброс исключения
            // ArgumentOutOfRangeException
            Int32 EmployeeAge2 = e2.Age; // "Получить" возраст сотрудника

            Employee e3 = new Employee() { Name = "Jeff", Age = 45 };
            String s = new Employee { Name = "Jeff", Age = 45 }.ToString().ToUpper();

            Classroom classroom = new Classroom
            {
                Students = { "Jeff", "Kristin", "Aidan", "Grant" }
            };

            // Вывести имена 4 студентов, находящихся в классе
            foreach (var student in classroom.Students)
                Console.WriteLine(student);

            var table = new Dictionary<String, Int32> {{ "Jeffrey", 1 }, { "Kristin", 2 }, { "Aidan", 3 }, { "Grant", 4 }};

            // Определение типа, создание сущности и инициализация свойств
            var o1 = new { Name = "Jeff", Year = 1964 };

            // Вывод свойств на консоль
            Console.WriteLine("Name={0}, Year={1}", o1.Name, o1.Year); // Выводит:
            // Name=Jeff, Year=1964

            String Name = "Grant";
            DateTime dt = DateTime.Now;
            // Анонимный тип с двумя свойствами
            // 1. Строковому свойству Name назначено значение Grant
            // 2. Свойству Year типа Int32 Year назначен год из dt
            var o2 = new { Name, dt.Year };

            // Совпадение типов позволяет осуществлять операции сравнения и присваивания
            Console.WriteLine("Objects are equal: " + o1.Equals(o2));
            o1 = o2; // Присваивание

            // Это работает, так как все объекты имею один анонимный тип
            var people = new[] {
            o1, // См. ранее в этом разделе
            new { Name = "Kristin", Year = 1970 },
            new { Name = "Aidan", Year = 2003 },
            new { Name = "Grant", Year = 2008 }
            };
            // Организация перебора массива анонимных типов
            // (ключевое слово var обязательно).
            foreach (var person in people)
                Console.WriteLine("Person={0}, Year={1}", person.Name, person.Year);

            // String myDocuments = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            // var query =
            // from pathname in Directory.GetFiles(myDocuments)
            // let LastWriteTime = File.GetLastWriteTime(pathname)
            // where LastWriteTime > (DateTime.Now - TimeSpan.FromDays(7))
            // orderby LastWriteTime
            // select new { Path = pathname, LastWriteTime };
            // foreach (var file in query)
            //     Console.WriteLine("LastWriteTime={0}, Path={1}",
            //     file.LastWriteTime, file.Path);
        }

        public sealed class Classroom
        {
            private List<String> m_students = new List<String>();
            public List<String> Students { get { return m_students; } }
            public Classroom() { }
        }

        private static void test_tuple()
        {
            var minmax = MinMax(6, 2);

            Console.WriteLine("Min={0}, Max={1}", minmax.Item1, minmax.Item2); // Min=2, Max=6
        }

        // Возвращает минимум в Item1 и максимум в Item2
        private static Tuple<Int32, Int32> MinMax(Int32 a, Int32 b)
        {
            return new Tuple<Int32, Int32>(Math.Min(a, b), Math.Max(a, b));
        }

        private static void test_indexer()
        {
            // Выделить массив BitArray, который может хранить 14 бит
            BitArray ba = new BitArray(14);
            // Установить все четные биты вызовом метода доступа set
            for (Int32 x = 0; x < 14; x++)
            {
                ba[x] = (x % 2 == 0);
            }
            // Вывести состояние всех битов вызовом метода доступа get
            for (Int32 x = 0; x < 14; x++)
            {
                Console.WriteLine("Bit " + x + " is " + (ba[x] ? "On" : "Off"));
            }
        }

        public sealed class BitArray
        {
            // Закрытый байтовый массив, хранящий биты
            private Byte[] m_byteArray;
            private Int32 m_numBits;
            // Конструктор, выделяющий память для байтового массива
            // и устанавливающий все биты в 0
            public BitArray(Int32 numBits)
            {
                // Начинаем с проверки аргументов
                if (numBits <= 0)
                    throw new ArgumentOutOfRangeException("numBits must be > 0");
                // Сохранить число битов
                m_numBits = numBits;
                // Выделить байты для массива битов
                m_byteArray = new Byte[(numBits + 7) / 8];
            }
            // Индексатор (свойство с параметрами)
            public Boolean this[Int32 bitPos]
            {
                // Метод доступа get индексатора
                get
                {
                    // Сначала нужно проверить аргументы
                    if ((bitPos < 0) || (bitPos >= m_numBits))
                        throw new ArgumentOutOfRangeException("bitPos");
                    // Вернуть состояние индексируемого бита
                    return (m_byteArray[bitPos / 8] & (1 << (bitPos % 8))) != 0;
                }
                // Метод доступа set индексатора
                set
                {
                    if ((bitPos < 0) || (bitPos >= m_numBits))
                        throw new ArgumentOutOfRangeException(
                        "bitPos", bitPos.ToString());
                    if (value)
                    {
                        // Установить индексируемый бит
                        m_byteArray[bitPos / 8] = (Byte)
                        (m_byteArray[bitPos / 8] | (1 << (bitPos % 8)));
                    }
                    else
                    {
                        // Сбросить индексируемый бит
                        m_byteArray[bitPos / 8] = (Byte)
                        (m_byteArray[bitPos / 8] & ~(1 << (bitPos % 8)));
                    }
                }
            }
        }

        public class SomeType
        {
            private String m_name;
            public String Name
            {
                get { return m_name; }
                protected set { m_name = value; }
            }
        }

        // Свойства позволяют обратиться к методу в исходном тексте программы с использованием упрощенного синтаксиса. CLR поддерживает два вида свойств: без параметров, их называют просто — свойства, и с параметрами — у них в разных языках разное название. Например, в C# свойства с параметрами называют индексаторами.
        
        // Свойства без параметров
        // Методы, выполняющие функции оболочки для доступа к полю, обычно называют методами доступа (accessor).
        // У каждого свойства есть имя и тип (но не void). Нельзя перегружать свойства (то есть определять несколько свойств с одинаковыми именами, но разным типом).
        // Определяя свойство, обычно описывают пару методов: get и set. Однако опустив метод set, можно определить свойство, доступное только для чтения, а опуская только метод get, мы получим свойство, доступное только для записи.
        // При определении свойства компилятор генерирует и помещает в результирующий управляемый модуль следующее:
        // - метод get свойства генерируется, только если для свойства определен метод доступа get;
        // - метод set свойства генерируется, только если для свойства определен метод доступа set;
        // - определение свойства в метаданных управляемого модуля генерируется всегда.

        // Автоматически реализуемые свойства
        // Лично мне не нравятся автоматически реализуемые свойства, обычно я стараюсь их избегать по нескольким причинам.
        // - Синтаксис объявления поля может включать инициализацию, таким образом, вы объявляете и инициализируете поле в одной строке кода. Однако нет подходящего синтаксиса для установки при помощи AIP начального значения. Следовательно, необходимо неявно инициализировать все автоматически реализуемые свойства во всех конструкторах.
        // - Механизм сериализации на этапе выполнения сохраняет имя поля в сериализованном потоке. Имя резервного поля для AIP определяется компилятором, и он может менять это имя каждый раз, когда компилирует код, сводя на нет возможность десериализации экземпляров всех типов, содержащих автоматически реализуемые свойства. Не используйте этот механизм для типов, подлежащих сериализации и десериализации.
        // - Во время отладки нельзя установить точку останова в AIP-методах set и get, поэтому вы не сможете легко узнать, когда приложение получает и задает значение автоматически реализуемого свойства. Точки останова можно устанавливать только в тех свойствах, которые программист пишет самостоятельно.

        // Осторожный подход к определению свойств
        // Столкнувшись с кодом, который вроде бы обращается к полю, разработчик привычно предполагает наличие множества условий, которые далеко не всегда соблюдаются, если речь идет о свойстве.
        // - Свойства могут быть доступны только для чтения или только для записи, в то время как поля всегда доступны и для чтения, и для записи. Определяя свойство, лучше всего создавать для него оба метода доступа (get и set).
        // - Свойство, являясь по сути методом, может выдавать исключения, а при обращениям к полям исключений не бывает.
        // - Свойства нельзя передавать в метод в качестве параметров с ключевым словом out или ref, в частности, следующий код не компилируется.
        // - Свойство-метод может выполняться довольно долго, в то время как обращения к полям выполняются моментально. Часто свойства применяют для синхронизации потоков, но это может привести к приостановке потока на неопределенное время, поэтому свойства не следует использовать для этих целей — в такой ситуации лучше задействовать метод. Кроме того, если предусмотрен удаленный доступ к классу (например, если он наследует от System.MarshalByRefObject), вызов свойства-метода выполняется очень медленно, поэтому предпочтение следует отдать методу. Я считаю, что в классах, производных от MarshalByRefObject, никогда не следует использовать свойства.
        // - При нескольких вызовах подряд свойство-метод может возвращать разные значения, а поле возвращает одно и то же значение. В классе System.DateTime есть неизменяемое свойство Now, которое возвращает текущие дату и время. При каждом последующем вызове свойство возвращает новое значение. Это ошибка, и в компании Microsoft охотно исправили бы этот класс, превратив Now в метод. Другой пример подобной ошибки — свойство Environment.TickCount 
        // - Свойство-метод может порождать видимые побочные эффекты, невозможные при доступе к полю. Иначе говоря, порядок определения значений различных свойств типа никак не должен влиять на поведение типа, однако в действительности часто бывает не так.
        // - Свойству-методу может требоваться дополнительная память или ссылка на объект, не являющийся частью состояния объекта, поэтому изменение возвращаемого объекта никак не сказывается на исходном объекте; при запросе поля всегда возвращается ссылка на объект, который гарантированно относится к состоянию исходного объекта. Свойство, возвращающее копию, — источник путаницы для разработчиков, причем об этом часто забывают упомянуть в документации.

        // Свойства и отладчик Visual Studio
        // Например, пусть вы создали поток FileStream для файла, передаваемого по сети, и затем добавили свойство FileStream.Length в окно просмотра отладчика. Каждый раз при переходе к точке останова отладчик вызовет метод доступа get, который во внутренней реализации выполнит сетевой запрос к серверу для получения текущей длины файла!
        // Из-за этих потенциальных проблем Visual Studio позволяет отключить режим вычислений для свойств, указанных в окне просмотра отладчика. Для этого выберите команду ToolsOptions, в списке открывшегося окна Options раскройте ветвь DebuggingGeneral и сбросьте флажок Enable Property Evaluation And Other Implicit Function Calls

        // Инициализаторы объектов и коллекций
        // Создание объекта с заданием некоторых открытых свойств (или полей) — чрезвычайно распространенная операция. Для ее упрощения в C# предусмотрен специальный синтаксис инициализации объекта
        // С# также позволяет опустить круглые скобки перед открывающей фигурной скобкой, если вы хотите вызвать конструктор без параметров.
        // Если тип свойства реализует интерфейс IEnumerable или IEnumerable<T>, то свойство является коллекцией, а инициализация коллекции является дополняющей операцией (а не заменяющей).

        // Анонимные типы
        // Кортежный тип (tuple type) — это тип, который содержит коллекцию свойств, каким-то образом связанных друг с другом.
        // Для передачи кортежного типа следует использовать тип System.Tuple, о котором речь идет в следующем разделе.

        // Тип System.Tuple
        // Чтобы создать тип Tuple с более, чем восьмью элементами, передайте другой объект Tuple в параметре Rest.
        // ПримечАние
        // Кроме анонимных и кортежных типов, стоит присмотреться к классу System.Dynamic.ExpandoObject (определенному в сборке System.Core.dll assembly). При использовании этого класса с динамическим типом C# (о котором говорится в главе 5) появляется другой способ группировки наборов свойств (пар ключ-значение) вместе. Полученный в результате тип не обладает безопасностью типов на стадии компиляции, зато синтаксис выглядит отлично (хотя вы лишаетесь поддержки IntelliSense), а объекты ExpandoObject могут передаваться между C# и такими динамическими языками, как Python. Пример кода с использованием объекта ExpandoObject:

        // Свойства с параметрами
        // поддержке индексаторов в C# на основе свойств с параметрами.
        // Поскольку CLR обрабатывает свойства с параметрами и без них одинаково, компилятор генерирует в итоговой управляемой сборке два или три элемента из следующего списка:
        // - метод get свойства с параметрами генерируется только в том случае, если у свойства определен метод доступа get;
        // - метод set свойства с параметрами генерируется только в том случае, если у свойства определен метод доступа set;
        // - определение свойства в метаданных управляемого модуля генерируется всегда; в метаданных нет отдельной таблицы для хранения определений свойств с параметрами: ведь для CLR свойства с параметрами — просто свойства.
        // Компилятор автоматически генерирует имена этих методов, добавляя к имени индексатора префикс get_ или set_. Поскольку синтаксис индексаторов в C# не позволяет разработчику задавать имя индексатора, создателям компилятора C# пришлось самостоятельно выбрать имя для методов доступа, и они выбрали Item. Поэтому имена созданных компилятором методов — get_Item и set_Item.
        // В C# в одном типе можно определять несколько индексаторов при условии, что они получают разные наборы параметров.
        // Как видите, C# рассматривает индексаторы как механизм перегрузки оператора [], и этот оператор не позволяет различать свойства с одинаковыми наборами параметров и разными именами методов доступа.

        // Выбор главного свойства с параметрами
        // При анализе ограничений, которые C# налагает на индексаторы, возникает два вопроса:
        // - Что если язык, на котором написан тип, позволяет разработчику определить несколько свойств с параметрами?
        // - Как использовать этот тип в программе на C#?
        // Ответ: в этом типе надо выбрать один из методов среди свойств с параметрами и сделать его свойством по умолчанию, применив к самому классу экземпляр System.Reflection.DefaultMemberAttribute. Кстати, DefaultMemberAttribute можно применять к классам, структурам или интерфейсам. В С# при компиляции типа, определяющего свойства с параметрами, компилятор автоматически применяет к определяющему типу экземпляр атрибута DefaultMember и учитывает его при использовании атрибута IndexerName. Конструктор этого атрибута задает имя, которое будет назначено свойству с параметрами, выбранному как свойство по умолчанию для этого типа.
        // Помните: C# не будет компилировать код, содержащий разноименные свойства с параметрами.
        // программах на языке, поддерживающем несколько свойств с параметрами, нужно выбрать один метод свойства и пометить его атрибутом DefaultMember. Это будет единственное свойство с параметрами, доступное программам на C#.
        
        // Производительность при вызове методов доступа
        // В случае простых методов доступа get и set JIT-компилятор подставляет (inlines) код метода доступа внутрь кода вызываемого метода, поэтому характерного снижения производительности работы программы, проявляющегося при использовании свойств вместо полей, не наблюдается.
        
        // Доступность методов доступа свойств
        // Иногда при проектировании типа требуется назначить методам доступа get и set разный уровень доступа. Чаще всего применяют открытый метод доступа get и закрытый метод доступа set
        
        // Обобщенные методы доступа свойств
        // C# не позволяет этого делать. Главная причина в том, что обобщения свойств лишены смысла с концептуальной точки зрения.


        // !!!
    }
}
