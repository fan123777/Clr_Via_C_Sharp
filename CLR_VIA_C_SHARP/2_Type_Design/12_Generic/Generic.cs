using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.IO;

namespace CLR_VIA_C_SHARP._2_Type_Design._12_Generic
{
    class Generic
    {
        public static void main()
        {
            SomeMethod();
            testArray();
            tetsGeneric();
            SameDataLinkedList();
            DifferentDataLinkedList();
            testContVariant();
            CallingSwapUsingInference();
            TestVerificationProblems();
        }

        private static void SomeMethod()
        {
            // Создание списка (List), работающего с объектами DateTime
            List<DateTime> dtList = new List<DateTime>();
            // Добавление объекта DateTime в список
            dtList.Add(DateTime.Now); // Без упаковки
            // Добавление еще одного объекта DateTime в список
            dtList.Add(DateTime.MinValue); // Без упаковки
            // Попытка добавить объект типа String в список
            // dtList.Add("1/1/2004"); // Ошибка компиляции
            // Извлечение объекта DateTime из списка
            DateTime dt = dtList[0]; // Приведение типов не требуется
        }

        private static void testArray()
        {
            // Создание и инициализация массива байтов
            Byte[] byteArray = new Byte[] { 5, 1, 4, 2, 3 };
            // Вызов алгоритма сортировки Byte[]
            Array.Sort<Byte>(byteArray);
            // Вызов алгоритма двоичного поиска Byte[]
            Int32 i = Array.BinarySearch<Byte>(byteArray, 1);
            Console.WriteLine(i); // Выводит "0"
        }

        private static void tetsGeneric()
        {
            Object o = null;
            // Dictionary<,> — открытый тип с двумя параметрами типа
            Type t = typeof(Dictionary<,>);
            // Попытка создания экземпляра этого типа (неудачная)
            o = CreateInstance(t);
            Console.WriteLine();
            // DictionaryStringKey<> — открытый тип с одним параметром типа
            t = typeof(DictionaryStringKey<>);
            // Попытка создания экземпляра этого типа (неудачная)
            o = CreateInstance(t);
            Console.WriteLine();
            // DictionaryStringKey<Guid> — это закрытый тип
            t = typeof(DictionaryStringKey<Guid>);
            // Попытка создания экземпляра этого типа (удачная)
            o = CreateInstance(t);
            // Проверка успешности попытки
            Console.WriteLine("Object type=" + o.GetType());
        }

        private static Object CreateInstance(Type t)
        {
            Object o = null;
            try
            {
                o = Activator.CreateInstance(t);
                Console.Write("Created instance of {0}", t.ToString());
            }
            catch (ArgumentException e)
            {
                Console.WriteLine(e.Message);
            }
            return o;
        }

        // Частично определенный открытый тип
        internal sealed class DictionaryStringKey<TValue> :
        Dictionary<String, TValue>
        {
        }

        internal sealed class GenericTypeThatRequiresAnEnum<T>
        {
            static GenericTypeThatRequiresAnEnum()
            {
                if (!typeof(T).IsEnum)
                {
                    throw new ArgumentException("T must be an enumerated type");
                }
            }
        }

        internal sealed class Node<T>
        {
            public T m_data;
            public Node<T> m_next;
            public Node(T data)
                : this(data, null)
            {

            }

            public Node(T data, Node<T> next)
            {
                m_data = data; m_next = next;
            }

            public override String ToString()
            {
                return m_data.ToString() +
                ((m_next != null) ? m_next.ToString() : null);
            }
        }

        // Тогда код создания связного списка будет выглядеть примерно так:
        private static void SameDataLinkedList()
        {
            Node<Char> head = new Node<Char>('C');
            head = new Node<Char>('B', head);
            head = new Node<Char>('A', head);
            Console.WriteLine(head.ToString()); // Выводится "ABC"
        }

        private static void DifferentDataLinkedList()
        {
            Node head = new TypedNode<Char>('.');
            head = new TypedNode<DateTime>(DateTime.Now, head);
            head = new TypedNode<String>("Today is ", head);
            Console.WriteLine(head.ToString());
        }

        private static void testContVariant()
        {
            Func<Object, ArgumentException> fn1 = null;
            Func<String, Exception> fn2 = fn1; // Явного приведения типа не требуется
            Exception e = fn2("");
        }

        private static void CallingSwapUsingInference()
        {
            Int32 n1 = 1, n2 = 2;
            Swap(ref n1, ref n2); // Вызывает Swap<Int32>
            String s1 = "Aidan";
            Object s2 = "Grant";
            // Swap(ref s1, ref s2); // Ошибка, невозможно вывести тип
        }

        private static void Swap<T>(ref T o1, ref T o2)
        {
            T temp = o1;
            o1 = o2;
            o2 = temp;
        }

        private static void Display(String s)
        {
            Console.WriteLine(s);
        }

        private static void Display<T>(T o)
        {
            Display(o.ToString()); // Вызывает Display(String)
        }

        private static void TestVerificationProblems()
        {
            // Приведение переменной обобщенного типа
            CastingAGenericTypeVariable1(5);
            CastingAGenericTypeVariable2(5);
            // Для приведения к ссылочному типу также применяют оператор as языка C#.
            CastingAGenericTypeVariable3(5);
            // Присваивание переменной обобщенного типа значения по умолчанию
            SettingAGenericTypeVariableToNull<int>();
            // При создании C# в Microsoft посчитали, что разработчикам может понадобиться присвоить переменной значение по умолчанию.
            SettingAGenericTypeVariableToDefaultValue<String>();
            // Сравнение переменной обобщенного типа с null
            ComparingAGenericTypeVariableWithNull(5);
            // Сравнение двух переменных обобщенного типа
            ComparingTwoGenericTypeVariables(3, 4);
            // Использование переменных обобщенного типа в качестве операндов
            Sum(5);
        }

        private static void CastingAGenericTypeVariable1<T>(T obj)
        {
            // Int32 x = (Int32)obj; // Ошибка
            // String s = (String)obj; // Ошибка
        }

        private static void CastingAGenericTypeVariable2<T>(T obj)
        {
            Int32 x = (Int32)(Object)obj; // Ошибки нет
            String s = (String)(Object)obj; // Ошибки нет
        }

        private static void CastingAGenericTypeVariable3<T>(T obj)
        {
            String s = obj as String; // Ошибки нет
        }

        private static void SettingAGenericTypeVariableToNull<T>()
        {
            // T temp = null; // CS0403: нельзя привести null к параметру типа T
            // because it could be a value type...
            // (Ошибка CS0403: нельзя привести null к параметру типа Т,
            // поскольку T может иметь значимый тип...)
        }

        private static void SettingAGenericTypeVariableToDefaultValue<T>()
        {
            T temp = default(T); // Работает
        }

        private static void ComparingAGenericTypeVariableWithNull<T>(T obj)
        {
            if (obj == null)
            { /* Этот код никогда не исполняется для значимого типа */ }
        }

        private static void ComparingTwoGenericTypeVariables<T>(T o1, T o2)
        {
            // if (o1 == o2) { } // Ошибка
        }

        private static T Sum<T>(T num) where T : struct
        {
            T sum = default(T);
            // не работает
            // for (T n = default(T); n < num; n++)
            //     sum += n;
            return sum;
        }
    }

    internal class Node
    {
        protected Node m_next;
        public Node(Node next)
        {
            m_next = next;
        }
    }

    internal sealed class TypedNode<T> : Node
    {
        public T m_data;
        public TypedNode(T data)
            : this(data, null)
        {

        }

        public TypedNode(T data, Node next)
            : base(next)
        {
            m_data = data;
        }

        public override String ToString()
        {
            return m_data.ToString() +
        ((m_next != null) ? m_next.ToString() : String.Empty);
        }

        public static T Min<T>(T o1, T o2) where T : IComparable<T>
        {
            if (o1.CompareTo(o2) < 0) return o1;
            return o2;
        }

        private static List<TBase> ConvertIList<T, TBase>(IList<T> list)
        where T : TBase
        {
            List<TBase> baseList = new List<TBase>(list.Count);
            for (Int32 index = 0; index < list.Count; index++)
            {
                baseList.Add(list[index]);
            }
            return baseList;
        }

        private static void CallingConvertIList()
        {
            // Создает и инициализирует тип List<String> (реализующий IList<String>)
            IList<String> ls = new List<String>();
            ls.Add("A String");
            // Преобразует IList<String> в IList<Object>
            IList<Object> lo = ConvertIList<String, Object>(ls);
            // Преобразует IList<String> в IList<IComparable>
            IList<IComparable> lc = ConvertIList<String, IComparable>(ls);
            // Преобразует IList<String> в IList<IComparable<String>>
            IList<IComparable<String>> lcs =
            ConvertIList<String, IComparable<String>>(ls);
            // Преобразует IList<String> в IList<String>
            IList<String> ls2 = ConvertIList<String, String>(ls);
            // Преобразует IList<String> в IList<Exception>
            // IList<Exception> le = ConvertIList<String, Exception>(ls); // Ошибка
        }
    }

    internal sealed class GenericType<T>
    {
        private T m_value;
        public GenericType(T value) { m_value = value; }
        public TOutput Converter<TOutput>()
        {
            TOutput result = (TOutput)Convert.ChangeType(m_value, typeof(TOutput));
            return result;
        }
    }

    // Можно определить следующие типы:
    internal sealed class AType { }
    internal sealed class AType<T> { }
    internal sealed class AType<T1, T2> { }
    // Ошибка: конфликт с типом AType<T>, у которого нет ограничений.
    // internal sealed class AType<T> where T : IComparable<T> { }
    // Ошибка: конфликт с типом AType<T1, T2>
    // internal sealed class AType<T3, T4> { }
    internal sealed class AnotherType
    {
        // Можно определить следующие методы:
        private static void M() { }
        private static void M<T>() { }
        private static void M<T1, T2>() { }
        // Ошибка: конфликт с типом M<T>, у которого нет ограничений
        // private static void M<T>() where T : IComparable<T> { }
        // Ошибка: конфликт с типом M<T1, T2>.
        // private static void M<T3, T4>() { }
    }

    internal class Base
    {
        public virtual void M<T1, T2>()
            where T1 : struct
            where T2 : class
        {
        }
    }

    internal sealed class Derived : Base
    {
        public override void M<T3, T4>()
        // where T3 : EventArgs // Ошибка
        // where T4 : class // Ошибка
        { }
    }

    internal sealed class PrimaryConstraintOfStream<T> where T : Stream
    {
        public void M(T stream)
        {
            stream.Close();// OK
        }
    }

    internal sealed class PrimaryConstraintOfClass<T> where T : class
    {
        public void M()
        {
            T temp = null;// Допустимо, потому что тип T должен быть ссылочным
        }
    }

    internal sealed class PrimaryConstraintOfStruct<T> where T : struct
    {
        public static T Factory()
        {
            // Допускается, потому что у каждого значимого типа неявно
            // есть открытый конструктор без параметров
            return new T();
        }
    }

    internal sealed class ConstructorConstraint<T> where T : new()
    {
        public static T Factory()
        {
            // Допустимо, потому что у всех значимых типов неявно
            // есть открытый конструктор без параметров, и потому что
            // это ограничение требует, чтобы у всех указанных ссылочных типов
            // также был открытый конструктор без параметров
            return new T();
        }
    }

    // Обобщения (generics) — еще один механизм, поддерживаемый средой CLR и языками программирования для другой разновидности многократного использования кода — а именно многократного использования алгоритмов.
    // По сути, разработчик описывает алгоритм, например, сортировки, поиска, замены, сравнения или преобразования, но не указывает типы данных, с которыми тот работает, что позволяет применять алгоритм к объектам разных типов. Применяя готовый алгоритм, другой разработчик должен указать конкретные типы данных, например для алгоритма сортировки — Int32, String и т. д., а для алгоритма сравнения — DateTime, Version и т. д.
    // Большинство алгоритмов инкапсулировано в типе. CLR поддерживает создание как обобщенных ссылочных, так и обобщенных значимых типов, однако обобщенные перечислимые типы не поддерживаются. Кроме того, CLR позволяет создавать обобщенные интерфейсы и делегатов. Иногда полезный алгоритм инкапсулирован в одном методе, поэтому CLR поддерживает создание обобщенных методов, определенных в ссылочном типе, в значимом типе или в интерфейсе.
    // FCL-класс, инкапсулирующий обобщенный алгоритм управления списками, называется List<T> и определен в пространстве имен System.Collections.Generic.
    // Символами <T> сразу после имени класса автор обобщенного класса List указал, что класс работает с неопределенным типом данных. При определении обобщенного типа или метода переменные, указанные вместо типа (например, T), называются параметрами типа (type parameters). T — это имя переменной, которое применяется в исходном тексте во всех местах, где используется соответствующий тип данных.
    // Другой пример — метод-индексатор (в C# он называется this). У индексатора есть метод доступа get, возвращающий значение типа T, и метод доступа set, получающий параметр типа T. Переменную T можно использовать в любом месте, где должен указываться тип данных — а значит, и при определении локальных переменных внутри метода или полей внутри типа.
    // В рекомендациях Microsoft для проектировщиков указано, что переменные параметров должны называться T или, в крайнем случае, начинаться с T (как, например, TKey или TValue). T означает тип (type), а I означает интерфейс (например, IComparable).
    // В случае обобщенного типа или метода указанные типы данных называют аргументами-типами (type arguments).
    // На примере этого кода видны главные преимущества обобщений для разработчиков.
    // - Защита исходного кода. Разработчику, использующему обобщенный алгоритм, не нужен доступ к исходному тексту алгоритма (при работе с шаблонами C++ разработчику, использующему алгоритм, необходим его исходный текст).
    // - Безопасность типов. Когда обобщенный алгоритм применяется с конкретным типом, компилятор и CLR понимают это и следят за тем, чтобы в алгоритме использовались лишь объекты, совместимые с этим типом данных. Попытка использования несовместимого объекта приведет к ошибке на этапе компиляции или исключению во время выполнения. В нашем примере попытка передачи объекта String методу Add вызывает ошибку компиляции.
    // - Более простой и понятный код. Поскольку компилятор обеспечивает безопасность типов, в исходном тексте требуется меньше операция приведения типов, а такой код проще писать и сопровождать. В последней строке SomeMethod разработчику не нужно использовать приведение (DateTime), чтобы присвоить переменной dt результат вызова индексатора (при запросе элемента с индексом 0).
    // - Повышение производительности. До появления обобщений один из способов определения обобщенного алгоритма заключался в таком определении всех его членов, чтобы они «умели» работать с типом данных Object. Чтобы алгоритм работал с экземплярами значимого типа, перед вызовом членов алгоритма среда CLR должна была упаковать этот экземпляр. Как показано в главе 5, упаковка требует выделения памяти в управляемой куче, что приводит к более частым процедурам уборки мусора, а это, в свою очередь, снижает производительность приложения. Поскольку обобщенный алгоритм можно создать для работы с конкретным значимым типом, экземпляры значимого типа могут передаваться по значению и CLR не нужно выполнять упаковку. Операции приведения типа также не нужны (см. предыдущий пункт), поэтому CLR не нужно контролировать безопасность типов при их преобразовании, что также ускоряет работу кода. 
    // ПримечАние
    // Необходимо понимать, что CLR генерирует машинный код для любого метода при первом его вызове в применении к конкретному типу данных. Это увеличивает размер рабочего набора приложения и снижает производительность. Подробнее об этом мы поговорим чуть позже в разделе «Инфраструктура обобщений».

    // Обобщения в библиотеке FCL
    // Разумеется, обобщения применяются с классами коллекций, и в FCL определено несколько таких обобщенных классов. Большинство этих классов можно найти в пространствах имен System.Collections.Generic и System.Collections.ObjectModel.
    // Также имеются безопасные в отношении потоков классы коллекций в пространстве имен System.Collections.Concurrent. Microsoft рекомендует программистам отказаться от необобщенных классов коллекций в пользу их обобщенных аналогов по нескольким причинам. Во-первых, необобщенные классы коллекций, в отличие от обобщенных, не обеспечивают безопасность типов, простоту и понятность кода и повышение производительности. Во-вторых, объектная модель у обобщенных классов лучше, чем у необобщенных. Например, у них меньше виртуальных методов, что повышает производительность, а новые члены, добавленные в обобщенные коллекции, добавляют новую функциональность.
    // Большинство используемых интерфейсов содержится в пространстве имен System.Collections.Generic.
    // Также отмечу, что класс System.Array, базовый для всех типов массивов, поддерживает множество статических обобщенных методов, в том числе AsReadOnly, BinarySearch, ConvertAll, Exists, Find, FindAll, FindIndex, FindLast, FindLastIndex, ForEach, IndexOf, LastIndexOf, Resize, Sort и TrueForAll. Вот как выглядят некоторые из них:
    
    // Инфраструктура обобщений
    // Поддержка обобщений была добавлена в версию 2.0 CLR, над ее реализацией долго трудилось множество специалистов. Для поддержания работы обобщений Microsoft нужно было сделать следующее:
    // - Создать новые IL-команды, работающие с аргументами типа.
    // - Изменить формат существующих таблиц метаданных для выражения имен типов и методов с обобщенными параметрами.
    // - Обновить многие языки программирования (в том числе C#, Microsoft Visual Basic .NET и др.), чтобы обеспечить поддержку нового синтаксиса и позволить разработчикам определять и ссылаться на новые обобщенные типы и методы.
    // - Изменить компиляторы для генерации новых IL-команд и измененного формата метаданных.
    // - Изменить JIT-компилятор, чтобы он обрабатывал новые IL-команды, работающие с аргументами типа, и создавал корректный машинный код.
    // - Создать новые члены отражения, чтобы разработчики могли запрашивать информацию о типах и членах, проверяя у них наличие параметров.
    // - Определить новые члены, предоставляющие информацию отражения, чтобы разработчики могли создавать определения обобщенных типов и методов во время исполнения.
    // - Изменить отладчик, чтобы он поддерживал обобщенные типы, члены, поля и локальные переменные.
    // - Изменить функцию IntelliSense в Microsoft Visual Studio для отображения конкретных прототипов членов при использовании обобщенного типа или метода с указанием типа данных.
    
    // Открытые и закрытые типы
    // Я уже рассказывал, как CLR создает внутреннюю структуру данных для каждого типа, применяемого в приложении. Эти структуры данных называют объектами-типами (type objects). Обобщенный тип также считается типом, и для него CLR тоже создает внутренний объект-тип. Это справедливо для ссылочных типов (классов), значимых типов (структур), интерфейсов и делегатов. Тем не менее тип с обобщенными параметрами-типами называют открытым типом (open type), а в CLR запрещено конструирование экземпляров открытых типов (как и экземпляров интерфейсных типов).
    // При ссылке на обобщенный тип в коде можно определить набор обобщенных аргументов типа. Если всем аргументам определенного типа передаются действительные типы данных, то он становится закрытым типом (closed type). CLR разрешает создание экземпляров закрытых типов. Тем не менее в коде, ссылающемся на обобщенный тип, можно не определять все обобщенные аргументы типа. Таким образом, в CLR создается новый объект открытого типа, экземпляры которого создавать нельзя.
    // Необходимо отметить, что CLR размещает статические поля типа в самом объекте-типе.
    // Следовательно, каждый закрытый тип имеет свои статические поля. Иначе говоря, статические поля, определенные в объекте List<T>, не будут совместно использоваться объектами List<DateTime> и List<String>, потому что у каждого объекта закрытого типа есть свои статические поля. 
    // В CLR существует механизм ограничений (constraints), предлагающий более удачный инструмент определения обобщенного типа с указанием допустимых для него аргументов типа. Но об ограничениях — чуть позже. К сожалению, этот механизм не позволяет ограничить аргументы типа только перечислимыми типами, поэтому в предыдущем примере необходим статический конструктор для проверки того, что используемый тип является перечислимым. 
    
    // Обобщенные типы и наследование
    // Обобщенный тип, как и всякий другой, может быть производным от других типов. При использовании обобщенного типа с указанием аргументов типа в CLR определяется новый объект-тип, производный от того же типа, что и обобщенный тип. Например, тип List<T> является производным от Object, поэтому типы List<String> и List<Guid> тоже будут производными от Object. Аналогично, тип DictionaryStringKey<TValue> — производный от Dictionary<String, TValue>, поэтому тип DictionaryStringKey<Guid> также производный от Dictionary<String, Guid>. Понимание того, что определение аргументов типа не имеет ничего общего с иерархиями наследования, позволяет разобраться, какие приведения типов допустимы, а какие нет.
    
    // Идентификация обобщенных типов
    // using DateTimeList = System.Collections.Generic.List<System.DateTime>;
    // Здесь директива using просто определяет символическое имя DateTimeList. При компиляции кода компилятор заменяет все вхождения DateTimeList типом System.Collections.Generic.List<System.DateTime>. Таким образом, разработчики могут использовать упрощенный синтаксис, не меняя смысл кода и тем самым сохраняя идентификацию и тождество типов. 
    // Для удобства вы можете использовать свойство локальной переменной неявного типа языка C# (var), для которой компилятор обозначает тип локальной переменной метода из типа вашего выражения.

    // Разрастание кода
    // При JIT-компиляции обобщенного метода CLR подставляет в IL-код метода указанные аргументы-типы, а затем создает машинный код для данного метода, работающего с конкретными типами данных. Это именно то, что нужно, и это одна из основных функций обобщений. Но в таком подходе есть один недостаток: CLR генерирует машинный код для каждого сочетания «метод + тип», что приводит к разрастанию кода (code explosion); в итоге существенно увеличивается рабочий набор приложения, снижая производительность. 
    // К счастью, в CLR есть несколько механизмов оптимизации, призванных предотвратить разрастание кода. Во-первых, если метод вызывается для конкретного аргумента типа и позже он вызывается опять с тем же аргументом типа, CLR компилирует код для такого сочетания «метод + тип» только один раз. Поэтому, если List<DateTime> используется в двух совершенно разных сборках (загруженных в один домен приложений), CLR компилирует методы для List<DateTime> всего один раз. Это существенно сокращает степень разрастания кода.
    // Кроме того, CLR считает все аргументы ссылочного типа тождественными, что опять же обеспечивает совместное использование кода. Например, код, скомпилированный в CLR для методов List<String>, может применяться для методов List<Stream>, потому что String и Stream — ссылочные типы. По сути, для всех ссылочных типов используется одинаковый код. CLR выполняет эту оптимизацию, потому что все аргументы и переменные ссылочного типа — это просто указатели на объекты в куче (32-разрядное значение в 32-разрядной и 64-разрядное значение в 64-разрядной версии Windows), а все операции с указателями на объекты выполняются одинаково.
    
    // Обобщенные интерфейсы
    // Конечно же, основное преимущество обобщений — это способность определять обобщенные ссылочные и значимые типы. Но для CLR также исключительно важна поддержка обобщенных интерфейсов. Без них любая попытка работы со значимым типом через необобщенный интерфейс (например, IComparable) всякий раз будет приводить к необходимости упаковки и потере безопасности типов в процессе компиляции, что сильно сузило бы область применения обобщенных типов. Вот почему CLR поддерживает обобщенные интерфейсы. Ссылочный и значимый типы реализуют обобщенный интерфейс путем задания аргументов-типов, или же любой тип реализует обобщенный интерфейс, не задавая аргументы-типы. Рассмотрим несколько примеров. 
    // Обобщенные делегаты
    // Поддержка обобщенных делегатов в CLR позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов. Более того, благодаря обобщенным делегатам экземпляры значимого типа могут передаваться методам обратного вызова без упаковки.
    // делегат — это просто определение класса с помощью четырех методов: конструктора и методов Invoke, BeginInvoke и EndInvoke. При определении типа делегата с параметрами типа компилятор задает методы класса делегата, а параметры типа применяются ко всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.
    // ПримечАние
    // Там, где это возможно, рекомендуется использовать обобщенных делегатов Action и Func из библиотеки FCL. 
    
    // Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах
    // Каждый из параметров-типов обобщенного делегата должен быть помечен как ковариантный или контравариантный. Это позволяет вам осуществлять приведение типа переменной обобщенного делегата к тому же типу делегата с другим параметром-типом. Параметры-типы могут быть:
    // - Инвариантными. Параметр-тип не может изменяться. Пока в этой главе приводились только инвариантные параметры-типы.
    // - Контравариантными. Параметр-тип может быть преобразован от класса к классу, производному от него. В языке C# контравариантный тип обозначается ключевым словом in. Контравариантный параметр-тип может появляться только во входной позиции, например, в качестве аргументов метода.
    // - Ковариантными. Аргумент-тип может быть преобразован от класса к одному из его базовых классов. В языке С# ковариантный тип обозначается ключевым словом out. Ковариантный параметр обобщенного типа может появляться только в выходной позиции, например, в качестве возвращаемого значения метода.
    // public delegate TResult Func<in T, out TResult>(T arg);
    // Здесь параметр-тип T помечен словом in, делающим его контравариантным, а параметр-тип TResult помечен словом out, делающим его ковариантным.
    // ПримечАние
    // Вариантность действует только в том случае, если компилятор сможет установить возможность преобразования ссылок между типами. Другими словами, вариантность неприменима для значимых типов из-за необходимости упаковки (boxing). Я считаю, что из-за этого ограничения вариантность существенно теряет свою полезность. Например:
    // void ProcessCollection(IEnumerable<Object> collection) { ... }
    // Я не смогу вызвать этот метод, передавая ссылку на объект List<DateTime> из-за невозможности ссылочного преобразования между значимым типом DateTime и объектом Object, даже если DateTime унаследован от объекта Object. Можно решить эту проблему следующим образом:
    // void ProcessCollection<T>(IEnumerable<T> collection) { ... }
    // Большое преимущество записи ProcessCollection(IEnumerable<Object> collection) заключается в том, что здесь используется только одна версия JIT-кода. Однако для ProcessCollection<T> (IEnumerable<T> collection) тоже существует только одна версия JIT-кода, совместно используемая всеми T, являющимися ссылочными типами. Для T, являющихся значимыми типами, будут генерироваться другие версии JIT-кода, но по крайней мере теперь можно вызвать метод с передачей ему коллекции значимого типа.
    // Вариантность также недопустима для параметра-типа, если при передаче аргумента этого типа используются ключевые слова out и ref. Например, для строки:
    // delegate void SomeDelegate<in T>(ref T t);
    // компилятор выдает следующее сообщение об ошибке (недействительная вариантность: параметр-тип 'T' должен быть инвариантно действительным для 'SomeDelegate<T>.Invoke(ref T)'. Параметр-тип 'T' контравариантен):
    // При использовании делегатов с обобщенными аргументами и возвращаемыми значениями рекомендуется всегда использовать ключевые слова in и out для обозначения контравариантности и ковариантности везде, где это возможно. Это не приводит ни к каким нежелательным последствиям, но позволит применять ваших делегатов в большем количестве сценариев.
    // Как и в случае с делегатами, параметры-типы интерфейсов могут быть либо контравариантными, либо ковариантными. Приведу пример интерфейса с контравариантным параметром обобщенного типа:
    // public interface IEnumerator<out T> : IEnumerator
    // {
    //  Boolean MoveNext();
    //  T Current { get; }
    // }
    // Внимание
    // Иногда разработчики спрашивают, почему они должны явно указывать слово in или out в параметрах обобщенного типа. Они полагают, что компилятор может самостоятельно проверить объявление делегатов или интерфейсов и автоматически определить, являются ли параметры обобщенного типа контравариантными или ковариантными. Несмотря на то что компилятор действительно может это определять автоматически, разработчики языка C# считают, что при определении контракта следует указывать эти слова в явном виде. Представьте, что компилятор определил, что параметр обобщенного типа контравариантен, а затем в будущем в интерфейс будет добавлен член с параметром-типом в выходной позиции. В следующий раз при компиляции компилятор определит, что этот параметр-тип инвариантен, но в тех местах кода, где используется факт контравариантности параметра-типа, могут возникнуть ошибки.
    // По этой причине разработчики компилятора требуют точно определять параметр-тип. При попытке использования этого параметра-типа в контексте, не соответствующем объявлению, компилятор выдаст ошибку с сообщением о нарушении контракта. Если потом вы решите исправить код путем добавления in или out для параметров-типов, вам придется внести изменения в программный код, использующий старый контракт.

    // Обобщенные методы
    // При определении обобщенного ссылочного и значимого типа или интерфейса все методы, определенные в этих типах, могут использовать их параметр-тип. Параметр-тип может использоваться для параметров метода, возвращаемого значения метода или типа заданной внутри него локальной переменной. Но CLR также позволяет методу иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных.
    // Использование обобщенных типов с методами, получающими параметры out и ref, особенно интересно тем, что переменные, передаваемые в качестве аргумента out/ref, должны быть того же типа, что и параметр метода, чтобы избежать возможного нарушения безопасности типов. Эта особенность параметров out/ref обсуждается в главе 9.
    
    // Обобщенные методы и выведение типов
    // Синтаксис обобщений в C# со всеми его знаками «меньше» и «больше» приводит в замешательство многих разработчиков. С целью упростить создание, чтение и работу с кодом компилятор С# предлагает логическое выведение типов (type inference) при вызове обобщенных методов. Это значит, что компилятор пытается определить (или логически вывести) тип, который будет автоматически использоваться при вызове обобщенного метода. Логический вывод типов продемонстрирован в следующем фрагменте кода
    // При выполнении логического выведения типа в C# используется тип данных переменной, а не фактический тип объекта, на который ссылается эта переменная.
    // Тип может определять несколько методов таким образом, что один из них будет принимать конкретный тип данных, а другой — обобщенный параметр-тип.
    // Но компилятор C# всегда выбирает явное, а не обобщенное соответствие.

    // Обобщения и другие члены
    // В языке C# у свойств, индексаторов, событий, операторных методов, конструкторов и деструкторов не может быть параметров-типов. Однако их можно определить в обобщенном типе с тем, чтобы в их коде использовать параметры-типы этого типа.
    // C# не поддерживает задание собственных обобщенных параметров типа у этих членов, поскольку создатели языка С# из компании Microsoft считают, что разработчикам вряд ли потребуется задействовать эти члены в качестве обобщенных. К тому же для поддержки обобщенного использования этих членов в С# пришлось бы разработать специальный синтаксис, что довольно затратно. Например, при использовании в коде оператора + компилятор может вызвать перегруженный операторный метод. Невозможно указать в коде, где есть оператор +, какие бы то ни было аргументы типа.

    // Верификация и ограничения
    // Получается, что при использовании обобщений можно лишь объявлять переменные обобщенного типа, выполнять присваивание, вызывать методы, определенные в Object, — и все! Но ведь в таком случае от обобщений пользы мало. К счастью, компиляторы и CLR поддерживают уже упоминавшийся механизм ограничений (constraints), благодаря которому обобщения снова начинают приносить практическую пользу.
    // Маркер where в C# сообщает компилятору, что указанный в T тип должен реализовывать обобщенный интерфейс IComparable того же типа (T). Благодаря этому ограничению компилятор разрешает методу вызвать метод CompareTo, потому что последний определен в интерфейсе IComparable<T>.
    // При переопределении виртуального обобщенного метода в переопределяющем методе должно быть задано то же число параметров-типов, а они, в свою очередь, наследуют ограничения, заданные для них методом базового класса. Собственно, переопределяемый метод вообще не вправе задавать ограничения для своих параметров-типов, но может переименовывать параметры-типы. Аналогично, при реализации интерфейсного метода в нем должно задаваться то же число параметров-типов, что и в интерфейсном методе, причем эти параметры-типы наследуют ограничения, заданные для них методом интерфейса.
    // Теперь поговорим о различных типах ограничений, которые компилятор и CLR позволяют применять к параметрам типа. К параметру-типу могут применяться следующие ограничения: основное (primary), дополнительное (secondary) и/или ограничение конструктора (constructor constraint). Речь о них идет в следующих трех разделах.

    // Основные ограничения
    // В параметре-типе можно задать не более одного основного ограничения. Основным ограничением может быть ссылочный тип, указывающий на незапечатанный класс. Нельзя использовать для этой цели следующие ссылочные типы: System.Object, System.Array, System.Delegate, System.MulticastDelegate, System.ValueType, System.Enum и System.Void.
    // Есть два особых основных ограничения: class и struct. Ограничение class гарантирует компилятору, что указанный аргумент-тип будет иметь ссылочный тип. Этому ограничению удовлетворяют все типы-классы, типы-интерфейсы, типы-делегаты и типы-массивы, как в следующем обобщенном классе.
    // Ограничение struct гарантирует компилятору, что указанный аргумент типа будет иметь значимый тип. Этому ограничению удовлетворяют все значимые типы, а также перечисления. Однако компилятор и CLR рассматривают любой значимый тип System.Nullable<T> как особый, и значимые типы с поддержкой null не подходят под это ограничение. Это объясняется тем, что для параметра типа Nullable<T> действует ограничение struct, а среда CLR запрещает такие рекурсивные типы, как Nullable<Nullable<T>>.
    
    // Дополнительные ограничения
    // Для параметра-типа могут быть заданы нуль или более дополнительных ограничений. При задании ограничения интерфейсного типа вы гарантируете компилятору, что указанный аргумент-тип будет определять тип, реализующий этот интерфейс. А так как можно задать несколько интерфейсных ограничений, в аргументе типа должен указываться тип, реализующий все интерфейсные ограничения
    // Другой тип дополнительных ограничений называют ограничением параметра типа (type parameter constraint). Оно используется гораздо реже, чем интерфейсные ограничения интерфейса, и позволяет обобщенному типу или методу указать, что аргументы-типы должны быть связаны определенными отношениями. К параметру-типу может быть применено нуль и более ограничений.

    // Ограничения конструктора
    // Для параметра-типа можно задать не более одного ограничения конструктора. Ограничение конструктора гарантирует компилятору, что указанный аргумент-тип будет иметь неабстрактный тип, имеющий открытый конструктор без параметров. Учтите, что компилятор С# считает ошибкой одновременное задание ограничения конструктора и ограничения struct, потому что это избыточно. У всех значимых типов неявно присутствует открытый конструктор без параметров. 
    
    // Другие проблемы верификации
    // Приведение переменной обобщенного типа


    // !!!
    // - разобрать пример с производительностью при использовании обобщений
}
