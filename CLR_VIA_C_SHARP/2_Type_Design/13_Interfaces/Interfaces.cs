using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._13_Interfaces
{
    class Interfaces
    {
        public static void main()
        {
            Point[] points = new Point[] {new Point(3, 3), new Point(1, 2)};
            // Вызов метода CompareTo интерфейса IComparable<T> объекта Point
            if (points[0].CompareTo(points[1]) > 0)
            {
                Point tempPoint = points[0];
                points[0] = points[1];
                points[1] = tempPoint;
            }
            Console.WriteLine("Points from closest to (0, 0) to farthest:");
            foreach (Point p in points)
                Console.WriteLine(p);

            /************************* Первый пример *************************/
            Base b = new Base();
            // Вызов реализации Dispose в типе b: "Dispose класса Base"
            b.Dispose();
            // Вызов реализации Dispose в типе объекта b: "Dispose класса Base"
            ((IDisposable)b).Dispose();
            /************************* Второй пример ************************/
            Derived d = new Derived();
            // Вызов реализации Dispose в типе d: "Dispose класса Derived"
            d.Dispose();
            // Вызов реализации Dispose в типе объекта d: "Dispose класса Derived"
            ((IDisposable)d).Dispose();
            /************************* Третий пример *************************/
            b = new Derived();
            // Вызов реализации Dispose в типе b: "Dispose класса Base"
            b.Dispose();
            // Вызов реализации Dispose в типе объекта b: "Dispose класса Derived"
            ((IDisposable)b).Dispose();

            TestInterfaceMethods();

            SimpleType st = new SimpleType();
            // Вызов реализации открытого метода Dispose
            st.Dispose();
            // Вызов реализации метода Dispose интерфейса IDisposable
            IDisposable d1 = st;
            d1.Dispose();

            SimpleType1 st1 = new SimpleType1();
            // Вызов реализации открытого метода Dispose
            st1.Dispose();
            // Вызов реализации метода Dispose интерфейса IDisposable
            IDisposable d2 = st1;
            d2.Dispose();

            testGenericInterface();
        }

        private static void TestInterfaceMethods()
        {
            // Переменная s ссылается на объект String
            String s = "Jeffrey";
            // Используя переменную s, можно вызывать любой метод,
            // определенный в String, Object, IComparable, ICloneable,
            // IConvertible, IEnumerable и т. д.

            // Переменная cloneable ссылается на тот же объект String
            ICloneable cloneable = s;
            // Используя переменную cloneable, я могу вызвать любой метод,
            // объявленный только в интерфейсе ICloneable (или любой метод,
            // определенный в типе Object)

            // Переменная comparable ссылается на тот же объект String
            IComparable comparable = s;
            // Используя переменную comparable, я могу вызвать любой метод,
            // объявленный только в интерфейсе IComparable (или любой метод,
            // определенный в типе Object)

            // Переменная enumerable ссылается на тот же объект String
            // Во время выполнения можно приводить интерфейсную переменную
            // к интерфейсу другого типа, если тип объекта реализует оба интерфейса
            // IEnumerable enumerable = (IEnumerable)comparable;
            // Используя переменную enumerable, я могу вызывать любой метод,
            // объявленный только в интерфейсе IEnumerable (или любой метод,
            // определенный только в типе Object)
        }

        private static void testGenericInterface()
        {
            Int32 x = 1, y = 2;
            IComparable<Int32> c = x;
            // CompareTo ожидает Object,
            // но вполне допустимо передать переменную y типа Int32
            c.CompareTo(y); // Выполняется упаковка
            // CompareTo ожидает Int32,
            // передача "2" (тип String) приводит к ошибке компиляции
            // с сообщением о невозможности привести тип String к Int32
            // c.CompareTo("2"); // Ошибка

            Number n = new Number();
            // Значение n сравнивается со значением 5 типа Int32
            IComparable<Int32> cInt32 = n;
            Int32 result = cInt32.CompareTo(5);
            // Значение n сравнивается со значением "5" типа String
            IComparable<String> cString = n;
            result = cString.CompareTo("5");

            MarioPizzeria mp = new MarioPizzeria();
            // Эта строка вызывает открытый метод GetMenu класса MarioPizzeria
            mp.GetMenu();
            // Эти строки вызывают метод IWindow.GetMenu
            IWindow window = mp;
            window.GetMenu();
            // Эти строки вызывают метод IRestaurant.GetMenu
            IRestaurant restaurant = mp;
            restaurant.GetMenu();

            SomeValueType v = new SomeValueType(0);
            Object o = new Object();
            Int32 n1 = v.CompareTo(v); // Без упаковки
            // n1 = v.CompareTo(o); // Ошибка компиляции
        }
    }

    // Объект Point является производным от System.Object
    // и реализует IComparable<T> в Point
    public sealed class Point : IComparable<Point>
    {
        private Int32 m_x, m_y;
        public Point(Int32 x, Int32 y)
        {
            m_x = x;
            m_y = y;
        }

        // Этот метод реализует IComparable<T> в Point
        public Int32 CompareTo(Point other)
        {
            return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
            - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
        }

        public override String ToString()
        {
            return String.Format("({0}, {1})", m_x, m_y);
        }
    }

    // Этот класс является производным от Object и реализует IDisposable
    internal class Base : IDisposable
    {
        // Этот метод неявно запечатан и его нельзя переопределить
        public void Dispose()
        {
            Console.WriteLine("Base's Dispose");
        }
    }

    // Этот класс наследует от Base и повторно реализует IDisposable
    internal class Derived : Base, IDisposable
    {
        // Этот метод не может переопределить Dispose из Base.
        // Ключевое слово 'new' указывает на то, что этот метод
        // повторно реализует метод Dispose интерфейса IDisposable
        new public void Dispose()
        {
            Console.WriteLine("Derived's Dispose");
            // ПРИМЕЧАНИЕ: следующая строка кода показывает,
            // как вызвать реализацию базового класса (если нужно)
            // base.Dispose();
        }
    }

    internal sealed class SimpleType : IDisposable
    {
        public void Dispose() { Console.WriteLine("Dispose"); }
    }

    internal sealed class SimpleType1 : IDisposable
    {
        public void Dispose() { Console.WriteLine("public Dispose"); }
        void IDisposable.Dispose() { Console.WriteLine("IDisposable Dispose"); }
    }

    // Этот класс реализует обобщенный интерфейс IComparable<T> дважды
    public sealed class Number : IComparable<Int32>, IComparable<String>
    {
        private Int32 m_val = 5;
        // Этот метод реализует метод CompareTo интерфейса IComparable<Int32>
        public Int32 CompareTo(Int32 n)
        {
            return m_val.CompareTo(n);
        }
        // Этот метод реализует метод CompareTo интерфейса IComparable<String>
        public Int32 CompareTo(String s)
        {
            return m_val.CompareTo(Int32.Parse(s));
        }
    }

    public static class SomeType
    {
        private static void Test()
        {
            Int32 x = 5;
            Guid g = new Guid();
            // Компиляция этого вызова M выполняется без проблем,
            // поскольку Int32 реализует и IComparable, и IConvertible
            M(x);
            // Компиляция этого вызова M приводит к ошибке, поскольку
            // Guid реализует IComparable, но не реализует IConvertible
            // M(g);
        }
        // Параметр T типа M ограничивается только теми типами,
        // которые реализуют оба интерфейса: IComparable И IConvertible
        private static Int32 M<T>(T t) where T : IComparable, IConvertible {
            return 5;
        }
    }

    public interface IWindow
    {
        Object GetMenu();
    }

    public interface IRestaurant
    {
        Object GetMenu();
    }

    // Этот тип является производным от System.Object
    // и реализует интерфейсы IWindow и IRestaurant
    public sealed class MarioPizzeria : IWindow, IRestaurant
    {
        // Реализация метода GetMenu интерфейса IWindow
        Object IWindow.GetMenu() { return 5; }
        // Реализация метода GetMenu интерфейса IRestaurant
        Object IRestaurant.GetMenu() { return 5; }
        // Метод GetMenu (необязательный),
        // не имеющий отношения к интерфейсу
        public Object GetMenu() { return 5; }
    }

    internal struct SomeValueType : IComparable
    {
        private Int32 m_x;
        public SomeValueType(Int32 x) { m_x = x; }
        public Int32 CompareTo(SomeValueType other) {
        return(m_x - other.m_x);
        }
        // ПРИМЕЧАНИЕ: в следующей строке не используется public/private
        Int32 IComparable.CompareTo(Object other)
        {
            return CompareTo((SomeValueType)other);
        }
    }

    internal class Base1 : IComparable
    {
        // Явная реализация интерфейсного метода (EIMI)
        Int32 IComparable.CompareTo(Object o)
        {
            Console.WriteLine("Base's IComparable CompareTo");
            return CompareTo(o); // Теперь здесь вызывается виртуальный метод
        }
        // Виртуальный метод для производных классов
        // (этот метод может иметь любое имя)
        public virtual Int32 CompareTo(Object o)
        {
            Console.WriteLine("Base's virtual CompareTo");
            return 0;
        }
    }
    internal sealed class Derived1 : Base1, IComparable
    {
        // Открытый метод, который также является реализацией интерфейса
        public override Int32 CompareTo(Object o)
        {
            Console.WriteLine("Derived's CompareTo");
            // Теперь можно вызвать виртуальный метод класса Base
            return base.CompareTo(o);
        }
    }

    // Некоторые языки программирования разрешают множественное наследование, позволяя создать класс SocketPort, производный от двух базовых классов. Однако CLR (а значит, и все основанные на этой среде языки программирования) множественное наследование не поддерживает. Вместе с тем CLR позволяет реализовать ограниченное множественное наследование через интерфейсы (interfaces). В этой главе рассказывается об определении и применении интерфейсов, а также приводятся основные правила, позволяющие понять, когда уместно использовать интерфейсы, а не базовые классы. 
    
    // Наследование в классах и интерфейсах
    // В .NET Framework есть класс System.Object, в котором определено 4 открытых экземплярных метода: ToString, Equals, GetHashCode и GetType. Этот класс является корневым базовым классом для всех остальных классов, поэтому все классы наследуют эти четыре метода класса Object. Это также означает, что код, оперирующий экземпляром класса Object, в действительности может выполнять операции с экземпляром любого класса.
    // Любой производный от Object класс наследует:
    // - Сигнатуры методов. Это позволяет коду считать, что он оперирует экземпляром класса Object, тогда как на самом деле он работает с экземпляром какого-либо другого класса.
    // - Реализацию этих методов. Разработчик может определить класс, производный от Object, не реализуя методы класса Object вручную.
    // В CLR у класса может быть один и только один прямой «родитель» (который прямо или опосредованно наследует от класса Object). Базовый класс предоставляет набор сигнатур и реализации этих методов. При этом новый класс может стать базовым для другого класса, который будет определен другим разработчиком, и при этом новый производный класс унаследует все сигнатуры методов и их реализации.
    // CLR также позволяет определить интерфейс, который, в сущности, представляет собой средство назначения имени набору сигнатур методов. Интерфейс не содержит реализаций методов. Класс наследует интерфейс через указание имени последнего, причем этот класс должен явно содержать реализации интерфейсных методов — иначе CLR посчитает определение типа недействительным. Конечно, реализация интерфейсных методов — обычно довольно утомительное занятие, поэтому я и назвал наследование интерфейсов ограниченным механизмом реализации множественного наследования. Компилятор C# и CLR позволяют классу наследовать от нескольких интерфейсов, и, конечно же, класс при этом должен реализовать все унаследованные методы интерфейсов.
    // Одна из замечательных особенностей наследования классов — возможность подстановки экземпляров производного типа в любые контексты, в которых выступают экземпляры базового типа. Аналогичным образом наследование от интерфейсов позволяет подставлять экземпляры типа, реализующего интерфейс, во все контексты, где требуются экземпляры указанного интерфейсного типа. Чтобы наше обсуждение стало более конкретным, давайте посмотрим, как определяются интерфейсы.

    // Определение интерфейсов
    // Обратите внимание, что в интерфейсах можно также определять события, свойства — без параметров или с ними (последние в C# называют индексаторами), поскольку все это просто упрощенные средства синтаксиса, которые в конечном итоге все равно соответствуют методам. Однако в интерфейсе нельзя определять ни конструкторы, ни экземплярные поля.
    // Хотя CLR допускает наличие в интерфейсах статических методов, статических полей и конструкторов, а также констант, CLS-совместимый интерфейс не может иметь подобных статических членов, поскольку некоторые языки не поддерживают их определение или обращение к ним. C# не позволяет определять в интерфейсе статические члены.
    // С точки зрения CLR, определение интерфейса — почти то же, что и определение типа. То есть CLR определяет внутреннюю структуру данных для объекта интерфейсного типа, а для обращения к различным членам интерфейса может использовать отражение.
    // Как и типы, интерфейс может определяться на уровне файлов или быть вложенным в другой тип. При определении интерфейсного типа можно указать требуемую область видимости и доступа (public, protected, internal и т. п.).
    // В соответствии с соглашением имена интерфейсных типов начинаются с прописной буквы I, что облегчает их поиск в исходном коде. CLR поддерживает обобщенные интерфейсы (как показано в некоторых предыдущих примерах) и интерфейсные методы.
    // Определение интерфейса может «наследовать» другие интерфейсы. Однако слово «наследовать» не совсем точное, поскольку в интерфейсах наследование работает иначе, чем в классах. Я предпочитаю рассматривать наследование интерфейсов как включение контрактов других интерфейсов. Например, определение интерфейса TCollection<T> включает контракт интерфейсов TEnumerable<T> и IEnumerable. Это означает следующее:
    // - любой класс, наследующий интерфейс ICollection<T>, должен реализовать все методы, определенные в интерфейсах ICollection<T>, IEnumerable<T> и IEnumerable;
    // - любой код, ожидающий объект, тип которого реализует интерфейс ICollection<T>, может быть уверен в том, что тип объекта также реализует методы интерфейсов IEnumerable<T> и IEnumerable.

    // Наследование интерфейсов
    // Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определен в коде как виртуальный, компилятор сделает его таковым и, вдобавок, запечатанным. Это не позволяет производному классу переопределять интерфейсные методы. Если явно задать метод как виртуальный, компилятор сделает его таковым и оставит незапечатанным, что предоставит производному классу возможность переопределять интерфейсные методы.

    // Подробнее о вызовах интерфейсных методов
    // Тип System.String из библиотеки FCL наследует сигнатуры и реализации методов System.Object. Кроме того, тип String реализует несколько интерфейсов: IComparable, ICloneable, IConvertible, IEnumerable, IComparable<String>, IEnumerable<Char> и IEquatable<String>. Это значит, что типу String не требуется реализовывать (или переопределять) методы, имеющиеся в его базовом типе Object. Однако тип String должен реализовывать методы, объявленные во всех интерфейсах.
    // CLR допускает определение полей, параметров или локальных переменных, имеющих интерфейсный тип. Используя переменную интерфейсного типа, можно вызывать методы, определенные этим интерфейсом. К тому же CLR позволяет вызывать методы, определенные в типе Object, поскольку все классы наследуют его методы
    // Внимание
    // Как и ссылочный тип, значимый тип может реализовать несколько (или нуль) интерфейсов. Но при приведении экземпляра значимого типа к интерфейсному типу этот экземпляр надо упаковать, потому что интерфейсная переменная является ссылкой, которая должна указывать на объект в куче, чтобы среда CLR могла проверить указатель и точно выяснить тип объекта. Затем при вызове метода интерфейса с упакованным значимым типом CLR использует указатель, чтобы найти таблицу методов типа объекта и вызвать нужный метод.
    
    // Явные и неявные реализации интерфейсных методов (что происходит за кулисами)
    // Когда тип загружается в CLR, для него создается и инициализируется таблица методов. Она содержит по одной записи для каждого нового, представляемого только этим типом метода, а также записи для всех виртуальных методов, унаследованных типом. Унаследованные виртуальные методы включают методы, определенные в базовых типах иерархии наследования, а также все методы, определенные интерфейсными типами.
    // internal sealed class SimpleType : IDisposable {
    // public void Dispose() { Console.WriteLine("Dispose"); }
    // }
    // Тогда таблица методов типа содержит записи, в которых представлены:
    // - все экземплярные методы, определенные в типе Object и неявно унаследованные от этого базового класса;
    // - все интерфейсные методы, определенные в явно унаследованном интерфейсе IDisposable (в нашем примере в интерфейсе IDisposable определен только один метод — Dispose);
    // - новый метод, Dispose, появившийся в типе SimpleType
    // Кстати, если бы новый метод Dispose был помечен как виртуальный, компилятор C# все равно сопоставил бы этот метод с одноименным интерфейсным методом.
    // Сопоставляя новый метод с интерфейсным методом, компилятор C# генерирует метаданные, указывающие на то, что обе записи в таблице методов типа SimpleType должны ссылаться на одну реализацию. Чтобы вам стало понятнее, следующий код демонстрирует вызов открытого метода Dispose класса, а также вызов реализации класса для метода Dispose интерфейса IDisposable.
    // Тогда таблица методов типа содержит записи, в которых представлены:
    // - все экземплярные методы, определенные в типе Object и неявно унаследованные от этого базового класса;
    // - все интерфейсные методы, определенные в явно унаследованном интерфейсе IDisposable (в нашем примере в интерфейсе IDisposable определен только один метод — Dispose);
    // - новый метод, Dispose, появившийся в типе SimpleType.
    // Если в C# перед именем метода указано имя интерфейса, в котором определен этот метод (в нашем примере — IDisposable.Dispose), то вы создаете явную реа- лизацию интерфейсного метода (Explicit Interface Method Implementation, EIMI).
    // Заметьте: при явной реализации интерфейсного метода в C# нельзя указывать уровень доступа (открытый или закрытый). Однако когда компилятор создает метаданные для метода, он назначает ему закрытый уровень доступа (private), что запрещает любому коду использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать интерфейсный метод — обратиться через переменную этого интерфейсного типа.
    
    // Обобщенные интерфейсы
    // обобщенные интерфейсы обеспечивают безопасность типов на стадии компиляции. Некоторые интерфейсы (такие, как необобщенный IComparable) определяют методы, которые принимают или возвращают параметры типа Object. При вызове в коде методов таких интерфейсов можно передать ссылку на экземпляр любого типа, однако обычно это нежелательно. 
    // ПримечАние
    // В FCL определены необобщенные и обобщенные версии интерфейсов IComparable, ICollection, IList, IDictionary и некоторых других. Если вы определяете тип и хотите реализовать любой из этих интерфейсов, обычно лучше выбирать обобщенные версии. Необобщенные версии оставлены в FCL для обратной совместимости с кодом, написанным до того, как в . NET Framework появилась поддержка обобщений. Необобщенные версии также предоставляют пользователям механизм работы с данными более универсальным, но и менее безопасным образом.
    // Некоторые обобщенные интерфейсы происходят от необобщенных версий, так что в классе приходится реализовывать как обобщенную, так и необобщенную версии. Например, обобщенный интерфейс IEnumerable<T> наследует от необобщенного интерфейса IEnumerable. Так что если класс реализует IEnumerable<T>, он должен также реализовать IEnumerable.
    // Иногда, при необходимости интеграции с другим кодом, приходится реализовывать необобщенный интерфейс просто потому, что необобщенной версии не существует. В этом случае, если любой из интерфейсных методов принимает или возвращает тип Object, теряется безопасность типов при компиляции, и значимые типы должны упаковываться. Можно в некоторой степени исправить эту ситуацию, действуя так, как описано далее в разделе «Совершенствование безопасности типов за счет явной реализации интерфейсных методов».
    // класс может реализовать один интерфейс многократно, просто используя параметры различного типа. Следующий пример показывает, как это бывает удобно.

    // Обобщения и ограничения интерфейса
    // Замечательно! При определении параметров метода каждый тип параметра указывает, что передаваемый аргумент должен иметь заданный тип или быть производным от него. Если типом параметра является интерфейс, аргумент может относиться к любому типу класса, реализующему заданный интерфейс. Использование нескольких ограничений интерфейса позволяет методу указывать, что передаваемый аргумент должен реализовывать несколько интерфейсов.
    // Второе преимущество ограничений интерфейса — избавление от упаковки при передаче экземпляров значимых типов. В предыдущем фрагменте кода методу M передавался аргумент x (экземпляр типа Int32, то есть значимого типа). При передаче x в M упаковка не выполнялась. Если код метода M вызовет t.CompareTo(...), то упаковка при вызове также не будет выполняться (упаковка может выполняться для аргументов, передаваемых CompareTo) 
    // В то же время если M объявляется следующим образом, то для передачи x в M придется выполнять упаковку:
    // private static Int32 M(IComparable t) {}
    // Для ограничений интерфейсов компилятор C# генерирует определенные IL-инструкции, которые вызывают интерфейсный метод для значимого типа напрямую, без упаковки. Кроме использования ограничений интерфейса нет другого способа заставить компилятор C# генерировать такие IL-инструкции; следовательно, во всех других случаях вызов интерфейсного метода для значимого типа всегда приводит к упаковке.
    
    // Реализация нескольких интерфейсов с одинаковыми сигнатурами и именами методов
    // Код, в котором используется объект MarioPizzeria, должен выполнять приведение типа к определенному интерфейсу для вызова нужного метода:

    // Совершенствование безопасности типов за счет явной реализации интерфейсных методов
    // Если какой-либо из интерфейсных методов принимает параметры типа System.Object или возвращает значение типа System.Object, безопасность типов при компиляции нарушается и выполняется упаковка. В этом разделе я показываю, как за счет явной реализации интерфейсных методов (EIMI) можно несколько улучшить ситуацию. 
    // - нежелательная упаковка — когда переменная v передается в качестве аргумента методу CompareTo, она должна упаковываться, поскольку CompareTo ожидает параметр типа Object;
    // - отсутствие безопасности типов — компиляция кода выполняется без проблем, но когда метод CompareTo пытается привести other к типу SomeValueType, возникает исключение InvalidCastException.
    // К EIMI часто прибегают при реализации таких интерфейсов, как IConvertible, ICollection, IList и IDictionary. Это позволяет обеспечить в интерфейсных методах безопасность типов при компиляции и избавиться от упаковки значимых типов.

    // Опасности явной реализации интерфейсных методов
    // Очень важно понимать некоторые особенности EIMI, из-за которых следует избегать явной реализации интерфейсных методов везде, где это возможно. К счастью, в некоторых случаях вместо EIMI можно обойтись обобщенными интерфейсами. Но все равно остаются ситуации, когда без EIMI не обойтись (например, при реализации двух интерфейсных методов с одинаковыми именами и сигнатурами). С явной реализацией интерфейсных методов связаны некоторые серьезные проблемы (далее я расскажу о них подробнее):
    // - отсутствие документации, объясняющей, как именно тип реализует EIMI-метод, а также отсутствие IntelliSense-поддержки в Microsoft Visual Studio;
    // - при приведении к интерфейсному типу экземпляры значимого типа упаковываются;
    // - EIMI нельзя вызвать из производного типа.
    // Требование приведения типа далеко не очевидно, многие разработчики не могут самостоятельно до этого додуматься. Но на этом проблемы не заканчиваются — при приведении значимого типа Int32 к интерфейсному типу IConvertible значимый тип упаковывается, что приводит к лишним затратам памяти и снижению производительности. Это вторая серьезная проблема.
    // Третья и, наверное, самая серьезная проблема с EIMI состоит в том, что явная реализация интерфейсного метода не может вызываться из производного класса.

    // Дилемма разработчика: базовый класс или интерфейс?
    // Меня часто спрашивают, что лучше выбирать для проектировании типа — базовый тип или интерфейс? Ответ не всегда очевиден. Вот несколько правил, которые могут помочь вам сделать выбор.
    // - Связь потомка с предком. Любой тип может наследовать только одну реализацию. Если производный тип не может ограничиваться отношением типа «является частным случаем» с базовым типом, нужно применять интерфейс, а не базовый тип. Интерфейс подразумевает отношение «поддерживает функциональность». Например, тип может преобразовывать экземпляры самого себя в другой тип (IConvertible), может создать набор экземпляров самого себя (ISerializable) и т. д. Заметьте, что значимые типы должны наследовать от типа System.ValueType и поэтому не могут наследовать от произвольного базового класса. В этом случае нужно определять интерфейс. 
    // - Простота использования. Разработчику проще определить новый тип, производный от базового, чем создать интерфейс. Базовый тип может предоставлять массу функций, и в производном типе потребуется внести лишь незначительные изменения, чтобы изменить его поведение. При создании интерфейса в новом типе придется реализовывать все члены.
    // - Четкая реализация. Как бы хорошо ни был документирован контракт, вряд ли будет реализован абсолютно корректно. По сути, проблемы COM связаны именно с этим — вот почему некоторые COM-объекты нормально работают только с Microsoft Word или Microsoft Internet Explorer. Базовый тип с хорошей реализацией основных функций — прекрасная отправная точка, вам останется изменить лишь отдельные части.
    // - Управление версиями. Когда вы добавляете метод к базовому типу, производный тип наследует стандартную реализацию этого метода без всяких затрат. Пользовательский исходный код даже не нужно перекомпилировать. Добавление нового члена к интерфейсу требует изменения пользовательского исходного кода и его перекомпиляции.


    // !!!
    // 
}
