using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.IO; // Подставлять префикс "System.IO"
using System.Text; // Подставлять префикс "System.Text"
using SystemText = System.Text;

namespace CLR_VIA_C_SHARP._2_Type_Design._4_TypeBasics
{
    class TypeBasics
    {
        public static void main()
        {
            testNew();
            testCast();
            testIsAs();
            testNamespace();
        }

        private static void testNew()
        {
            Employee e = new Employee("David");
        }

        private static void testCast()
        {
            Object o = new Employee("Jane");
            Employee e = (Employee)o;

            Manager m = new Manager();
            PromoteEmployee(m);

            // System.InvalidCastException
            //DateTime newYears = new DateTime(2013, 1, 1);
            //PromoteEmployee(newYears);
        }

        private static void PromoteEmployee(Object o)
        {
            // В этом месте компилятор не знает точно, на какой тип объекта
            // ссылается o, поэтому скомпилирует этот код
            // Однако в период выполнения CLR знает, на какой тип
            // ссылается объект o (приведение типа выполняется каждый раз),
            // и проверяет, соответствует ли тип объекта типу Employee
            // или другому типу, производному от Employee
            Employee e = (Employee) o;
        }

        private static void testIsAs()
        {
            Object o = new Object();
            Boolean b1 = (o is Object); // b1 равно true
            Boolean b2 = (o is Employee); // b2 равно false
            testing();
        }

        private static void testing()
        {
            Object o1 = new Object();
            Object o2 = new B();
            Object o3 = new D();
            Object o4 = o3;

            B b1 = new B();
            B b2 = new D();
            D d1 = new D();

            // CTE
            // B b3 = new Object();
            // D d2 = new Object();

            B b4 = d1;

            // CTE
            // D d3 = b2;
            D d4 = (D)d1;
            D d5 = (D)b2;
            // RTE
            // D d6 = (D)b1;
            // B b5 = (B)o1;
            B b6 = (D)b2;
        }

        private static void testNamespace()
        {
            // System.IO.FileStream fs = new System.IO.FileStream();
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
        }

        // Все типы — производные от System.Object
        // // Тип, неявно производный от Object
        // class Employee {
        // ...
        // }
        // // Тип, явно производный от Object
        // class Employee : System.Object {
        // ...
        // }

        // Открытые методы System.Object
        // - Equals - Возвращает true, если два объекта имеют одинаковые значения.
        // - GetHashCode - Возвращает хеш-код для значения данного объекта. Этот метод следует переопределить, если объекты типа используются в качестве ключа хеш-таблиц.
        // - ToString - По умолчанию возвращает полное имя типа (this.GetType().FullName). На практике этот метод переопределяют, чтобы он возвращал объект String, содержащий состояние объекта в виде строки.
        // - GetType - Возвращает экземпляр объекта, производного от Type, который идентифицирует тип объекта, вызвавшего GetType.

        // Защищенные методы System.Object
        // MemberwiseClone - Этот невиртуальный метод создает новый экземпляр типа и присваивает полям нового объекта соответствующие значения объекта this. Возвращается ссылка на созданный экземпляр
        // Finalize - Этот виртуальный метод вызывается, когда уборщик мусора определяет, что объект является мусором, но до возвращения занятой объектом памяти в кучу. В типах, требующих очистки при сборке мусора, следует переопределить этот метод.

        // CLR требует, чтобы все объекты создавались оператором new. Например, объект Employee создается следующим образом: Employee e = new Employee("ConstructorParam1");
        // Оператор new выполняет следующие действия:
        // 1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, включая System.Object (в котором отсутствуют собственные экземплярные поля). Кроме того, в каждом объекте кучи должны присутствовать дополнительные члены, называемые указателем на объект-тип (type object pointer) и индексом блока синхронизации (sync block index); они необходимы CLR для управления объектом. Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта.
        // 2. Выделение памяти для объекта с резервированием необходимого для данного типа количества байтов в управляемой куче. Выделенные байты инициализируются нулями (0).
        // 3. Инициализация указателя на объект-тип и индекса блока синхронизации.
        // 4. Вызов конструктора экземпляра типа с параметрами, указанными при вызове new (в предыдущем примере это строка ConstructorParam1). Большинство компиляторов автоматически включает в конструктор код вызова конструктора базового класса. Каждый конструктор выполняет инициализацию определенных в соответствующем типе полей. В частности, вызывается конструктор System.Object, но он ничего не делает и просто возвращает управление.
        // Выполнив все эти операции, new возвращает ссылку (или указатель) на вновь созданный объект. В предыдущем примере кода эта ссылка сохраняется в переменной e типа Employee.
        // Кстати, у оператора new нет пары — оператора delete, то есть нет явного способа освобождения памяти, занятой объектом. Уборкой мусора занимается среда CLR.

        // Приведение типов
        // Одна из важнейших особенностей CLR — безопасность типов (type safety). Во время выполнения программы среде CLR всегда известен тип объекта.
        // Программист всегда может точно определить тип объекта при помощи метода GetType.
        // CLR разрешает привести тип объекта к его собственному типу или любому из его базовых типов.
        // в C# нет специального синтаксиса для приведения типа объекта к его базовому типу, поскольку такое приведение считается безопасным неявным преобразованием.
        // Однако для приведения типа к производному от него типу разработчик на C# должен ввести операцию явного приведения типов — неявное преобразование приведет к ошибке.
        // В данном примере было бы правильнее выбрать для метода PromoteEmployee в качестве типа параметра не Object, а Employee, чтобы ошибка проявилась на стадии компиляции, а разработчику не пришлось бы ждать исключения, чтобы узнать о существовании проблемы.

        // Приведение типов в C# с помощью операторов is и as
        // В C# существуют другие механизмы приведения типов. Например, оператор is проверяет совместимость объекта с данным типом, а в качестве результата выдает значение типа Boolean (true или false). Оператор is никогда не генерирует исключение.
        // Для null-ссылок оператор is всегда возвращает false, так как объекта, тип которого нужно проверить, не существует.
        // if (o is Employee) {
        // Employee e = (Employee) o;
        // // Используем e внутри инструкции if
        // }
        // более эффективно
        // Employee e = o as Employee;
        // if (e != null) {
        // // Используем e внутри инструкции if
        // }
        // В C# разрешено определять методы операторов преобразования при помощи типов, об этом речь идет в разделе «Методы операторов преобразования» главы 8. Эти методы вызываются только в случаях, когда имеет место приведение типов, и никогда не вызываются при использовании операторов is и as в C#.

        // Пространства имен и сборки
        // CLR ничего не знает о пространствах имен. При обращении к какому-либо типу среде CLR надо предоставить полное имя типа (а это может быть действительно длинная строка с точками) и сборку, содержащую описание типа, чтобы во время выполнения загрузить эту сборку, найти в ней нужный тип и оперировать им.
        // По умолчанию компилятор C# автоматически просматривает сборку MSCorLib.dll, даже если она явно не указана. В ней содержатся описания всех фундаментальных FCL-типов, таких как Object, Int32, String и др.
        // При обращении к Widget от Microsoft надо использовать запись Microsoft.Widget, а при ссылке на Widget от Wintellect — запись Wintellect.Widget.
        // В C# есть еще одна форма директивы using, позволяющая создать псевдоним для отдельного типа или пространства имен.
        // Для разработки приложения, оперирующего обоими типами, необходим механизм, позволяющий различать программными средствами не только пространства имен, но и сборки.
        // К счастью, в компиляторе C# поддерживаются внешние псевдонимы (extern aliases), позволяющие справиться с проблемой. Внешние псевдонимы дают также возможность обращаться к одному типу двух (или более) версий одной сборки.

        // Связь между сборками и пространством имен
        // Пространство имен и сборка (файл, в котором реализован тип) не обязательно связаны друг с другом. В частности, различные типы, принадлежащие одному пространству имен, могут быть реализованы в разных сборках. Например, тип System.IO.FileStream реализован в сборке MSCorLib.dll, а тип System.IO.FileSystemWatcher — в сборке System.dll. На самом деле, сборка System.IO.dll в .NET Framework даже не поставляется.
        // Для того чтобы скомпилировать код, ссылающийся на тип ResXFileRef, необходимо добавить директиву using System.Resources и использовать параметр компилятора /r:System.Windows.forms.dll.
        // важны 2 параметра - namespace и assembly.

        // Как разные компоненты взаимодействуют во время выполнения
        // В этом разделе рассказано, как во время выполнения взаимодействуют типы, объекты, стек потока и управляемая куча.
        // Кроме того, объяснено, в чем различие между вызовом статических, экземплярных и виртуальных методов.
        // У процесса может быть много потоков. После создания потоку выделяется стек размером в 1 Мбайт.
        // Выделенная память используется для передачи параметров в методы и хранения определенных в пределах методов локальных переменных.
        // Все методы, кроме самых простых, содержат некоторый входной код (prologue code), инициализирующий метод до начала его работы.
        // Кроме того, эти методы содержат выходной код (epilogue code), выполняющий очистку после того, как метод завершит свою основную работу, чтобы возвратить управление вызывающей программе.
        // На данном этапе CLR обеспечивает загрузку в домен приложений всех сборок, в которых определены все эти типы. Затем, используя метаданные сборки, CLR получает информацию о типах и создает структуры данных, собственно и представляющие эти типы.
        // При определении типа можно включить в него статические поля данных.
        // Байты для этих статических полей выделяются в составе самих объектов-типов. Наконец, у каждого объекта-типа есть таблица методов с входными точками всех методов, определенных в типе. Эта таблица методов уже обсуждалась в главе 1. Так как в типе Employee определены три метода (GetYearsEmployed, GenProgressReport и Lookup), в соответствующей таблице методов есть три записи. В типе Manager определен один метод (переопределенный метод GenProgressReport), который и представлен в таблице методов этого типа.
        // Всякий раз при создании нового объекта в куче CLR автоматически инициализирует внутренний указатель на объект-тип так, чтобы он указывал на соответствующий объект-тип (в данном случае — на объект-тип Manager).
        // Кроме того, CLR инициализирует индекс блока синхронизации и присваивает всем экземплярным полям объекта значение null или 0 (нуль) перед вызовом конструктора типа — метода, который, скорее всего, изменит значения некоторых экземплярных полей.
        // в куче обьекты и обьект-типы, в стеке - локальные переменные.
        // Следующая строка метода M3 вызывает виртуальный экземплярный метод GenProgressReport в Employee. При вызове виртуального экземплярного метода CLR приходится выполнять некоторую дополнительную работу. Во-первых, CLR обращается к переменной, используемой для вызова, и затем следует по адресу вызывающего объекта. В данном случае переменная e указывает на объект Joe типа Manager. Во-вторых, CLR проверяет у объекта внутренний указатель на объект-тип.Затем CLR находит в таблице методов объекта-типа запись вызываемого метода, обрабатывает код JIT-компилятором (при необходимости) и вызывает полученный машинный код. В нашем случае вызывается реализация метода GenProgressReport в Manager, потому что e ссылается на объект Manager.
        // По сути объекты-типы тоже являются объектами. Создавая объект-тип, среда CLR должна его как-то инициализировать. Резонно спросить: «Какие значения будут присвоены при инициализации?» В общем, при своем запуске в процессе CLR сразу же создает специальный объект-тип для типа System.Type (он определен в MSCorLib.dll). Объекты типа Employee и Manager являются «экземплярами» этого типа, и по этой причине их указатели на объекты-типы инициализируются ссылкой на объект-тип System.Typeю
        // Кстати, метод GetType типа System.Object просто возвращает адрес, хранящийся в указателе на объект-тип заданного объекта.

        //!!!
        // - interface +
        // - указателем на объект-тип (type object pointer) + 
        // - индексом блока синхронизации (sync block index) +
        // - sealed - запрещает наследование.
        // - internal -  типы или члены доступны только внутри файлов в одной и той же сборке
        // - external alias
    }
}