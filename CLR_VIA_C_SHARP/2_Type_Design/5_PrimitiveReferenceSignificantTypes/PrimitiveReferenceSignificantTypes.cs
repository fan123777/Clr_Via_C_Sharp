using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Collections;
//using Microsoft.Office.Interop.Excel;
using System.Dynamic;
using System.Reflection;

namespace CLR_VIA_C_SHARP._2_Type_Design._5_PrimitiveReferenceSignificantTypes
{
    class PrimitiveReferenceSignificantTypes
    {
        public static void main()
        {
            TestPrimitive();
            TestOverflow();
            ValueTypeDemo();
            TestInitialization();
            TestPackaging();
            TestPakaging1();
            TestPakaging2();
            TestEqualityAndIdentity();
            TestDynamic();
            TestCom();
            TestReflection();

            // Testing
            Testing test = new Testing();
            test.run();
        }

        public static void TestPrimitive()
        {
            int a = 0; // Самый удобный синтаксис
            System.Int32 a1 = 0; // Удобный синтаксис
            int a2 = new int(); // Неудобный синтаксис
            System.Int32 a3 = new System.Int32(); // Самый неудобный синтаксис

            //BinaryReader br = new BinaryReader(...);
            //float val = br.ReadSingle(); // Код правильный, но выглядит странно
            //Single val = br.ReadSingle(); // Код правильный и выглядит нормально

            Int32 i1 = 5; // 32-разрядное число
            Int64 l1 = i1; // Неявное приведение типа к 64-разрядному значению
            // Могу вас обнадежить: код успешно компилируется и делает все, что ему положено. Дело в том, что компилятор C# неплохо разбирается в примитивных типах и применяет свои правила при компиляции кода. Иначе говоря, он распознает наиболее распространенные шаблоны программирования и генерирует такие IL-команды, благодаря которым исходный код работает так, как требуется. В первую очередь, это относится к приведению типов, литералам и операторам, примеры которых мы рассмотрим позже.

            // Начнем с того, что компилятор выполняет явное и неявное приведение между примитивными типами, например:
            Int32 i = 5; // Неявное приведение Int32 к Int32
            Int64 l = i; // Неявное приведение Int32 к Int64
            Single s = i; // Неявное приведение Int32 к Single
            Byte b = (Byte)i; // Явное приведение Int32 к Byte
            Int16 v = (Int16)s; // Явное приведение Single к Int16

            // Кроме того, благодаря тому, что выражения, состоящие из литералов, вычисляются на этапе компиляции, возрастает скорость выполнения приложения.
            Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
            Boolean found = false; // В готовом коде found присваивается 0
            Int32 x = 100 + 20 + 3; // В готовом коде x присваивается 123
            String s1 = "a " + "bc"; // В готовом коде s присваивается "a bc"

            Int32 x1 = 100; // Оператор присваивания
            Int32 y = x1 + 23; // Операторы суммирования и присваивания
            Boolean lessThanFifty = (y < 50); // Операторы "меньше чем" и присваивания

            Byte b1 = 100;
            b1 = (Byte)(b1 + 200);// После этого b равно 44 (2C в шестнадцатеричной записи)
            // При выполнении этой арифметической операции CLR на первом шаге все значения операндов расширяются до 32 разрядов (или 64 разрядов, если для представления операнда 32 разрядов недостаточно). Поэтому b и 200 (для которых 32 разрядов достаточно) сначала преобразуются в 32-разрядные значения, а затем уже суммируются. Полученное 32-разрядное число (300 в десятичной системе, 12C в шестнадцатеричной), прежде чем поместить его обратно в переменную b, нужно привести к типу Byte. Так как в данном случае C# не выполняет неявного приведения типа, во вторую строку введена операция приведения к типу Byte.
        }

        public static void TestOverflow()
        {
            UInt32 invalid = unchecked((UInt32)(-1)); // OK
            Byte b = 100;
            // b = checked((Byte)(b + 200)); // Выдается исключение OverflowException
            // Здесь b и 200 преобразуются в 32-разрядные числа и суммируются; результат равен 300. Затем при преобразовании 300 в Byte генерируется исключение OverflowException. Если приведение к типу Byte вывести из оператора checked, исключения не будет:
            b = (Byte)checked(b + 200); // b содержит 44; нет OverflowException
            checked
            { // Начало проверяемого блока
                Byte b1 = 100;
                // exception
                // b1 = (Byte)(b1 + 200); // Это выражение проверяется на переполнение
            }
            checked
            { // Начало проверяемого блока
                Byte b2 = 100;
                // exception
                // b2 += 200; // Это выражение проверяется на переполнение
            }
            //Установка режима контроля переполнения не влияет на работу метода, вызываемого внутри оператора или инструкции checked, так как действие оператора (и инструкции) checked распространяется только на выбор IL-команд сложения, вычитания, умножения и преобразования данных.
            checked
            {
                // Предположим, SomeMethod пытается поместить 400 в Byte
                // SomeMethod(400);
                // Возникновение OverflowException в SomeMethod
                // зависит от наличия в нем операторов проверки
            }
        }

        // Ссылочный тип (поскольку 'class')
        class SomeRef { public Int32 x; }

        // Значимый тип (поскольку 'struct')
        struct SomeVal { public Int32 x; }

        static void ValueTypeDemo()
        {
            SomeRef r1 = new SomeRef(); // Размещается в куче
            SomeVal v1 = new SomeVal(); // Размещается в стеке
            // также можно записать:
            SomeVal v3; // Размещается в стеке
            r1.x = 5; // Разыменовывание указателя
            v1.x = 5; // Изменение в стеке
            Console.WriteLine(r1.x); // Отображается "5"
            Console.WriteLine(v1.x); // Также отображается "5"
            // В левой части рис. 5.2 показан результат
            // выполнения предыдущих строк
            SomeRef r2 = r1; // Копируется только ссылка (указатель)
            SomeVal v2 = v1; // Помещаем в стек и копируем члены
            r1.x = 8; // Изменяются r1.x и r2.x
            v1.x = 9; // Изменяется v1.x, но не v2.x
            Console.WriteLine(r1.x); // Отображается "8"
            Console.WriteLine(r2.x); // Отображается "8"
            Console.WriteLine(v1.x); // Отображается "9"
            Console.WriteLine(v2.x); // Отображается "5"
            // В правой части рис. 5.2 показан результат
            // выполнения ВСЕХ предыдущих строк
        }

        public static void TestInitialization()
        {
            // Две следующие строки компилируются, так как C# считает,
            // что поля в v1 инициализируются нулем
            SomeVal v1 = new SomeVal();
            Int32 a1 = v1.x;

            // Следующие строки вызовут ошибку компиляции, поскольку C# не считает,
            // что поля в v1 инициализируются нулем
            SomeVal v2;
            // Int32 a2 = v2.x;
            // error CS0170: Use of possibly unassigned field 'x'
            // (ошибка CS0170: Используется поле 'x', которому не присвоено значение)
        }

        // Для повышения производительности разрешим CLR
        // установить порядок полей для этого типа
        [StructLayout(LayoutKind.Auto)]
        internal struct SomeValType
        {
            private readonly Byte m_b;
            private readonly Int16 m_x;
        }

        // Разработчик явно задает порядок полей в значимом типе
        [StructLayout(LayoutKind.Explicit)]
        internal struct SomeValType1
        {
            [FieldOffset(0)]
            private readonly Byte m_b; // Поля m_b и m_x перекрываются
            [FieldOffset(0)]
            private readonly Int16 m_x; // в экземплярах этого класса
        }

        struct Point
        {
            public Int32 x, y;
        }

        public static void TestPackaging()
        {
            // Упаковка
            ArrayList a = new ArrayList();
            Point p;
            for (Int32 i = 0; i < 10; i++)
            {
                p.x = p.y = i; // Инициализация членов в нашем значимом типе
                a.Add(p); // Упаковка значимого типа и добавление ссылки в ArrayList
                // public virtual Int32 Add(Object value);
                // Переменную p значимого типа Point можно использовать повторно, так как ArrayList ничего о ней не знает.
            }

            // Распаковка
            Point p1 = (Point)a[0];

            Int32 x = 5;
            Object o = x; // Упаковка x; o указывает на упакованный объект
            // Int16 y = (Int16)o; // Генерируется InvalidCastException
            Int16 y = (Int16)(Int32)o; // Распаковка, а затем приведение типа

            Point p2;
            p2.x = p2.y = 1;
            Object o2 = p2; // Упаковка p; o указывает на упакованный объект
            p2 = (Point)o2; // Распаковка o и копирование полей из экземпляра в стек


            Point p3;
            p3.x = p3.y = 1;
            Object o3 = p3; // Упаковка p; o указывает на упакованный экземпляр
            // Изменение поля x структуры Point (присвоение числа 2).
            p3 = (Point)o3; // Распаковка o и копирование полей из экземпляра
            // в переменную в стеке
            p3.x = 2; // Изменение состояния переменной в стеке
            o3 = p3; // Упаковка p; o ссылается на новый упакованный экземпляр
            // все эти операции обязательно сказываются на производительности приложения

            Int32 v = 5; // Создание неупакованной переменной значимого типа o
            Object o4 = v; // указывает на упакованное Int32, содержащее 5
            v = 123; // Изменяем неупакованное значение на 123
            Console.WriteLine(v + ", " + (Int32)o4); // Отображается "123, 5"
            // Дальше вызывается метод WriteLine, которому нужно передать объект String, но такого объекта нет. Вместо строкового объекта мы имеем неупакованный экземпляр значимого типа Int32 (v), объект String (ссылочного типа) и ссылку на упакованный экземпляр значимого типа Int32 (o), который приводится к неупакованному типу Int32. Эти элементы нужно как-то объединить, чтобы получился объект String.

            // Полученный IL-код станет эффективнее, если обращение к WriteLine переписать:
            Console.WriteLine(v + ", " + o4); // Отображается "123, 5"
            // Предыдущий код можно улучшить, изменив вызов метода WriteLine:
            Console.WriteLine(v.ToString() + ", " + o4); // Отображается "123, 5"

            Int32 v5 = 5; // Создаем неупакованную переменную значимого типа
            Object o5 = v5; // o указывает на упакованную версию v
            v = 123; // Изменяет неупакованный значимый тип на 123
            Console.WriteLine(v); // Отображает "123"
            v = (Int32)o; // Распаковывает и копирует o в v
            Console.WriteLine(v); // Отображает "5"

            Int32 v6 = 5; // Создаем переменную упакованного значимого типа
#if INEFFICIENT
            // При компиляции следующей строки v упакуется
            // три раза, расходуя и время, и память
            Console.WriteLine("{0}, {1}, {2}", v, v, v);
#else
            // Следующие строки дают тот же результат,
            // но выполняются намного быстрее и расходуют меньше памяти
            Object o6 = v6; // Упакуем вручную v (только единожды)
            // При компиляции следующей строки код упаковки не создается
            Console.WriteLine("{0}, {1}, {2}", o6, o6, o6);
#endif
        }

        public static void TestPakaging1()
        {
            // Создаем в стеке два экземпляра Point
            MyPoint p1 = new MyPoint(10, 10);
            MyPoint p2 = new MyPoint(20, 20);

            // p1 НЕ пакуется для вызова ToString (виртуальный метод)
            Console.WriteLine(p1.ToString()); // "(10, 10)"

            // p1 ПАКУЕТСЯ для вызова GetType (невиртуальный метод)
            Console.WriteLine(p1.GetType()); // "MyPoint"

            // p1 НЕ пакуется для вызова CompareTo
            // p2 НЕ пакуется, потому что вызван CompareTo(MyPoint)
            Console.WriteLine(p1.CompareTo(p2)); // "-1"

            // p1 пакуется , а ссылка размещается в c
            IComparable c = p1;
            Console.WriteLine(c.GetType()); // "MyPoint"

            // p1 НЕ пакуется для вызова CompareTo
            // Поскольку в CompareTo не передается переменная MyPoint,
            // вызывается CompareTo(Object), которому нужна ссылка
            // на упакованный MyPoint
            // c НЕ пакуется, потому что уже ссылается на упакованный MyPoint
            Console.WriteLine(p1.CompareTo(c)); // "0"

            // c НЕ пакуется, потому что уже ссылается на упакованный MyPoint
            // p2 ПАКУЕТСЯ, потому что вызывается CompareTo(Object)
            Console.WriteLine(c.CompareTo(p2));// "-1"

            // c пакуется, а поля копируются в p2
            p2 = (MyPoint)c;

            // Убеждаемся, что поля скопированы в p2
            Console.WriteLine(p2.ToString());// "(10, 10)"
        }

        internal struct MyPoint : IComparable
        {
            private Int32 m_x, m_y;
            // Конструктор, просто инициализирующий поля
            public MyPoint(Int32 x, Int32 y)
            {
                m_x = x;
                m_y = y;
            }

            // Переопределяем метод ToString, унаследованный от System.ValueType
            public override String ToString()
            {
                // Возвращаем Point как строку (вызов ToString предотвращает упаковку)
                return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
            }

            // Безопасная в отношении типов реализация метода CompareTo
            public Int32 CompareTo(MyPoint other)
            {
                // Используем теорему Пифагора для определения точки,
                // наиболее удаленной от начала координат (0, 0)
                return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
                - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
            }

            // Реализация метода CompareTo интерфейса IComparable
            public Int32 CompareTo(Object o) {
            if (GetType() != o.GetType()) {
                throw new ArgumentException("o is not a MyPoint");
            }
            // Вызов безопасного в отношении типов метода CompareTo
            return CompareTo((MyPoint)o);
            }
        }

        internal struct Point1
        {
            private Int32 m_x, m_y;
            public Point1(Int32 x, Int32 y)
            {
                m_x = x;
                m_y = y;
            }
            public void Change(Int32 x, Int32 y)
            {
                m_x = x; m_y = y;
            }
            public override String ToString()
            {
                return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
            }
        }

        // Интерфейс, определяющий метод Change
        internal interface IChangeBoxedPoint
        {
            void Change(Int32 x, Int32 y);
        }

        // Point - значимый тип
        internal struct Point2 : IChangeBoxedPoint
        {
            private Int32 m_x, m_y;
            public Point2(Int32 x, Int32 y)
            {
                m_x = x;
                m_y = y;
            }
            public void Change(Int32 x, Int32 y)
            {
                m_x = x; m_y = y;
            }
            public override String ToString()
            {
                return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
            }
        }
        
        public static void TestPakaging2()
        {
            Point1 p = new Point1(1, 1);
            Console.WriteLine(p);
            p.Change(2, 2);
            Console.WriteLine(p);

            Object o = p;
            Console.WriteLine(o);

            ((Point1)o).Change(3, 3);
            // При таком приведении типа o распаковывается, и поля упакованного объекта типа Point копируются во временный объект типа Point в стеке потока. Поля m_x и m_y этого временного объекта устанавливаются равными 3, но это обращение к Change не влияет на упакованный объект Point. При обращении к WriteLine снова выводится (2, 2). Для многих разработчиков это оказывается неожиданным.
            Console.WriteLine(o);


            Point2 p2 = new Point2(1, 1);
            Console.WriteLine(p2);
            p2.Change(2, 2);
            Console.WriteLine(p2);
            Object o2 = p2;
            Console.WriteLine(o2);
            ((Point2)o2).Change(3, 3);
            Console.WriteLine(o2);

            // p упаковывается, упакованный объект изменяется и освобождается
            ((IChangeBoxedPoint)p2).Change(4, 4);
            Console.WriteLine(p2); // 2 2
            // Упакованный объект изменяется и выводится
            ((IChangeBoxedPoint)o2).Change(5, 5);
            Console.WriteLine(o2); // 5 5
        }

        public static void TestEqualityAndIdentity()
        {

        }

        public static void TestDynamic()
        {
            dynamic value;
            for (Int32 demo = 0; demo < 2; demo++)
            {
                value = (demo == 0) ? (dynamic)5 : (dynamic)"A";
                value = value + value;
                M(value);
            }

            Object o1 = 123; // OK: Неявное приведение Int32 к Object (упаковка)
            // Int32 n1 = o1; // Ошибка: Нет неявного приведения Object к Int32
            Int32 n2 = (Int32)o1; // OK: Явное приведение Object к Int32 (распаковка)
            dynamic d1 = 123; // OK: Неявное приведение Int32 к dynamic (упаковка)
            Int32 n3 = d1; // OK: Неявное приведение dynamic к Int32 (распаковка)

            dynamic d = 123;
            // var result = M(d); // 'var result' - то же, что 'dynamic result'

            dynamic d2 = 123;
            var x2 = (Int32)d2; // Конвертация: 'var x' одинаково с 'Int32 x'
            var dt2 = new DateTime(d2); // Создание: 'var dt' одинаково с 'DateTime dt'

            //dynamic stringType = new StaticMemberDynamicWrapper(typeof(String));
            //var r = stringType.Concat("A", "B"); // Динамический вызов статического
            //// метода Concat класса String
            //Console.WriteLine(r); // выводится "AB"
        }

        private static void M(Int32 n) { Console.WriteLine("M(Int32): " + n); }
        private static void M(String s) { Console.WriteLine("M(String): " + s); }

        public static void TestCom()
        {
            //Application excel = new Application();
            //excel.Visible = true;
            //excel.Workbooks.Add(Type.Missing);
            //((Range)excel.Cells[1, 1]).Value = "Text in cell A1";
            // Помещаем эту строку в ячейку A1.

            // with dynamic
            //Application excel = new Application();
            //excel.Visible = true;
            //excel.Workbooks.Add(Type.Missing);
            //excel.Cells[1, 1].Value = "Text in cell A1";
            // Помещаем эту строку в ячейку A1
        }

        public static void TestReflection()
        {
            //Object target = "Jeffrey Richter";
            //Object arg = "ff";

            //// Находим метод, который подходит по типам аргументов
            //Type[] argTypes = newType[] { arg.GetType() };
            //MethodInfo method = target.GetType().GetMethod("Contains", argTypes);
            //// Вызываем метод с желаемым аргументом
            //Object[] arguments = newObject[] { arg };
            //Boolean result = Convert.ToBoolean(method.Invoke(target, arguments));

            dynamic target = "Jeffrey Richter";
            dynamic arg = "ff";
            Boolean result = target.Contains(arg);
        }

        internal sealed class StaticMemberDynamicWrapper : DynamicObject
        {
            private readonly TypeInfo m_type;
            public StaticMemberDynamicWrapper(Type type) { m_type = type.GetTypeInfo(); }
            public override IEnumerable<String> GetDynamicMemberNames()
            {
                return m_type.DeclaredMembers.Select(mi => mi.Name);
            }
            public override Boolean TryGetMember(GetMemberBinder binder, out object result)
            {
                result = null;
                var field = FindField(binder.Name);
                if (field != null) { result = field.GetValue(null); return true; }
                var prop = FindProperty(binder.Name, true);
                if (prop != null) { result = prop.GetValue(null, null); return true; }
                return false;
            }
            public override Boolean TrySetMember(SetMemberBinder binder, object value)
            {
                var field = FindField(binder.Name);
                if (field != null) { field.SetValue(null, value); return true; }
                var prop = FindProperty(binder.Name, false);
                if (prop != null) { prop.SetValue(null, value, null); return true; }
                return false;
            }
            //public override Boolean TryInvokeMember(InvokeMemberBinder binder, Object[]
            //args,
            //out Object result)
            //{
            //    MethodInfo method = FindMethod(binder.Name, args);
            //    if (method == null) { result = null; return false; }
            //    result = method.Invoke(null, args);
            //    return true;
            //}
            private MethodInfo FindMethod(String name, Type[] paramTypes)
            {
                return m_type.DeclaredMethods.FirstOrDefault(mi => mi.IsPublic &&
                mi.IsStatic
                && mi.Name == name
                && ParametersMatch(mi.GetParameters(), paramTypes));
            }
            private Boolean ParametersMatch(ParameterInfo[] parameters, Type[]
            paramTypes)
            {
                if (parameters.Length != paramTypes.Length) return false;
                for (Int32 i = 0; i < parameters.Length; i++)
                    if (parameters[i].ParameterType != paramTypes[i]) return false;
                return true;
            }
            private FieldInfo FindField(String name)
            {
                return m_type.DeclaredFields.FirstOrDefault(fi => fi.IsPublic && fi.IsStatic
                && fi.Name == name);
            }
            private PropertyInfo FindProperty(String name, Boolean get)
            {
                if (get)
                    return m_type.DeclaredProperties.FirstOrDefault(
                    pi => pi.Name == name && pi.GetMethod != null &&
                    pi.GetMethod.IsPublic && pi.GetMethod.IsStatic);
                return m_type.DeclaredProperties.FirstOrDefault(
                pi => pi.Name == name && pi.SetMethod != null &&
                pi.SetMethod.IsPublic && pi.SetMethod.IsStatic);
            }
        }

        // Примитивные типы в языках программирования
        // Типы данных, которые поддерживаются компилятором напрямую, называются примитивными (primitive types); у них существуют прямые аналоги в библиотеке классов .NET Framework Class Library (FCL).
        // Примитивный тип - FCL тип - Совместимость с CLS - Описание
        // sbyte - System.Sbyte - Нет - 8-разрядное значение со знаком
        // byte - System.Byte - Да - 8-разрядное значение без знака
        // short - System.Int16 - Да - 16-разрядное значение со знаком
        // ushort - System.Uint16 - Нет - 16-разрядное значение без знака
        // int - System.Int32 - Да - 32-разрядное значение со знаком
        // uint - System.Uint32 - Нет - 32-разрядное значение без знака
        // long - System.Int64 - Да - 64-разрядное значение со знаком
        // ulong - System.Uint64 - Нет - 64-разрядное значение без знака
        // char - System.Char - Да - 16-разрядный символ Unicode (char никогда не представляет 8-разрядное значение, как в неуправляемом коде на С++)
        // float - System.Single - Да - 32-разрядное значение с плавающей точкой в стандарте IEEE
        // double - System.Double - Да - 64-разрядное значение с плавающей точкой в стандарте IEEE
        // bool - System.Boolean - Да - Булево значение (true или false)
        // decimal - System.Decimal - Да - 128-разрядное значение с плавающей точкой повышенной точности, часто используемое для финансовых расчетов, где недопустимы ошибки округления. Один разряд числа — это знак, в следующих 96 разрядах помещается само значение, следующие 8 разрядов — степень числа 10, на которое делится 96-разрядное число (может быть в диапазоне от 0 до 28). Остальные разряды не используются
        // string - System.String - Да - Массив символов
        // object - System.Object - Да - Базовый тип для всех типов
        // dynamic - System.Object - Да - Для CLR тип dynamic идентичен типу object. Однако компилятор С# позволяет переменным типа dynamic участвовать в динамическом разрешении типа с упрощенным синтаксисом. Подробнее об этом читайте в разделе «Примитивный тип данных dynamic» в конце этой главы

        // Я не могу согласиться со следующим утверждением из спецификации языка C#: «С точки зрения стиля программирования предпочтительней использовать ключевое слово, а не полное системное имя типа», поэтому стараюсь задействовать имена FCL-типов и избегать имен примитивных типов. На самом деле, мне бы хотелось, чтобы имен примитивных типов не было совсем, а разработчики употребляли только имена FCL-типов. И вот по каким причинам.
        // - Мне попадались разработчики, не знавшие, какое ключевое слово использовать им в коде: string или String. В C# это не важно, так как ключевое слово string в точности преобразуется в FCL-тип System.String. Я также слышал, что некоторые разработчики говорили о том, что в 32-разрядных операционных системах тип int представлялся 32-разрядным типом, а в 64‑разрядных — 64-разрядным типом. Это утверждение совершенно неверно: в C# тип int всегда преобразуется в System.Int32, поэтому он всегда представляется 32-разрядным типом безотносительно запущенной операционной системы. Использование ключевого слова Int32 в своем коде позволит избежать путаницы.
        // - В C# long соответствует тип System.Int64, но в другом языке это может быть Int16 или Int32. Как известно, в С++/CLI тип long трактуется как Int32. Если кто-то возьмется читать код, написанный на новом для себя языке, то назначение кода может быть неверно им истолковано. Многим языкам незнакомо ключевое слово long, и их компиляторы не пропустят код, где оно встречается.
        // - У многих FCL-типов есть методы, в имена которых включены имена типов. Например, у типа BinaryReader есть методы ReadBoolean, ReadInt32, ReadSingle и т. д., а у типа System.Convert — методы ToBoolean, ToInt32, ToSingle и т. д. Вот вполне приемлемый код, в котором строка, содержащая float, выглядит неестественно; даже возникает впечатление, что код ошибочен: 
        // BinaryReader br = new BinaryReader(...);
        // float val = br.ReadSingle(); // Код правильный, но выглядит странно
        // Single val = br.ReadSingle(); // Код правильный и выглядит нормально
        // - Многие программисты, пишущие исключительно на С#, часто забывают, что в CLR могут применяться и другие языки программирования. Например, среда FCL практически полностью написана на С#, а разработчики из команды FCL ввели в библиотеку такие методы, как метод GetLongLength класса Array, возвращающий значение Int64, которое имеет тип long в С#, но не в других языках программирования (например, C++/CLI). Другой пример — метод LongCount класса System.Linq.Enumerable.

        // Int32 i = 5; // 32-разрядное число
        // Int64 l = i; // Неявное приведение типа к 64-разрядному значению
        // C# разрешает неявное приведение типа, если это преобразование «безопасно»,то есть не сопряжено с потерей данных; пример — преобразование из Int32 в Int64.
        // Однако для преобразования с риском потери данных C# требует явного приведения типа. Для числовых типов «небезопасное» преобразование означает «связанное с потерей точности или величины числа». Например, преобразование из Int32 в Byte требует явного приведения к типу, так как при больших величинах Int32 теряется точность; требует приведения и преобразование из Single в Int16, поскольку число Single может оказаться больше, чем допустимо для Int16.
        // Например, в случае приведения числа 6,8 типа Single к типу Int32 одни компиляторы сгенерируют код, который поместит в Int32 число 6, а другие округлят результат до 7. Между прочим, в C# дробная часть всегда отбрасывается.
        // к ним применима литеральная форма записи.
        // Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
        // Кроме того, благодаря тому, что выражения, состоящие из литералов, вычисляются на этапе компиляции, возрастает скорость выполнения приложения.
        // И наконец, компилятор «знает», как и в каком порядке интерпретировать встретившиеся в коде операторы (в том числе +, -, *, /, %, &, ^, |, ==, !=, >, <, >=, <=, <<, >>, ~, !, ++, -- и т. п.):

        // Проверяемые и непроверяемые операции для примитивных типов
        // Программистам должно быть хорошо известно, что многие арифметические операции над примитивными типами могут привести к переполнению:
        // Byte b = 100;
        // b = (Byte) (b + 200);// После этого b равно 44 (2C в шестнадцатеричной записи)
        // При выполнении этой арифметической операции CLR на первом шаге все значения операндов расширяются до 32 разрядов (или 64 разрядов, если для представления операнда 32 разрядов недостаточно). Поэтому b и 200 (для которых 32 разрядов достаточно) сначала преобразуются в 32-разрядные значения, а затем уже суммируются. Полученное 32-разрядное число (300 в десятичной системе, 12C в шестнадцатеричной), прежде чем поместить его обратно в переменную b, нужно привести к типу Byte. Так как в данном случае C# не выполняет неявного приведения типа, во вторую строку введена операция приведения к типу Byte.
        // В CLR есть IL-команды, позволяющие компилятору по-разному реагировать на переполнение. Например, суммирование двух чисел выполняет команда add, не реагирующая на переполнение, а также команда add.ovf, которая при переполнении генерирует исключение System.OverflowException. Кроме того, в CLR есть аналогичные IL-команды для вычитания (sub/sub.ovf), умножения (mul/mul.ovf) и преобразования данных (conv/conv.ovf).
        // Чтобы включить механизм управления процессом обработки переполнения на этапе компиляции, добавьте в командную строку компилятора параметр /checked+. Он сообщает компилятору, что для выполнения сложения, вычитания, умножения и преобразования должны быть сгенерированы IL-команды с проверкой переполнения.
        // C# предлагает такой механизм гибкого управления проверкой в виде операторов checked и unchecked.
        // Наряду с операторами checked и unchecked в C# есть одноименные инструкции, позволяющие включить проверяемые или непроверяемые выражения внутрь блока:
        // Установка режима контроля переполнения не влияет на работу метода, вызываемого внутри оператора или инструкции checked, так как действие оператора (и инструкции) checked распространяется только на выбор IL-команд сложения, вычитания, умножения и преобразования данных.
        // правила при использовании операторов checked и unchecked.
        // - Используйте типы со знаком (Int32 и Int64) вместо числовых типов без знака(UInt32 и UInt64) везде, где это возможно. Это позволит компилятору выявлять ошибку переполнения. Кроме того, некоторые компоненты библиотеки классов (например, свойства Length классов Array и String) жестко запрограммированы на возвращение значений со знаком, и передача этих значений в коде потребует меньшего количества преобразований типа (а следовательно, упростит структуру кода и его сопровождение). Кроме того, числовые типы без знака несовместимы с CLS.
        // - Включайте в блок checked ту часть кода, в которой возможно переполнение из-за неверных входных данных, например при обработке запросов, содержащих данные, предоставленные конечным пользователем или клиентской машиной. Возможно, также стоит перехватывать исключение OverflowException, чтобы ваше приложение могло корректно продолжить работу после таких сбоев.
        // - Включайте в блок unchecked те фрагменты кода, в которых переполнение не создает проблем (например, при вычислении контрольной суммы).
        // - В коде, где нет операторов и блоков checked и unchecked, предполагается, что при переполнении должно происходить исключение. Например, при вычислении простых чисел входные данные известны, а переполнение является признаком ошибки.
        // В процессе отладки кода установите параметр компилятора /checked+. Выполнение приложения замедлится, так как система будет контролировать переполнение во всем коде, не помеченном ключевыми словами checked или unchecked. Обнаружив исключение, вы сможете легко обнаружить его и исправить ошибку. В окончательной сборке приложения установите параметр /checked-,
        // Build, щелкните на кнопке Advanced и установите флажок Check for arithmetic overflow/underflow

        // Тип System.Decimal стоит особняком. В отличие от многих языков программирования (включая C# и Visual Basic), в CLR тип Decimal не относится к примитивным типам. В CLR нет IL-команд для работы со значениями типа Decimal. В документации по . NET Framework сказано, что тип Decimal имеет открытые статические методы-члены Add, Subtract, Multiply, Divide и прочие, а также перегруженные операторы +, -, *, / и т. д.
        // При компиляции кода с типом Decimal компилятор генерирует вызовы членов Decimal, которые и выполняют реальную работу. Поэтому значения типа Decimal обрабатываются медленнее примитивных CLR-типов. Кроме того, раз нет IL-команд для манипуляции числами типа Decimal, то не будут иметь эффекта ни операторы checked и unchecked, ни соответствующие параметры командной строки компилятора, а неосторожность в операциях над типом Decimal может привести к исключению OverflowException.
        // Аналогично, тип System.Numerics.BigInteger используется в массивах UInt32 для представления большого целочисленного значения, не имеющего верхней или нижней границы. Следовательно, операции с типом BigInteger никогда не вызовут исключения OverflowException. Однако они могут привести к выдаче исключения OutOfMemoryException, если значение переменной окажется слишком большим.

        // Ссылочные и значимые типы
        // CLR поддерживает две разновидности типов: ссылочные (reference types) и значимые (value types). Большинство типов в FCL — ссылочные, но программисты чаще всего используют значимые. Память для ссылочных типов всегда выделяется из управляемой кучи, а оператор C# new возвращает адрес в памяти, где размещается сам объект. При работе со ссылочными типами необходимо учитывать следующие обстоятельства, относящиеся к производительности приложения:
        // - память для ссылочных типов всегда выделяется из управляемой кучи;
        // - каждый объект, размещаемый в куче, содержит дополнительные члены, под лежащие инициализации;
        // - незанятые полезной информацией байты объекта обнуляются (это касается полей);
        // - размещение объекта в управляемой куче со временем инициирует сборку мусора.
        // чтобы ускорить обработку простых, часто используемых типов CLR предлагает «облегченные» типы — значимые. Экземпляры этих типов обычно размещаются в стеке потока (хотя они могут быть встроены и в объект ссылочного типа).
        // В представляющей экземпляр переменной нет указателя на экземпляр; поля экземпляра размещаются в самой переменной. Поскольку переменная содержит поля экземпляра, то для работы с экземпляром не нужно выполнять разыменование (dereference) экземпляра. Благодаря тому, что экземпляры значимых типов не обрабатываются уборщиком мусора, уменьшается интенсивность работы с управляемой кучей и сокращается количество сеансов уборки мусора, необходимых приложению на протяжении его существования.
        // Если тип называют классом (class), речь идет о ссылочном типе. Например, классы System.Object, System.Exception, System.IO.FileStream и System.Random — это ссылочные типы. В свою очередь, значимые типы в документации называются структурами (structure) и перечислениями (enumeration). Например, структуры System.Int32, System.Boolean, System.Decimal, System.TimeSpan и перечисления System.DayOfWeek, System.IO.FileAttributes и System.Drawing.FontStyle являются значимыми типами.
        // Все структуры являются прямыми потомками абстрактного типа System.ValueType, который, в свою очередь, является производным от типа System.Object. По умолчанию все значимые типы должны быть производными от System.ValueType. Все перечисления являются производными от типа System.Enum, производного от System.ValueType.
        // CLR значимый тип является изолированным, то есть он не может служить базовым типом для какого-либо другого ссылочного или значимого типа. Поэтому, например, нельзя в описании нового типа указывать в качестве базовых типы Boolean, Char, Int32, Uint64, Single, Double, Decimal и т. д.
        // В C# типы, объявленные как struct, являются значимыми, а объявленные как class, — ссылочными
        // C# также обеспечивает обнуление всех полей экземпляра значимого типа.
        // SomeVal v1; // Размещается в стеке
        // Единственное отличие в том, что экземпляр, созданный оператором new, C# «считает» инициализированным. Поясню эту мысль на следующем примере:
        // Проектируя свой тип, проверьте, не использовать ли вместо ссылочного типа значимый. Иногда это позволяет повысить эффективность кода. Сказанное особенно справедливо для типа, удовлетворяющего всем перечисленным далее условиям.
        // - Тип ведет себя подобно примитивному типу. В частности, это означает, что тип достаточно простой и у него нет членов, способных изменить экземплярные поля типа, в этом случае говорят, что тип неизменяемый (immutable). На самом деле, многие значимые типы рекомендуется помечать спецификатором readonly.
        // - Тип не обязан иметь любой другой тип в качестве базового.
        // - Тип не имеет производных от него типов.
        // для метода, возвращающего значимый тип, поля экземпляра копируются в память, выделенную вызывающим кодом в месте возврата из метода, что снижает эффективность работы программы. Поэтому в дополнение к перечисленным условиям следует объявлять тип как значимый, если верно хотя бы одно из следующих условий:
        // - Размер экземпляров типа мал (примерно 16 байт или меньше).
        // - Размер экземпляров типа велик (более 16 байт), но экземпляры не передаются в качестве параметров метода или не являются возвращаемыми из метода значениями.

        // Важнейшие отличия между значимыми и ссылочными типы:
        // - Объекты значимого типа существуют в двух формах (см. следующий раздел): неупакованной (unboxed) и упакованной (boxed). Ссылочные типы бывают только в упакованной форме.
        // - Значимые типы являются производными от System.ValueType. Этот тип имеет те же методы, что и System.Object. Однако System.ValueType переопределяет метод Equals, который возвращает true, если значения полей в обоих объектах совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode, который создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с производительностью в реализации по умолчанию, определяя собственные значимые типы значений, надо переопределить и написать свою реализацию методов Equals и GetHashCode. О методах Equals и GetHashCode рассказано в конце этой главы.
        // - Поскольку в объявлении нового значимого или ссылочного типа нельзя указывать значимый тип в качестве базового класса, создавать в значимом типе новые виртуальные методы нельзя. Методы не могут быть абстрактными и неявно являются запечатанными (то есть их нельзя переопределить).
        // - Переменные ссылочного типа содержат адреса объектов в куче. Когда переменная ссылочного типа создается, ей по умолчанию присваивается null, то есть в этот момент она не указывает на действительный объект. Попытка задействовать переменную с таким значением приведет к генерации исключения NullReferenceException. В то же время в переменной значимого типа всегда содержится некое значение соответствующего типа, а при инициализации всем членам этого типа присваивается 0. Поскольку переменная значимого типа не является указателем, при обращении к значимому типу исключение NullReferenceException возникнуть не может. CLR поддерживает понятие значимого типа особого вида, допускающего присваивание null (nullable types).
        // - Когда переменной значимого типа присваивается другая переменная значимого типа, выполняется копирование всех ее полей. Когда переменной ссылочно го типа присваивается переменная ссылочного типа, копируется только ее адрес.
        // - Вследствие сказанного в предыдущем пункте несколько переменных ссылочного типа могут ссылаться на один объект в куче, благодаря чему, работая с одной переменной, можно изменить объект, на который ссылается другая переменная. В то же время каждая переменная значимого типа имеет собственную копию данных «объекта», поэтому операции с одной переменной значимого типа не влияют на другую переменную.
        // - Так как неупакованные значимые типы не размещаются в куче, отведенная для них память освобождается сразу при возвращении управления методом, в котором описан экземпляр этого типа (в отличие от ожидания уборки мусора).

        // Как CLR управляет размещением полей для типа
        // Для повышения производительности CLR дано право устанавливать порядок размещения полей типа. Например, CLR может выстроить поля таким образом, что ссылки на объекты окажутся в одной группе, а поля данных и свойства — выровненные и упакованные — в другой. Однако при описании типа можно указать, сохранить ли порядок полей данного типа, определенный программистом, или разрешить CLR выполнить эту работу.
        // Для того чтобы сообщить CLR способ управления полями, укажите в описании класса или структуры атрибут System.Runtime.InteropServices.StructLayoutAttribute. Чтобы порядок полей устанавливался CLR, нужно передать конструктору атрибута параметр LayoutKind.Auto, чтобы сохранить установленный программистом порядок — параметр LayoutKind.Sequential, а параметр LayoutKind.Explicit позволяет разместить поля в памяти, явно задав смещения. Если в описании типа не применен атрибут StructLayoutAttribute, порядок полей выберет компилятор.
        // Для ссылочных типов (классов) компилятор C# выбирает вариант LayoutKind.Auto, а для значимых типов (структур) — LayoutKind.Sequential. Очевидно, разработчики компилятора считают, что структуры обычно используются для взаимодействия с неуправляемым кодом, а значит, поля нужно расположить так, как определено разработчиком. Однако при создании значимого типа, не работающего совместно с неуправляемым кодом, скорее всего, поведение компилятора, предлагаемое по умолчанию, потребуется изменить
        // Атрибут StructLayoutAttribute также позволяет явно задать смещение для всех полей, передав в конструктор LayoutKind.Explicit. Затем можно применить атрибут System.Runtime.InteropServices.FieldOffsetAttribute ко всем полям путем передачи конструктору этого атрибута значения типа Int32, определяющего смещение (в байтах) первого байта поля от начала экземпляра. Явное размещение обычно используется для имитации того, что в неуправляемом коде на C/C++ называлось объединением (union), то есть размещения нескольких полей с одного смещения в памяти 
        // Не допускается определение типа, в котором перекрываются ссылочный и значимый типы. Можно определить тип, в котором перекрываются несколько значимых типов, однако все перекрывающиеся байты должны быть доступны через открытые поля, чтобы обеспечить верификацию типа.

        // Упаковка и распаковка значимых типов
        // Значимые типы «легче» ссылочных: для них не нужно выделять память в управляемой куче, их не затрагивает сборка мусора, к ним нельзя обратиться через указатель. Однако часто требуется получать ссылку на экземпляр значимого типа, например если вы хотите сохранить структуры Point в объекте типа ArrayList (определен в пространстве имен System.Collections).
        // В каждой итерации цикла инициализируются поля значимого типа Point, после чего Point помещается в ArrayList. Задумаемся, что же помещается в ArrayList: сама структура Point, адрес структуры Point или что-то иное? За ответом обратимся к методу Add типа ArrayList и посмотрим описание его параметра. В данном случае прототип метода Add выглядит следующим образом: 
        // public virtual Int32 Add(Object value);
        // Отсюда видно, что в параметре Add должен передаваться тип Object, то есть ссылка (или указатель) на объект в управляемой куче. Однако в примере я передаю переменную p, имеющую значимый тип Point. Чтобы код работал, нужно преобразовать значимый тип Point в объект из управляемой кучи и получить на него ссылку.
        // Для преобразования значимого типа в ссылочный служит упаковка (boxing).При упаковке экземпляра значимого типа происходит следующее
        // - В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя дополнительными членами — указателем на типовой объект и индексом блока синхронизации. Эти члены необходимы для всех объектов в управляемой куче.
        // - Поля значимого типа копируются в память, только что выделенную в куче.
        // - Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается в ссылочный.
        // Компилятор C# создает IL-код, необходимый для упаковки экземпляра значимого типа, автоматически, но вы должны понимать, что происходит «за кулисами» и помнить об опасности «распухания» кода и снижения производительности.
        // время жизни упакованного значимого типа превышает время жизни неупакованного значимого типа.
        // В состав FCL входит новое множество обобщенных классов коллекций, из-за которых необобщенные классы коллекций считаются устаревшими. Так, вместо класса System.Collections.ArrayList следует использовать класс System.Collections.Generic.List<T>. 
        // T>. Обобщенные классы коллекций во многих отношениях совершеннее своих необобщенных аналогов. В частности, API-интерфейс стал яснее и совершеннее, кроме того, повышена производительность классов коллекций. Но одно из самых ценных улучшений заключается в предоставляемой обобщенными классами коллекций возможности работать с коллекциями значимых типов, не прибегая к их упаковке/распаковке. Одна эта особенность позволяет значительно повысить производительность, так как радикально сокращается число создаваемых в управляемой куче объектов, что, в свою очередь, сокращает число проходов сборщика мусора в приложении. В результате обеспечивается безопасность типов на этапе компиляции, а код становится понятнее за счет сокращения числа приведений типов 
        // Познакомившись с упаковкой, перейдем к распаковке. Допустим, в другом месте кода нужно извлечь первый элемент массива ArrayList
        // Здесь ссылка (или указатель), содержащаяся в элементе с номером 0 массива ArrayList, помещается в переменную p значимого типа Point. Для этого все поля, содержащиеся в упакованном объекте Point, надо скопировать в переменную p значимого типа, находящуюся в стеке потока. CLR выполняет эту процедуру в два этапа. Сначала извлекается адрес полей Point из упакованного объекта Point. Этот процесс называют распаковкой (unboxing). Затем значения полей копируются из кучи в экземпляр значимого типа, находящийся в стеке.
        // Распаковка не является точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем упаковка, и состоит только в получении указателя на исходный значимый тип (поля данных), содержащийся в объекте. В сущности, указатель ссылается на неупакованную часть упакованного экземпляра, и никакого копирования при распаковке (в отличие от упаковки) не требуется. Однако вслед за распаковкой обычно выполняется копирование полей.
        // При распаковке упакованного значимого типа происходит следующее.
        // - Если переменная, содержащая ссылку на упакованный значимый тип, равна null, генерируется исключение NullReferenceException
        // - Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа, генерируется исключение InvalidCastException
        // при распаковке объекта должно быть выполнено приведение к неупакованному типу (в нашем случае — к Int32)
        // Распаковка возвращает адрес неупакованной части упакованного объекта (дополнительные члены — указатель на типовой объект и индекс блока синхронизации — игнорируются)
        // Если вы хотя бы в малейшей степени заботитесь о производительности своего приложения, вам необходимо знать, когда компилятор создает код, выполняющий эти операции. К сожалению, многие компиляторы неявно генерируют код упаковки, поэтому иногда бывает сложно узнать о происходящей упаковке. Если меня действительно волнует производительность приложения, я прибегаю к такому инструменту, как ILDasm.exe, просматриваю IL-код готовых методов и смотрю, присутствуют ли в нем команды упаковки.
        // public static String Concat(Object arg0, Object arg1, Object arg2);
        // В качестве первого параметра, arg0, передается v. Но v — это неупакованное значение, а arg0 — это значение Object, поэтому экземпляр v нужно упаковать, а его адрес передать в качестве arg0. Параметром arg1 является строка "," в виде ссылки на объект String. И наконец, чтобы передать параметр arg2, o (ссылка на Object) приводится к типу Int32. Для этого нужна распаковка (но без копирования), при которой извлекается адрес неупакованного экземпляра Int32 внутри упакованного экземпляра Int32. Этот неупакованный экземпляр Int32 надо опять упаковать, а его адрес в памяти передать в качестве параметра arg2 методу Concat.
        // Метод Concat вызывает методы ToString для каждого указанного объекта и выполняет конкатенацию строковых представлений этих объектов. Возвращаемый из Concat объект String передается затем методу WriteLine, который отображает окончательный результат.
        // В показанных ранее вызовах WriteLine переменная v, имеющая неупакованный значимый тип Int32, передается по значению. Возможно, где-то у себя WriteLine упакует это значение Int32, но тут уж ничего не поделаешь. Главное — мы сделали то, что от нас зависело: убрали упаковку из своего кода. Пристально взглянув на FCL, можно заметить, что многие перегруженные методы используют в качестве параметров значимые типы. Так, тип System.Console предлагает несколько перегруженных вариантов метода WriteLine:
        // Передача значимого типа как Object приведет к упаковке, что отрицательно скажется на производительности. Определяя собственный класс, можно задать в нем обобщенные методы (возможно, содержащие параметры типа, которые являются значимыми типами). Обобщения позволяют определить метод, принимающий любой значимый тип, не требуя при этом упаковки (см. главу 12).
        // Простое правило: если нужна ссылка на экземпляр значимого типа, этот экземпляр должен быть упакован. Обычно упаковка выполняется, когда надо передать значимый тип методу, требующему ссылочный тип. Однако могут быть и другие ситуации, когда требуется упаковать экземпляр значимого типа.
        // Помните, мы говорили, что неупакованные значимые типы «легче» ссылочных, поскольку:
        // - память в управляемой куче им не выделяется;
        // - у них нет дополнительных членов, присущих каждому объекту в куче: указателя на типовой объект и индекса блока синхронизации.
        // Поскольку неупакованные значимые типы не имеют индекса блока синхронизации, то не может быть и нескольких потоков, синхронизирующих свой доступ к экземпляру через методы типа System.Threading.Monitor (или инструкция lock языка C#).
        // Хотя неупакованные значимые типы не имеют указателя на типовой объект, вы все равно можете вызывать виртуальные методы (такие, как Equals, GetHashCode или ToString), унаследованные или прееопределенные этим типом. Если ваш значимый тип переопределяет один из этих виртуальных методов, CLR может вызвать метод невиртуально, потому что значимые типы неявно запечатываются и поэтому не могут выступать базовыми классами других типов. Кроме того, экземпляр значимого типа, используемый для вызова виртуального метода, не упаковывается. Но если ваше переопределение виртуального метода вызывает реализацию этого метода из базового типа, экземпляр значимого типа упаковывается при вызове реализации базового типа, чтобы в указателе this базового метода передавалась ссылка на объект в куче.
        // Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы определены в System.Object, поэтому методы ожидают, что в аргументе this передается указатель на объект в куче.
        // Кроме того, приведение неупакованного экземпляра значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче.
        // В этом примере демонстрируется сразу несколько сценариев поведения кода, связанного с упаковкой/распаковкой.
        // - Вызов ToString. При вызове ToString упаковка p1 не требуется. Казалось бы, тип p1 должен быть упакован, так как ToString — метод, унаследованный от базового типа, System.ValueType. Обычно для вызова виртуального метода нужен указатель на типовой объект, а поскольку p1 является неупакованным значимым типом, то нет ссылки на типовой объект Point. Однако JIT-компилятор видит, что метод ToString переопределен в Point, и создает код, который напрямую (невиртуально) вызывает ToString. Компилятор знает, что полиморфизм здесь невозможен, коль скоро Point является значимым типом, а значимые типы не могут применяться для другого типа в качестве базового и по-другому реали-зовывать виртуальный метод. Ели бы метод ToString из Point во внутренней реализации вызывал base.ToString(), то экземпляр значимого типа был бы упакован при вызове метода ToString типа System.ValueType.
        // - Вызов GetType. При вызове невиртуального метода GetType упаковка p1 необходима, поскольку тип Point не реализует GetType, а наследует его от System.Object. Поэтому для вызова GetType нужен указатель на типовой объект Point, который можно получить только путем упаковки p1.
        // - Первый вызов CompareTo. При первом вызове CompareTo упаковка p1 не нужна, так как Point реализует метод CompareTo, и компилятор может просто вызвать его напрямую. Заметьте: в CompareTo передается переменная p2 типа Point, поэтому компилятор вызывает перегруженную версию CompareTo, которая принимает параметр типа Point. Это означает, что p2 передается в CompareTo по значению, и никакой упаковки не требуется.
        // - Приведение типа к IComparable. Когда выполняется приведение типа p1 к переменной интерфейсного типа (с), упаковка p1 необходима, так как интерфейсы по определению имеют ссылочный тип. Поэтому выполняется упаковка p1, а указатель на этот упакованный объект сохраняется в переменной c. Следующий вызов GetType подтверждает, что c действительно ссылается на упакованный объект Point в куче.
        // - Второй вызов CompareTo. При втором вызове CompareTo упаковка p1 не производится, потому что Point реализует метод CompareTo, и компилятор может вызывать его напрямую. Заметьте, что в CompareTo передается переменная с интерфейса IComparable, поэтому компилятор вызывает перегруженную версию CompareTo, которая принимает параметр типа Object. Это означает, что передаваемый параметр должен являться указателем, ссылающимся на объект в куче. К счастью, с уже ссылается на упакованный объект Point, по этой причине адрес памяти из c может передаваться в CompareTo и никакой дополнительной упаковки не требуется.
        // - Третий вызов CompareTo. При третьем вызове CompareTo переменная c уже ссылается на упакованный объект Point в куче. Поскольку переменная c сама по себе имеет интерфейсный тип IComparable, можно вызывать только метод CompareTo интерфейса, а ему требуется параметр Object. Это означает, что передаваемый аргумент должен быть указателем, ссылающимся на объект в куче. Поэтому выполняется упаковка p2 и указатель на этот упакованный объект передается в CompareTo.
        // - Приведение типа к Point. Когда выполняется приведение c к типу Point, объект в куче, на который указывает c, распаковывается, и его поля копируются из кучи в p2, экземпляр типа Point, находящийся в стеке.
        
        // Изменение полей в упакованных значимых типах посредством интерфейсов (и почему этого лучше не делать)
        // При таком приведении типа o распаковывается, и поля упакованного объекта типа Point копируются во временный объект типа Point в стеке потока. Поля m_x и m_y этого временного объекта устанавливаются равными 3, но это обращение к Change не влияет на упакованный объект Point. При обращении к WriteLine снова выводится (2, 2). Для многих разработчиков это оказывается неожиданным.
        // Некоторые языки, например C++/CLI, позволяют изменять поля в упакованном значимом типе, но только не C#. Однако и C# можно обмануть, применив интерфейс.
        // первом примере p — неупакованный объект типа Point — приводится к типу IChangeBoxedPoint. Такое приведение типа вызывает упаковку p. Метод Change вызывается для упакованного значения, и его поля m_x и m_y становятся равными 4, но при возврате из Change упакованный объект немедленно становится доступным для уборки мусора. Так что при пятом обращении к WriteLine на экран выводится (2, 2), что для многих неожиданно.
        // В последнем примере упакованный тип Point, на который ссылается o, приводится к типу IChangeBoxedPoint. Упаковка здесь не производится, поскольку тип o уже упакован. Затем вызывается метод Change, который изменяет поля m_x и m_y упакованного типа Point. Интерфейсный метод Change позволил мне изменить поля упакованного объекта типа Point! Теперь при обращении к WriteLine выводится (5, 5). Я привел эти примеры, чтобы продемонстрировать, как метод интерфейса может изменить поля в упакованном значимом типе. В C# сделать это без интерфейсов нельзя.
        
        // Внимание
        // Ранее в этой главе я отмечал, что значимые типы должны быть неизменяемыми, то есть в значимых типах нельзя определять члены, которые изменяют какие-либо поля экземпляра. Фактически я рекомендовал, чтобы такие поля в значимых типах помечались спецификатором readonly, чтобы компилятор сообщил об ошибке, если вы вдруг случайно напишите метод, пытающийся модифицировать такое поле. Предыдущий пример как нельзя лучше иллюстрирует это. Показанное в примере неожиданное поведение программы проявляется при попытке вызвать методы, изменяющие поля экземпляра значимого типа. Если после создания значимого типа не вызывать методы, изменяющие его состояние, не возникнет недоразумений при копировании поля в процессе упаковки и распаковки. Если значимый тип неизменяемый, результатом будет простое многократное копирование одного и того же состояния, поэтому не возникнет непонимания наблюдаемого поведения.
        // Некоторые главы этой книги я показал разработчикам. Познакомившись с примерами программ (например, из этого раздела), они сказали, что решили держаться подальше от значимых типов. Должен сказать, что эти незначительные нюансы значимых типов стоили мне многодневной отладки, поэтому я и описываю их в этой книге. Надеюсь, вы не забудете об этих нюансах, тогда они не застигнут вас врасплох. Не бойтесь значимых типов — они полезны и занимают свою нишу. Просто не забывайте, что ссылочные и значимые типы ведут себя по-разному в зависимости от того, как применяются. Возьмите предыдущий код и объявите Point как class, а не struct - увидите, что все получится. И наконец, радостная новость заключается в том, что значимые типы, содержащиеся в библиотеке FCL — Byte, Int32, UInt32, Int64, UInt64, Single, Double, Decimal, BigInteger, Complex и все перечислимые типы, — являются неизменяемыми и не преподносят никаких сюрпризов.

        // Равенство и тождество объектов
        // Часто разработчикам приходится создавать код сравнения объектов. В частности, это необходимо, когда объекты размещаются в коллекциях и требуется писать код для сортировки, поиска и сравнения отдельных элементов в коллекции. В этом разделе рассказывается о равенстве и тождестве объектов, а также о том, как определять тип, который правильно реализует равенство объектов.
        // У типа System.Object есть виртуальный метод Equals, который возвращает true для двух «равных» объектов. Вот как выглядит реализация метода Equals для Object:
        // public class Object
        // {
        //    public virtual Boolean Equals(Object obj)
        //    {
        //        // Если обе ссылки указывают на один и тот же объект,
        //        // значит, эти объекты равны
        //        if (this == obj) return true;
        //        // Предполагаем, что объекты не равны
        //        return false;
        //    }
        // }
        // стандартная реализация метода Equals типа Object реализует проверку на тождество, а не на равенство значений.

        // Вот как должна действовать правильная реализация метода Equals:
        // 1. Если аргумент obj равен null, вернуть false, так как ясно, что текущий объект, указанный в this, не равен null при вызове нестатического метода Equals.
        // 2. Если аргументы obj и this ссылаются на объекты одного типа, вернуть true. Этот шаг поможет повысить производительность в случае сравнения объектов с многочисленными полями.
        // 3. Если аргументы obj и this ссылаются на объекты разного типа, вернуть false. Понятно, что результат сравнения объектов String и FileStream равен false.
        // 4. Сравнить все определенные в типе экземплярные поля объектов obj и this. Если хотя бы одна пара полей не равна, вернуть false.
        // 5. Вызвать метод Equals базового класса, чтобы сравнить определенные в нем поля. Если метод Equals базового класса вернул false, тоже вернуть false, в противном случае вернуть true.
        // Правильная реализация
        //public class Object
        //{
        //    public virtual Boolean Equals(Object obj)
        //    {
        //        // Сравниваемый объект не может быть равным null
        //        if (obj == null) return false;
        //        // Объекты разных типов не могут быть равны
        //        if (this.GetType() != obj.GetType()) return false;
        //        // Если типы объектов совпадают, возвращаем true при условии,
        //        // что все их поля попарно равны.
        //        // Так как в System.Object не определены поля,
        //        // следует считать, что поля равны
        //        return true;
        //    }
        //} 

        // Если ваш тип переопределяет Equals, переопределенная версия метода должна вызывать реализацию Equals базового класса, если только не планируется вызывать реализацию в типе Object. Это означает еще и то, что поскольку тип может переопределять метод Equals типа Object, этот метод больше не может использоваться для проверки на тождественность. Для исправления ситуации в Object предусмотрен статический метод ReferenceEquals со следующим прототипом:
        //public class Object
        //{
        //    public static Boolean ReferenceEquals(Object objA, Object objB)
        //    {
        //        return (objA == objB);
        //    }
        //}
        // Для проверки на тождественность нужно всегда вызывать ReferenceEquals (то есть проверять на предмет того, относятся ли две ссылки к одному объекту).
        // Не нужно использовать оператор == языка C# (если только перед этим оба операнда не приводятся к типу Object), так как тип одного из операндов может перегружать этот оператор, в результате чего его семантика перестает соответствовать понятию «тождественность».
        // Кстати, в System.ValueType (базовом классе всех значимых типов) метод Equals типа Object переопределен и корректно реализован для проверки на равенство (но не тождественность). Внутреняя реализация переопределенного метода работает по следующей схеме:
        // 1. Если аргумент obj равен null, вернуть false.
        // 2. Если аргументы obj и this ссылаются на объекты разного типа, вернуть false.
        // 3. Для каждого экземплярного поля, определенного типом, сравнить значение из объекта obj со значением из объекта this вызовом метода Equals поля. Если хотя бы одна пара полей не равна, вернуть false.
        // 4. Вернуть true. Метод Equals типа ValueType не вызывает одноименный метод типа Object.
        // Для выполнения шага 3 в методе Equals типа ValueType используется отражение
        // Так как отражение в CLR работает медленно, при создании собственного значимого типа нужно переопределить Equals и создать свою реализацию, чтобы повысить производительность сравнения значений на предмет равенства экземпляров созданного типа. И, конечно же, не стоит вызывать из этой реализации метод Equals базового класса.
        // обеспечьте поддержку четырех характеристик, присущих равенству:
        // - Рефлексивность: x.Equals(x) должно возвращать true.
        // - Симметричность: x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение.
        // - Транзитивность: если x.Equals(y) возвращает true и y.Equals(z) возвращает true, то x.Equals(z) также должно возвращать true.
        // - Постоянство: если в двух сравниваемых значениях не произошло изменений, результат сравнения тоже не должен измениться.
        // При переопределении метода Equals может потребоваться выполнить несколько дополнительных операций.
        // - Реализовать в типе метод Equals интерфейса System.IEquatable<T>. Этот обобщенный интерфейс позволяет определить безопасный в отношении типов метод Equals. Обычно Equals реализуют так, что, принимая параметр типа Object, код метода вызывает безопасный в отношении типов метод Equals.
        // - Перегрузить методы операторов == и !=. Обычно код реализации этих операторных методов вызывает безопасный в отношении типов метод Equals.
        // Если предполагается сравнивать экземпляры собственного типа для целей сортировки, рекомендуется также реализовать метод CompareTo типа System.Icomparable и безопасный в отношении типов метод CompareTo типа System.IComparable<T>.
        // Реализовав эти методы, можно реализовать метод Equals так, чтобы он вызывал CompareTo типа System.IComparable<T> и возвращал true, если CompareTo возвратит 0. После реализации методов CompareTo также часто требуется перегрузить методы различных операторов сравнения (<, <=, >, >=) и реализовать код этих методов так, чтобы он вызывал безопасный в отношении типов метод CompareTo.

        // Хеш-коды объектов
        // Разработчики FCL решили, что было бы чрезвычайно полезно иметь возможность добавления в хеш-таблицы любых экземпляров любых типов. С этой целью в System.Object включен виртуальный метод GetHashCode, позволяющий вычислить для любого объекта целочисленный (Int32) хеш-код.
        // Если вы определяете тип и переопределяете метод Equals, вы должны переопределить и метод GetHashCode. Если при определении типа переопределить только один из этих методов, компилятор C# выдаст предупреждение.
        // Причина, по которой в типе должны быть определены оба метода — Equals и GetHashCode, — состоит в том, что реализация типов System.Collections.Hashtable, System.Collections.Generic.Dictionary и любых других коллекций требует, чтобы два равных объекта имели одинаковые значения хеш-кодов. Поэтому, переопределяя Equals, нужно переопределить GetHashCode и обеспечить соответствие алгоритма, применяемого для вычисления равенства, алгоритму,используемому для вычисления хеш-кода объекта.
        // По сути, когда вы добавляете пару «ключ-значение» в коллекцию, первым вычисляется хеш-код ключа. Он указывает, в каком «сегменте» будет храниться пара «ключ-значение». Когда коллекции требуется найти некий ключ, она вычисляет для него хеш-код. Хеш-код определяет «сегмент» поиска имеющегося в таблице ключа, равного заданному. Применение этого алгоритма хранения и поиска ключей означает, что если вы измените хранящийся в коллекции ключ объекта, коллекция больше не сможет найти этот объект. Если вы намерены изменить ключ объекта в хеш-таблице, то сначала удалите имеющуюся пару «ключ-значение», модифицируйте ключ, а затем добавьте в хеш-таблицу новую пару «ключ-значение».
        // Вот простой алгоритм, неплохо подходящий для объектов Point:
        //internal sealed class Point
        //{
        //    private readonly Int32 m_x, m_y;
        //    public override Int32 GetHashCode()
        //    {
        //        return m_x ^ m_y; // Исключающее ИЛИ для m_x и m_y
        //    }
        //}
        // Выбирая алгоритм вычисления хеш-кодов для экземпляров своего типа, старайтесь следовать определенным правилам:
        // - Используйте алгоритм, который дает случайное распределение, повышающее производительность хеш-таблицы.
        // - Алгоритм может вызывать метод GetHashCode базового типа и использовать возвращаемое им значение, однако в общем случае лучше отказаться от вызова встроенного метода GetHashCode для типа Object или ValueType, так как эти реализации обладают низкой производительностью алгоритмов хеширования.
        // - В алгоритме должно использоваться как минимум одно экземплярное поле.
        // - Поля, используемые в алгоритме, в идеале не должны изменяться, то есть они должны инициализироваться при создании объекта и сохранять значение в течение всей его жизни.
        // - Алгоритм должен быть максимально быстрым.
        // - Объекты с одинаковым значением должны возвращать одинаковые коды. Например, два объекта String, содержащие одинаковый текст, должны возвращать одно значение хеш-кода.
        // Внимание
        // Если вы взялись за собственную реализацию хеш-таблиц или пишете код, в котором будет вызываться метод GetHashCode, никогда не сохраняйте значения хеш-кодов. Они подвержены изменениям в силу своей природы. Например, при переходе к следующей версии типа алгоритм вычисления хеш-кода объекта может просто измениться.
        // не сохраняйте хеш коды в базе данных, изменение алгоритма - крах.

        // Примитивный тип данных dynamic
        // Язык C# обеспечивает безопасность типов данных. Это означает, что все выражения разрешаются в экземпляр типа и компилятор генерирует только тот код, который старается представить операции, правомерные для данного типа данных.
        // Однако возможны неприятные ситуации, возникающие из-за того, что программа должна выполняться на основе информации, недоступной до ее выполнения.
        // Если вы пишете приложение на «чистом» языке C#, неприятная ситуация может подстерегать вас только во время работы с информацией, определяемой на этапе выполнения, когда вы используете отражения.
        // Однако многие разработчики используют также С# для связи с компонентами, не реализованными на С#. Некоторые из этих компонентов могут быть написаны на динамических языках, например Python или Ruby, или быть COM-объектами, которые поддерживают интерфейс IDispatch (возможно, реализованный на С или C++), или объектами модели DOM (Document Object Model), реализованными при помощи разных языков и технологий. Взаимодействие с DOM-объектами особенно полезно для построения Silverlight-приложений.
        // Для того чтобы облегчить разработку при помощи отражений или коммуникаций с другими компонентами, компилятор С# предлагает помечать типы как динамические (dynamic). Вы также можете записывать результаты вычисления выражений в переменную и пометить ее тип как динамический. Затем динамическое выражение (переменная) может быть использовано для вызовов членов класса, например поля, свойства/индексатора, метода, делегата, или унарных/бинарных операторов. Когда ваш код вызывает член класса при помощи динамического выражения (переменной), компилятор создает специальный IL-код, который описывает желаемую операцию. Этот код называется полезной нагрузкой (payload). Во время выполнения программы он определяет существующую операцию для выполнения на основе действительного типа объекта, на который ссылается динамическое выражение (переменная).
        //public static void Main()
        //{
        //    dynamic value;
        //    for (Int32 demo = 0; demo < 2; demo++)
        //    {
        //        value = (demo == 0) ? (dynamic)5 : (dynamic)"A";
        //        value = value + value;
        //        M(value);
        //    }
        //}
        //private static void M(Int32 n) { Console.WriteLine("M(Int32): " + n); }
        //private static void M(String s) { Console.WriteLine("M(String): " + s); }
        // обратимся к оператору +. У этого оператора имеются операнды типа с пометкой dynamic. По этой причине компилятор С# генерирует код полезной нагрузки, который проверяет действительный тип переменной value во время выполнения и определяет, что должен делать оператор +.
        // Для вызова метода M компилятор создает код полезной нагрузки, который на этапе выполнения будет проверять действительный тип значения переменной, переданной методу M.
        // Когда тип поля, параметр метода, возвращаемый тип метода или локальная переменная снабжаются пометкой dynamic, компилятор конвертирует этот тип в тип System.Object и применяет экземпляр System.Runtime.CompilerServices.DynamicAttribute к полю, параметру или возвращаемому типу в метаданных. Если локальная переменная определена как динамическая, то тип переменной также будет типом Object, но атрибут DynamicAttribute неприменим к локальным переменным из-за того, что они используются только внутри метода. Из-за того, что типы dynamic и Object одинаковы, вы не сможете создавать методы с сигнатурами, отличающимися только типами dynamic и Object.
        // Тип dynamic можно использовать для определения аргументов типов обобщенных классов (ссылочный тип), структур (значимый тип), интерфейсов, делегатов или методов. Когда вы это делаете, компилятор конвертирует тип dynamic в Object и применяет DynamicAttribute к различным частям метаданных, где это необходимо. Обратите внимание, что обобщенный код, который вы используете, уже скомпилирован в соответствии с типом Object, и динамическая отправка не осуществляется, поскольку компилятор не производит код полезной нагрузки в обобщенном коде.
        // компилятор разрешит выполнить приведение типа dynamic к другому типу с использованием синтаксиса неявного приведения.
        // Если метод M, вызванный на этапе выполнения, возвращает void, выдается исключение Microsoft.CSharp.RuntimeBinder.RuntimeBinderException.
        // Внимание
        // Не путайте типы dynamic и var. Объявление локальной переменной как var является синтаксическим указанием компилятору подставлять специальные данные из соответствующего выражения. Ключевое слово var может использоваться только для объявления локальных переменных внутри метода, тогда как ключевое слово dynamic может указываться с локальными переменными, полями и аргументами. Вы не можете привести выражение к типу var, но вы можете привести его к типу dynamic. Вы должны явно инициализировать переменную, объявленную как var, тогда как переменную, объявленную как dynamic, инициализировать нельзя.
        // При преобразовании типа dynamic в другой статический тип результатом будет, очевидно, тоже статический тип. Аналогичным образом при создании типа с передачей конструктору одного и более аргументов dynamic результатом будет объект того типа, который вы создаете:
        // Если выражение dynamic задается как коллекция в инструкции foreach или как ресурс в директиве using, то компилятор генерирует код, который попытается привести выражение к необобщенному интерфейсу System.IEnumerable или интерфейсу System.IDisposable соответственно.
        // Внимание
        // Выражение dynamic реально имеет тот же тип, что и System.Object. Компилятор принимает операции с выражением как допустимые и не генерирует ни предупреждений, ни ошибок. Однако исключения могут быть выданы на этапе выполнения программы, если программа попытается выполнить недопустимую операцию. К тому же Visual Studio не предоставляет какой-либо IntelliSense-поддержки для написания кода с динамическими выражениями. Вы не можете определить метод расширения для dynamic (об этом рассказывается в главе 8), хотя можете его определить для Object. И вы можете использовать лямбда-выражение или анонимный метод (они оба обсуждаются в главе 17) в качестве аргумента при вызове динамического метода, потому что компилятор не может вычислить фактически используемые типы.
        // Без типа dynamic значение, возвращаемое excel.Cells[1, 1], имеет тип Object, который должен быть приведен к типу Range перед обращением к его свойству Value. Однако во время генерации выполняемой «обертки» для COM-объекта любое использование типа VARIANT в COM‑методе будет преобразовано в dynamic. Следовательно, поскольку выражение excel.Cells[1, 1] относится к типу dynamic, вам не обязательно явно приводить его к типу Range для обращения к свойству Value. Преобразование к dynamic значительно упрощает код, взаимодействующий с COM-объектами.
        // компилятор C# на этапе выполнения программы генерирует код полезной нагрузки, основываясь на действительных типах объекта. Этот код полезной нагрузки использует класс, известный как компоновщик (runtime binder).
        // Во время выполнения сборка Microsoft.CSharp.dll должна быть загружена в домен приложений, что снизит производительность приложения и повысит расход памяти. Кроме того, сборка Microsoft.SCharp.dll загружает библиотеки System.dll и System.Core.dll. А если вы используете тип dynamic для связи с COM-объектами, загружается и библиотека System.Dynamic.dll. И когда будет выполнен код полезной нагрузки, генерирующий динамический код во время выполнения, этот код окажется в сборке, названной анонимной сборкой динамических методов (Anonymously Hosted Dynamic Methods Assembly). Назначение этого кода заключается в повышении производительности динамических ссылок в ситуациях, в которых конкретное место вызова (call site) выдает много вызовов с динамическими аргументами, соответствующих одному типу на этапе выполнения.
        // Из-за всех издержек, связанных с особенностями встроенных динамических вычислений в C#, вы должны осознанно решить, что именно вы желаете добиться от динамического кода: превосходной производительности приложения при загрузке всех этих сборок или оптимального расходования памяти. Если динамический код используется только в паре мест вашего программного кода, разумнее придерживаться старого подхода: либо вызывать методы отражения (для управляемых объектов), либо «вручную» приводить типы (для COM-объектов).
        // Во время выполнения компоновщик С# разрешает динамические операции в соответствии с типом объекта. Сначала компоновщик проверяет, реализуется ли типом интерфейс IDynamicMetObjectProvider. И если интерфейс реализован, вызывается метод GetMetaObject, который возвращает тип, производный от DynamicMetaObject. Этот тип может обработать все привязки членов, методов и операторов, связанные с объектом. Интерфейс IDynamicMetaObjectProvider и основной класс DynamicMetaObject определены в пространстве имен System.Dynamic и находятся в сборке System.Core.dll.
        // Динамические языки, такие как Python и Ruby, используют типы, производные от DynamicMetaObject, что позволяет взаимодействовать с ними из других языков (например, C#). Аналогичным образом компоновщик C# при связи с COM-компонентами будет использовать порожденный тип DynamicMetaObject, умеющий взаимодействовать с COM-компонентами. Порожденный тип DynamicMetaObject определен в сборке System.Dynamic.dll.
        // Если тип объекта, используемый в динамическом выражении, не реализует интерфейс IDynamicMetaObjectProvider, тогда компилятор C# воспринимает его как обычный объект типа языка C# и все связанные с ним действия осуществляет через отражение.
        // Одно из ограничений динамических типов заключается в том, что они могут использоваться только для обращения к членам экземпляров, потому что динамическая переменная должна ссылаться на объект. Однако в некоторых случаях бывает полезно динамически вызывать статические методы типа, определяемого во время выполнения. Для этого я создал класс StaticMemberDynamicWrapper, производный от класса System.Dynamic.DynamicObject, реализующего интерфейс IDynamicMetaObjectProvider.
        // Чтобы вызвать статический метод динамически, сконструируйте экземпляр класса с передачей Type и сохраните ссылку на него в динамическую переменную. Затем вызовите нужный статический метод с использованием синтаксиса вызова экземплярного метода. Пример вызова статического метода Concat(String, String) класса String:


        // !!!
        // - readonly + 
        // - ArrayList+ 
        // - System.Collections.Generic.List<T> + 
        // - обобщения +
        // - отражение + 
        // - System.IEquatable<T>
        // - Перегрузить методы операторов == и !=.
        // - System.IComparable<T>
        // - var
        // - посмотреть тождество и равенство.
        // - dynamic
        // - c# и com

        // - повторить и разобрать материал главы !!!
    }
}
