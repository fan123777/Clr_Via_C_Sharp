using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._5_PrimitiveReferenceSignificantTypes
{
    class PrimitiveReferenceSignificantTypes
    {
        public static void main()
        {
            TestPrimitive();
            TestOverflow();
        }

        public static void TestPrimitive()
        {
            int a = 0; // Самый удобный синтаксис
            System.Int32 a1 = 0; // Удобный синтаксис
            int a2 = new int(); // Неудобный синтаксис
            System.Int32 a3 = new System.Int32(); // Самый неудобный синтаксис

            //BinaryReader br = new BinaryReader(...);
            //float val = br.ReadSingle(); // Код правильный, но выглядит странно
            //Single val = br.ReadSingle(); // Код правильный и выглядит нормально

            Int32 i1 = 5; // 32-разрядное число
            Int64 l1 = i1; // Неявное приведение типа к 64-разрядному значению
            // Могу вас обнадежить: код успешно компилируется и делает все, что ему положено. Дело в том, что компилятор C# неплохо разбирается в примитивных типах и применяет свои правила при компиляции кода. Иначе говоря, он распознает наиболее распространенные шаблоны программирования и генерирует такие IL-команды, благодаря которым исходный код работает так, как требуется. В первую очередь, это относится к приведению типов, литералам и операторам, примеры которых мы рассмотрим позже.

            // Начнем с того, что компилятор выполняет явное и неявное приведение между примитивными типами, например:
            Int32 i = 5; // Неявное приведение Int32 к Int32
            Int64 l = i; // Неявное приведение Int32 к Int64
            Single s = i; // Неявное приведение Int32 к Single
            Byte b = (Byte)i; // Явное приведение Int32 к Byte
            Int16 v = (Int16)s; // Явное приведение Single к Int16

            // Кроме того, благодаря тому, что выражения, состоящие из литералов, вычисляются на этапе компиляции, возрастает скорость выполнения приложения.
            Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
            Boolean found = false; // В готовом коде found присваивается 0
            Int32 x = 100 + 20 + 3; // В готовом коде x присваивается 123
            String s1 = "a " + "bc"; // В готовом коде s присваивается "a bc"

            Int32 x1 = 100; // Оператор присваивания
            Int32 y = x1 + 23; // Операторы суммирования и присваивания
            Boolean lessThanFifty = (y < 50); // Операторы "меньше чем" и присваивания

            Byte b1 = 100;
            b1 = (Byte)(b1 + 200);// После этого b равно 44 (2C в шестнадцатеричной записи)
            // При выполнении этой арифметической операции CLR на первом шаге все значения операндов расширяются до 32 разрядов (или 64 разрядов, если для представления операнда 32 разрядов недостаточно). Поэтому b и 200 (для которых 32 разрядов достаточно) сначала преобразуются в 32-разрядные значения, а затем уже суммируются. Полученное 32-разрядное число (300 в десятичной системе, 12C в шестнадцатеричной), прежде чем поместить его обратно в переменную b, нужно привести к типу Byte. Так как в данном случае C# не выполняет неявного приведения типа, во вторую строку введена операция приведения к типу Byte.
        }

        public static void TestOverflow()
        {
            UInt32 invalid = unchecked((UInt32)(-1)); // OK
            Byte b = 100;
            // b = checked((Byte)(b + 200)); // Выдается исключение OverflowException
            // Здесь b и 200 преобразуются в 32-разрядные числа и суммируются; результат равен 300. Затем при преобразовании 300 в Byte генерируется исключение OverflowException. Если приведение к типу Byte вывести из оператора checked, исключения не будет:
            b = (Byte)checked(b + 200); // b содержит 44; нет OverflowException
            checked
            { // Начало проверяемого блока
                Byte b1 = 100;
                // exception
                // b1 = (Byte)(b1 + 200); // Это выражение проверяется на переполнение
            }
            checked
            { // Начало проверяемого блока
                Byte b2 = 100;
                // exception
                // b2 += 200; // Это выражение проверяется на переполнение
            }


        }

        // Примитивные типы в языках программирования
        // Типы данных, которые поддерживаются компилятором напрямую, называются примитивными (primitive types); у них существуют прямые аналоги в библиотеке классов .NET Framework Class Library (FCL).
        // Примитивный тип - FCL тип - Совместимость с CLS - Описание
        // sbyte - System.Sbyte - Нет - 8-разрядное значение со знаком
        // byte - System.Byte - Да - 8-разрядное значение без знака
        // short - System.Int16 - Да - 16-разрядное значение со знаком
        // ushort - System.Uint16 - Нет - 16-разрядное значение без знака
        // int - System.Int32 - Да - 32-разрядное значение со знаком
        // uint - System.Uint32 - Нет - 32-разрядное значение без знака
        // long - System.Int64 - Да - 64-разрядное значение со знаком
        // ulong - System.Uint64 - Нет - 64-разрядное значение без знака
        // char - System.Char - Да - 16-разрядный символ Unicode (char никогда не представляет 8-разрядное значение, как в неуправляемом коде на С++)
        // float - System.Single - Да - 32-разрядное значение с плавающей точкой в стандарте IEEE
        // double - System.Double - Да - 64-разрядное значение с плавающей точкой в стандарте IEEE
        // bool - System.Boolean - Да - Булево значение (true или false)
        // decimal - System.Decimal - Да - 128-разрядное значение с плавающей точкой повышенной точности, часто используемое для финансовых расчетов, где недопустимы ошибки округления. Один разряд числа — это знак, в следующих 96 разрядах помещается само значение, следующие 8 разрядов — степень числа 10, на которое делится 96-разрядное число (может быть в диапазоне от 0 до 28). Остальные разряды не используются
        // string - System.String - Да - Массив символов
        // object - System.Object - Да - Базовый тип для всех типов
        // dynamic - System.Object - Да - Для CLR тип dynamic идентичен типу object. Однако компилятор С# позволяет переменным типа dynamic участвовать в динамическом разрешении типа с упрощенным синтаксисом. Подробнее об этом читайте в разделе «Примитивный тип данных dynamic» в конце этой главы

        // Я не могу согласиться со следующим утверждением из спецификации языка C#: «С точки зрения стиля программирования предпочтительней использовать ключевое слово, а не полное системное имя типа», поэтому стараюсь задействовать имена FCL-типов и избегать имен примитивных типов. На самом деле, мне бы хотелось, чтобы имен примитивных типов не было совсем, а разработчики употребляли только имена FCL-типов. И вот по каким причинам.
        // - Мне попадались разработчики, не знавшие, какое ключевое слово использовать им в коде: string или String. В C# это не важно, так как ключевое слово string в точности преобразуется в FCL-тип System.String. Я также слышал, что некоторые разработчики говорили о том, что в 32-разрядных операционных системах тип int представлялся 32-разрядным типом, а в 64‑разрядных — 64-разрядным типом. Это утверждение совершенно неверно: в C# тип int всегда преобразуется в System.Int32, поэтому он всегда представляется 32-разрядным типом безотносительно запущенной операционной системы. Использование ключевого слова Int32 в своем коде позволит избежать путаницы.
        // - В C# long соответствует тип System.Int64, но в другом языке это может быть Int16 или Int32. Как известно, в С++/CLI тип long трактуется как Int32. Если кто-то возьмется читать код, написанный на новом для себя языке, то назначение кода может быть неверно им истолковано. Многим языкам незнакомо ключевое слово long, и их компиляторы не пропустят код, где оно встречается.
        // - У многих FCL-типов есть методы, в имена которых включены имена типов. Например, у типа BinaryReader есть методы ReadBoolean, ReadInt32, ReadSingle и т. д., а у типа System.Convert — методы ToBoolean, ToInt32, ToSingle и т. д. Вот вполне приемлемый код, в котором строка, содержащая float, выглядит неестественно; даже возникает впечатление, что код ошибочен: 
        // BinaryReader br = new BinaryReader(...);
        // float val = br.ReadSingle(); // Код правильный, но выглядит странно
        // Single val = br.ReadSingle(); // Код правильный и выглядит нормально
        // - Многие программисты, пишущие исключительно на С#, часто забывают, что в CLR могут применяться и другие языки программирования. Например, среда FCL практически полностью написана на С#, а разработчики из команды FCL ввели в библиотеку такие методы, как метод GetLongLength класса Array, возвращающий значение Int64, которое имеет тип long в С#, но не в других языках программирования (например, C++/CLI). Другой пример — метод LongCount класса System.Linq.Enumerable.

        // Int32 i = 5; // 32-разрядное число
        // Int64 l = i; // Неявное приведение типа к 64-разрядному значению
        // C# разрешает неявное приведение типа, если это преобразование «безопасно»,то есть не сопряжено с потерей данных; пример — преобразование из Int32 в Int64.
        // Однако для преобразования с риском потери данных C# требует явного приведения типа. Для числовых типов «небезопасное» преобразование означает «связанное с потерей точности или величины числа». Например, преобразование из Int32 в Byte требует явного приведения к типу, так как при больших величинах Int32 теряется точность; требует приведения и преобразование из Single в Int16, поскольку число Single может оказаться больше, чем допустимо для Int16.
        // Например, в случае приведения числа 6,8 типа Single к типу Int32 одни компиляторы сгенерируют код, который поместит в Int32 число 6, а другие округлят результат до 7. Между прочим, в C# дробная часть всегда отбрасывается.
        // к ним применима литеральная форма записи.
        // Console.WriteLine(123.ToString() + 456.ToString()); // "123456"
        // Кроме того, благодаря тому, что выражения, состоящие из литералов, вычисляются на этапе компиляции, возрастает скорость выполнения приложения.
        // И наконец, компилятор «знает», как и в каком порядке интерпретировать встретившиеся в коде операторы (в том числе +, -, *, /, %, &, ^, |, ==, !=, >, <, >=, <=, <<, >>, ~, !, ++, -- и т. п.):

        // Проверяемые и непроверяемые операции для примитивных типов
        // Программистам должно быть хорошо известно, что многие арифметические операции над примитивными типами могут привести к переполнению:
        // Byte b = 100;
        // b = (Byte) (b + 200);// После этого b равно 44 (2C в шестнадцатеричной записи)
        // При выполнении этой арифметической операции CLR на первом шаге все значения операндов расширяются до 32 разрядов (или 64 разрядов, если для представления операнда 32 разрядов недостаточно). Поэтому b и 200 (для которых 32 разрядов достаточно) сначала преобразуются в 32-разрядные значения, а затем уже суммируются. Полученное 32-разрядное число (300 в десятичной системе, 12C в шестнадцатеричной), прежде чем поместить его обратно в переменную b, нужно привести к типу Byte. Так как в данном случае C# не выполняет неявного приведения типа, во вторую строку введена операция приведения к типу Byte.
        // В CLR есть IL-команды, позволяющие компилятору по-разному реагировать на переполнение. Например, суммирование двух чисел выполняет команда add, не реагирующая на переполнение, а также команда add.ovf, которая при переполнении генерирует исключение System.OverflowException. Кроме того, в CLR есть аналогичные IL-команды для вычитания (sub/sub.ovf), умножения (mul/mul.ovf) и преобразования данных (conv/conv.ovf).
        // Чтобы включить механизм управления процессом обработки переполнения на этапе компиляции, добавьте в командную строку компилятора параметр /checked+. Он сообщает компилятору, что для выполнения сложения, вычитания, умножения и преобразования должны быть сгенерированы IL-команды с проверкой переполнения.
        // C# предлагает такой механизм гибкого управления проверкой в виде операторов checked и unchecked.
        // Наряду с операторами checked и unchecked в C# есть одноименные инструкции, позволяющие включить проверяемые или непроверяемые выражения внутрь блока:


        // !!!


    }
}
