using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;

namespace CLR_VIA_C_SHARP._2_Type_Design._5_PrimitiveReferenceSignificantTypes
{
    class Testing
    {
        public void run()
        {
            TestReadonly();
            TestArrayList();
            TestList();
            //TestGeneric();
            TestReflection();
            TestTypes();
            TestBoxingUnboxing();
        }

        private void TestReadonly()
        {
            SampleClass p1 = new SampleClass(11, 21, 32);   // OK
            Console.WriteLine("p1: x={0}, y={1}, z={2}", p1.x, p1.y, p1.z);
            SampleClass p2 = new SampleClass();
            p2.x = 55;   // OK
            Console.WriteLine("p2: x={0}, y={1}, z={2}", p2.x, p2.y, p2.z);
            // p2.y = 66; // Error
        }

        private void TestArrayList()
        {
            // Creates and initializes a new ArrayList.
            ArrayList myAL = new ArrayList();
            myAL.Add("Hello");
            myAL.Add("World");
            myAL.Add("!");

            // Displays the properties and values of the ArrayList.
            Console.WriteLine("myAL");
            Console.WriteLine("    Count:    {0}", myAL.Count);
            Console.WriteLine("    Capacity: {0}", myAL.Capacity);
            Console.Write("    Values:");
            PrintValues(myAL);
        }

        private static void PrintValues(IEnumerable myList)
        {
            foreach (Object obj in myList)
                Console.Write("   {0}", obj);
            Console.WriteLine();
        }

        private void TestList()
        {

        }

        private void TestGeneric()
        {
            MyObj<int> obj1 = new MyObj<int>(25);
            obj1.objectType();

            MyObjects<string, byte, decimal> obj2 = new MyObjects<string, byte, decimal>("Alex", 26, 12.333m);
            obj2.objectsType();

            Console.ReadLine();
        }

        private void TestReflection()
        {
            // Using GetType to obtain type information:
            int i = 42;
            System.Type type = i.GetType();
            System.Console.WriteLine(type);

            // Using Reflection to get information from an Assembly:
            System.Reflection.Assembly info = typeof(System.Int32).Assembly;
            System.Console.WriteLine(info);
        }

        private void TestTypes()
        {
            // SomeRef r1 = new SomeRef(); // Размещается в куче
            // SomeVal v1 = new SomeVal(); // Размещается в стеке
            // SomeVal v1;
            // Единственное отличие в том, что экземпляр, созданный оператором new, C# «считает» инициализированным.
        }

        private void TestBoxingUnboxing()
        {

        }
    }

    class Age
    {
        readonly int _year;
        Age(int year)
        {
            _year = year;
        }
        void ChangeYear()
        {
            //_year = 1967; // Compile error if uncommented.
        }
    }

    class SampleClass
    {
        public int x;
        // Initialize a readonly field
        public readonly int y = 25;
        public readonly int z;

        public SampleClass()
        {
            // Initialize a readonly instance field
            z = 24;
        }

        public SampleClass(int p1, int p2, int p3)
        {
            x = p1;
            y = p2;
            z = p3;
        }
    }

    // Создадим обобщенный класс имеющий параметр типа T
    class MyObj<T>
    {
        T obj;

        public MyObj(T obj)
        {
            this.obj = obj;
        }

        public void objectType()
        {
            Console.WriteLine("Тип объекта: " + typeof(T));
        }
    }

    // Обобщенный класс с несколькими параметрами
    class MyObjects<T, V, E>
    {
        T obj1;
        V obj2;
        E obj3;

        public MyObjects(T obj1, V obj2, E obj3)
        {
            this.obj1 = obj1;
            this.obj2 = obj2;
            this.obj3 = obj3;
        }

        public void objectsType()
        {
            Console.WriteLine("\nТип объекта 1: " + typeof(T) +
                "\nТип объекта 2: " + typeof(V) +
                "\nТип объекта 3: " + typeof(E));
        }
    }

    // readonly
    // Ключевое слово readonly — это модификатор, который можно использовать для полей.Если объявление поля содержит модификатор readonly, присвоение значений таким полям может происходить только как часть объявления или в конструкторе в том же классе.
    // Можно присвоить значение полю readonly только в следующих контекстах:
    // - Когда переменная инициализируется в объявлении, например:
    // public readonly int y = 5;
    // - Для поля экземпляра — в конструкторах экземпляров класса, содержащего объявление поля, или, для статического поля — в статическом конструкторе класса, содержащего объявление поля.Это единственно возможные контексты, в которых можно передавать поле readonly в качестве параметра out или ref.
    // Ключевое слово readonly отличается от ключевого слова const. Поле с модификатором const может быть инициализировано только при объявлении поля.Поле с модификатором readonly может быть инициализировано при объявлении или в конструкторе.Следовательно, поля с модификатором readonly могут иметь различные значения в зависимости от использованного конструктора.Кроме того, поле const является константой во время компиляции, а поле readonly можно использовать для констант времени выполнения, как показано в следующем примере
    // public static readonly uint timeStamp = (uint)DateTime.Now.Ticks;

    // ArrayList
    // Реализует интерфейс IList с помощью массива с динамическим изменением размера по требованию.
    // - Сортировка списка ArrayList не гарантируется. Необходимо отсортировать список ArrayList перед выполнением операций (таких, как BinarySearch), для которых требуется отсортированный список ArrayList.
    // - Емкость коллекции ArrayList — это количество элементов, которое может вместить коллекция ArrayList. Когда в список ArrayList добавляются элементы, его емкость автоматически увеличивается должным образом посредством перераспределения. Емкость может быть уменьшена посредством вызова метода TrimToSize или с помощью явного задания свойства Capacity.
    // - Доступ к элементам этой коллекции осуществляется с помощью целочисленного индекса. Индексы в этой коллекции начинаются с нуля.
    // - Коллекция ArrayList принимает null как допустимое значение и разрешает дублировать элементы.
    // - Использование многомерных массивов в качестве элементов коллекции ArrayList не поддерживается.

    // List<T>
    // Представляет строго типизированный список объектов, доступных по индексу. Поддерживает методы для поиска по списку, выполнения сортировки и других операций со списками.
    // 

    // Обобщения
    // Термин обобщение, по существу, означает параметризированный тип. Особая роль параметризированных типов состоит в том, что они позволяют создавать классы, структуры, интерфейсы, методы и делегаты, в которых обрабатываемые данные указываются в виде параметра. С помощью обобщений можно, например, создать единый класс, который автоматически становится пригодным для обработки разнотипных данных. Класс, структура, интерфейс, метод или делегат, оперирующий параметризированным типом данных, называется обобщенным, как, например, обобщенный класс или обобщенный метод.
    // Давайте рассмотрим основные преимущества использования обобщений:
    // - Производительность
    // Одним из основных преимуществ обобщений является производительность. Использование типов значений с необобщенными классами коллекций вызывает упаковку (boxing) и распаковку (unboxing) при преобразовании в ссылочный тип и обратно.
    // - Безопасность
    // Другим свойством обобщений является безопасность типов. Обобщения автоматически обеспечивают типовую безопасность всех операций. В ходе выполнения этих операций обобщения исключают необходимость обращаться к приведению типов и проверять соответствие типов в коде вручную.
    // - Повторное использование двоичного кода
    // Обобщения повышают степень повторного использования двоичного кода. Обобщенный класс может быть определен однажды, и на его основе могут быть созданы экземпляры многих типов. При этом не нужно иметь доступ к исходным текстам, как это необходимо в случае шаблонов С++.
    // - "Разбухание" кода
    // Насколько много кода генерируется при создании экземпляров конкретных типов из обобщений? Поскольку определение обобщенного класса включается в сборку, создание на его основе конкретных классов специфических типов не приводит к дублированию кода в IL.
    
    // Reflection
    // Механизм отражения позволяет получать объекты (типа Type), которые описывают сборки, модули и типы.Отражение можно использовать для динамического создания экземпляра типа, привязки типа к существующему объекту, а также получения типа из существующего объекта и вызова его методов или доступа к его полям и свойствам.Если в коде используются атрибуты, отражение обеспечивает доступ к ним.
    // Ключевые слова C# protected и internal не имеют никакого значения в промежуточном языке и не используются в интерфейсах API отражения.Соответствующими терминами в промежуточном языке являются Family и Assembly.Для идентификации метода internal с помощью отражения используется свойство IsAssembly.Для идентификации метода protected internal используется свойство IsFamilyOrAssembly.
    // Отражение удобно использовать в следующих ситуациях.
    // - При необходимости доступа к атрибутам в метаданных программы.Дополнительные сведения см. в разделе Извлечение информации, сохраненной в атрибуте.
    // - Для проверки и создания экземпляров типов в сборке.
    // - Для создания новых типов во время выполнения.Используйте классы в System.Reflection.Emit.
    // - Для выполнения позднего связывания, которое обеспечивает доступ к методам в типах, созданных во время выполнения
}
