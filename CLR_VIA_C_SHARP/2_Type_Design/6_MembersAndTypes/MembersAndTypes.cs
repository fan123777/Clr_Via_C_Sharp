using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._6_MembersAndTypes
{
    class MembersAndTypes
    {
        public static void main()
        {
            testCall();
        }

        private static void testCall()
        {
            Console.WriteLine(); // Вызов статического метода
            Object o = new Object();
            o.GetHashCode(); // Вызов виртуального экземплярного метода
            o.GetType(); // Вызов невиртуального экземплярного метода

            Point p = new Point(3, 4);
            // Компилятор C# вставит здесь инструкцию callvirt,
            // но JIT-компилятор оптимизирует этот вызов и сгенерирует код
            // для невиртуального вызова ToString,
            // поскольку p имеет тип Point, являющийся запечатанным
            Console.WriteLine(p.ToString());
        }
        // Члены типа
        // В типе можно определить следующие члены:
        // - Константа — идентификатор, определяющий некую постоянную величину. Эти идентификаторы обычно используют, чтобы упростить чтение кода, а также для удобства сопровождения и поддержки. Константы всегда связаны с типом, а не с экземпляром типа, а на логическом уровне константы всегда являются статическими членами.
        // - Поле представляет собой значение данных, доступное только для чтения или для чтения/записи. Поле может быть статическим — тогда оно является частью состояния типа. Поле может быть экземплярным (нестатическим) — тогда оно является частью состояния конкретного объекта. Я настоятельно рекомендую ограничивать доступ к полям, чтобы внешний код не мог нарушить состояние типа или объекта.
        // - Конструктор экземпляров — метод, служащий для инициализации полей экземпляра при его создании.
        // - Конструктор типа — метод, используемый для инициализации статических полей типа.
        // - Метод представляет собой функцию, выполняющую операции, которые изменяют или запрашивают состояние типа (статический метод) или объекта (экземплярный метод). Методы обычно осуществляют чтение и запись полей типов или объектов.
        // - Перегруженный оператор определяет, что нужно проделать с объектом при применении к нему конкретного оператора. Перегрузка операторов не входит в общеязыковую спецификацию CLS, поскольку не все языки программирования ее поддерживают.
        // - Оператор преобразования — метод, задающий порядок явного или неявного преобразования объекта из одного типа в другой. Операторы преобразования не входят в спецификацию CLS по той же причине, что и перегруженные операторы.
        // - Свойство представляет собой механизм, позволяющий применить простой синтаксис (напоминающий обращение к полям) для установки или получения части логического состояния типа или объекта с контролем логической целостности этого состояния. Свойства бывают необобщенными (распространенный случай) и обобщенными (встречаются редко, в основном в классах коллекций).
        // - Событие — механизм статических событий позволяет типу отправлять уведомления статическим или экземплярным методам. Механизм экземплярных (нестатических) событий позволяет объекту посылать уведомление статическому или экземплярному методу. События обычно инициируются в ответ на изменение состояния типа или объекта, порождающего событие. Событие состоит из двух методов, позволяющих статическим или экземплярным методам регистрировать и отменять регистрацию (подписку) на событие. Помимо этих двух методов, в событиях обычно используется поле-делегат для управления набором зарегистрированных методов. 
        // - Тип позволяет определять другие вложенные в него типы. Обычно этот подход применяется для разбиения большого, сложного типа на небольшие блоки с целью упростить его реализацию.
        // Формат метаданных един и не зависит от выбранного языка программирования — именно поэтому CLR называют общеязыковой исполняющей средой.
        // Стандартный формат метаданных также используется средой CLR для определения порядка поведения констант, полей, конструкторов, методов, свойств и событий во время выполнения. Короче говоря, метаданные — это ключ ко всей платформе разработки Microsoft .NET Framework; они обеспечивают интеграцию языков, типов и объектов. 

        // Видимость типа
        // При определении типа с видимостью в рамках файла, а не другого типа его можно сделать открытым (public) или внутренним (internal). Открытый тип доступен любому коду любой сборки. Внутренний тип доступен только в той сборке, где он определен. По умолчанию компилятор C# делает тип внутренним (с более ограниченной видимостью). Вот несколько примеров.

        // Дружественные сборки
        // То есть нам необходим способ, который бы позволил группе А определить свои типы как внутренние, но в то же время предоставить группе Б доступ к этим типам. Для таких ситуаций в CLR и C# предусмотрен механизм дружественных сборок (friend assemblies). Кстати говоря, он пригодится еще и в ситуации со сборкой, содержащей код, который выполняет модульные тесты с внутренними типами другой сборки.
        // В процессе создания сборки можно указать другие сборки, которые она будет считать «друзьями», — для этого служит атрибут InternalsVisibleTo, определенный в пространстве имен System.Runtime.CompilerServices. что дружественные сборки получают доступ ко всем внутренним типам сборки, а также к внутренним членам этих типов. Приведем пример сборки, которая объявляет дружественными две другие сборки со строгими именами Wintellect и Microsoft:
        // using System.Runtime.CompilerServices; // Для атрибута InternalsVisibleTo
        // Внутренние типы этой сборки доступны из кода двух следующих сборок
        // (независимо от версии или региональных стандартов)
        // [assembly:InternalsVisibleTo("Wintellect, PublicKey=12345678...90abcdef")]
        // [assembly:InternalsVisibleTo("Microsoft, PublicKey=b77a5c56...1934e089")]
        // Поскольку внутренние члены принадлежащих сборке типов становятся доступными для дружественных сборок, следует очень осторожно подходить к определению уровня доступа, предоставляемого членам своего типа, и объявлению дружественных сборок.

        // Доступ к членам типов
        // При определении члена типа (в том числе вложенного) можно указать модификатор доступа к члену. Модификаторы определяют, на какие члены можно ссылаться из кода.
        // CLR - C# - Описание
        // Private (закрытый) - private - Доступен только методам в определяющем типе и вложенных в него типах
        // Family (родовой) - protected - Доступен только методам в определяющем типе (и вложенных в него типах) или в одном из его производных типов независимо от сборки
        // Family and Assembly (родовой и сборочный) - (не поддер-живается) - Доступен только методам в определяющем типе (и вложенных в него типах) и производных типах в определяющей сборке
        // Assembly (сборочный) - internal - Доступен только методам в определяющей сборке
        // Assembly or Family - protected internal - Доступен только методам вложенного типа, производного типа (независимо от сборки) и любым методам определяющей сборки
        // Public (открытый) - public - Доступен всем методам во всех сборках
        // В процессе компиляции кода компилятор языка проверяет корректность обращения кода к типам и членам. Обнаружив некорректную ссылку на какие-либо типы или члены, компилятор информирует об ошибке.
        // Верификация IL-кода гарантирует правильность обработки модификаторов доступа к членам в период выполнения, даже если компилятор языка проигнорировал проверку доступа.
        // Другая, более вероятная возможность заключается в компиляции кода, обращающегося к открытому члену другого типа (другой сборки); если в период выполнения загрузится другая версия сборки, где модификатор доступа открытого члена заменен защищенным (protected) или закрытым (private), верификация обеспечит корректное управление доступом.
        // Если модификатор доступа явно не указан, компилятор C# обычно (но не всегда) выберет по умолчанию закрытый — наиболее строгий из всех. CLR требует, чтобы все члены интерфейсного типа были открытыми. Компилятор C# знает об этом и запрещает программисту явно указывать модификаторы доступа к членам интерфейса, просто делая все члены открытыми.
        // Если в производном типе переопределяется член базового типа, компилятор C# требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. То есть если член базового класса является защищенным, то и член производного класса должен быть защищенным. Однако это ограничение языка C#, а не CLR.
        // При наследовании от базового класса CLR позволяет снижать, но не повышать ограничения доступа к члену. Например, защищенный метод базового класса можно переопределить в производном классе в открытый, но не в закрытый. Дело в том, что пользователь производного класса всегда может получить доступ к методу базового класса путем приведения к базовому типу. Если бы среда CLR разрешала устанавливать более жесткие ограничения на доступ к методу в производном типе, то эти ограничения бы элементарно обходились. 

        // Статические классы
        // Существуют классы, не предназначенные для создания экземпляров, например Console, Math, Environment и ThreadPool. У этих классов есть только статические методы. В сущности, такие классы существуют лишь для группировки логически связанных членов. Например, класс Math объединяет методы, выполняющие математические операции. В C# такие классы определяются с ключевым словом static. Его разрешается применять только к классам, но не к структурам (значимым типам), поскольку CLR всегда разрешает создавать экземпляры значимых типов, и нет способа обойти это ограничение.
        // Компилятор налагает на статический класс ряд ограничений:
        // - Класс должен быть прямым потомком System.Object — наследование любому другому базовому классу лишено смысла, поскольку наследование применимо только к объектам, а создать экземпляр статического класса невозможно.
        // - Класс не должен реализовывать никаких интерфейсов, поскольку методы интерфейса можно вызывать только через экземпляры класса.
        // - В классе можно определять только статические члены (поля, методы, свойства и события). Любые экземплярные члены вызовут ошибку компиляции.
        // - Класс нельзя использовать в качестве поля, параметра метода или локальной переменной, поскольку это подразумевает существование переменной, ссылающейся на экземпляр, что запрещено. Обнаружив подобное обращение со статическим классом, компилятор вернет сообщение об ошибке.
        // определение класса с ключевым словом static заставляет компилятор C# сделать этот класс абстрактным (abstract) и запечатанным (sealed). Более того, компилятор не создает в классе метод конструктора экземпляров (.ctor).

        // Частичные классы, структуры и интерфейсы
        // Ключевое слово partial говорит компилятору C#, что исходный код класса, структуры или интерфейса может располагаться в нескольких файлах. Компилятор объединяет все частичные файлы класса во время компиляции; CLR всегда работает с полными определениями типов. Есть три основные причины, по которым исходный код разбивается на несколько файлов.
        // - Управление версиями. Представьте, что определение типа содержит большой объем исходного кода. Если этот тип будут одновременно редактировать два программиста, по завершении работы им придется каким-то образом объединять свои результаты, что весьма неудобно. Ключевое слово partial позволяет разбить исходный код типа на несколько файлов, чтобы один и тот же тип могли одновременно редактировать несколько программистов.
        // - Разделение файла или структуры на логические модули внутри файла. Иногда требуется создать один тип для решения разных задач. Для упрощения реализации я иногда объявляю одинаковые типы повторно внутри одного файла. Затем в каждой части такого типа я реализую по одному функциональному аспекту типа со всеми его полями, методами, свойствами, событиями и т. д. Это позволяет мне упростить наблюдение за членами, обеспечивающими единую функциональность и объединенными в группу. Я также могу легко закомментировать частичный тип с целью удаления всей функциональности из класса или замены ее другой (путем использования новой части частичного типа). 
        // - Разделители кода. При создании в Microsoft Visual Studio нового проекта Windows Forms или Web Forms некоторые файлы с исходным кодом создаются автоматически. Они называются шаблонными. При использовании конструкторов форм Visual Studio в процессе создания и редактирования элементов управления формы автоматически генерирует весь необходимый код и помещает его в отдельные файлы. Это значительно повышает продуктивность работы. Раньше автоматически генерируемый код попадал в тот же файл, где программист писал свой исходный код. Однако при случайном изменении сгенерированного кода конструктор форм переставал корректно работать. Начиная с Visual Studio 2005, при создании нового проекта Visual Studio создает два исходных файла: один предназначен для программиста, а в другой помещается код, создаваемый редактором форм. В результате вероятность случайного изменения генерируемого кода существенно снижается.
        // Как уже отмечалось, частичные типы реализуются только компилятором C#; поэтому все файлы с исходным кодом таких типов необходимо писать на одном языке и компилировать их вместе как единый блок компиляции.

        // Компоненты, полиморфизм и версии
        // При компонентной разработке приложений (Component Software Programming, CSP) идеи ООП используются на уровне компонентов. Ниже перечислены некоторые свойства компонента.
        // - Компонент (сборка в .NET) можно публиковать.
        // - Компоненты уникальны и идентифицируются по имени, версии, региональным стандартам и открытому ключу
        // - Компонент сохраняет свою уникальность (код одной сборки никогда статически не связывается с другой сборкой — в .NET применяется только динамическое связывание).
        // - В компоненте всегда четко указана зависимость от других компонентов (ссылочные таблицы метаданных).
        // - В компоненте документированы его классы и члены. В C# даже разрешается включать в код компонента XML-документацию — для этого служит параметр /doc командной строки компилятора.
        // - В компоненте определяются требуемые разрешения на доступ. Для этого в CLR существует механизм защиты доступа к коду (Code Access Security, CAS).
        // - Опубликованный компонентом интерфейс (объектная модель) не изменяется во всех его служебных версиях. Служебной версией (servicing) называют новую версию компонента, обратно совместимую с оригинальной. Обычно служебная версия содержит исправления ошибок, исправления системы безопасности и небольшие корректировки функциональности. Однако в нее нельзя добавлять новые зависимости или разрешения безопасности.
        // В .NET номер версии состоит из четырех частей: основного (major) и дополнительного (minor) номеров версии, номера построения (build) и номера редакции (revision).
        // Я описал то, как вам следует относиться к номерам версий. К сожалению, CLR не работает с номерами версий по этим правилам. Если сборка зависит от версии 1.2.3.4 другой сборки, CLR будет пытаться загрузить только версию 1.2.3.4 (если только не задействовать механизм перенаправления связывания).
        // Проблемы управления версиями возникают, когда тип, определенный в одном компоненте (сборке), используется в качестве базового класса для типа другого компонента (сборки). Ясно, что изменения в базовом классе могут повлиять на поведение производного класса. Эти проблемы особенно характерны для полиморфизма, когда в производном типе переопределяются виртуальные методы базового типа.
        // В C# для типов и/или их членов есть пять ключевых слов, влияющих на управление версиями, причем они напрямую связаны с соответствующими возможностями CLR.

        // Ключевые слова C# и их влияние на управление версиями компонентов
        // Ключевое слово C# - Тип - Метод/Свойство/Событие - Константа/Поле
        // abstract - Экземпляры такого типа создавать нельзя - Член необходимо переопределить и реализовать в производном типе — только после этого можно создавать экземпляры производного типа - (запрещено)
        // virtual - (запрещено) - Член может переопределяться в производном типе - (запрещено)
        // override - (запрещено) - Член переопределяется в производном типе - (запрещено)
        // sealed - Тип нельзя использовать в качестве базового при наследовании - Член нельзя переопределить в производном типе. Это ключевое слово может применяться только к методу, переопределяющему виртуальный метод - (запрещено)
        // new - Применительно к вложенному типу, методу, свойству, событию, константе или полю означает, что член никак не связан с похожим членом, который может существовать в базовом класс
        
        // Вызов виртуальных методов, свойств и событий в CLR
        // В этом разделе речь идет только о методах, но все сказанное относится и к виртуальным свойствам и событиям, поскольку они, как показано далее, на самом деле реализуются методами.
        // У типа может быть несколько методов с одним именем, но с разным числом параметров или разными возвращаемыми значениями. Можно также определить два метода с одним и тем же именем и параметрами, но с разными типами возвращаемого значения.
        // При компиляции этого кода компилятор помещает три записи в таблицу определений методов сборки. Каждая запись содержит флаги, указывающие, является ли метод экземплярным, виртуальным или статическим.
        // В CLR есть две инструкции для вызова метода:
        // - Инструкция call используется для вызова статических, экземплярных и виртуальных методов.Инструкция call часто служит для невиртуального вызова виртуального метода.
        // - Инструкция callvirt используется только для вызова экземплярных и виртуальных (но не статических) методов.
        // Внимание
        // Если метод определен как невиртуальный, не рекомендуется в дальнейшем делать его виртуальным. Причина в том, что некоторые компиляторы для вызова невиртуального метода используют инструкцию call вместо callvirt. Если метод сделать виртуальным и не перекомпилировать ссылающийся на него код, виртуальный метод будет вызван невиртуально, в результате приложение может повести себя непредсказуемо. Если код, содержащий вызов, написан на C#, все пройдет нормально, поскольку в C# все экземплярные методы вызываются с помощью инструкции callvirt. Но если код написан на другом языке, возможны проблемы.
        // Иногда компилятор вместо callvirt использует для вызова виртуального метода команду call. Такое поведение выглядит странно, но следующий пример показывает, почему это действительно бывает необходимо.
        // Компиляторы стремятся использовать команду call при вызове методов, определенных значимыми типами, поскольку они запечатаны.
        // Независимо от используемой для вызова экземплярного или виртуального метода инструкции — call или callvirt — эти методы всегда в первом параметре получают скрытый аргумент this, ссылающийся на объект, с которым производятся действия.
        // При проектировании типа следует стремиться свести к минимуму количество виртуальных методов.

        // Разумное использование видимости типов и модификаторов доступа к членам
        // Есть три веские причины в пользу использования запечатанных классов.
        // - Управление версиями. Если класс изначально запечатан, его впоследствии можно сделать незапечатанным, не нарушая совместимости.
        // - Производительность. Как уже отмечалось, невиртуальные методы вызываются быстрее виртуальных, поскольку для последних CLR во время выполнения проверяет тип объекта, чтобы выяснить, где находится метод. Однако, встретив вызов виртуального метода в запечатанном типе, JIT-компилятор может сгенерировать более эффективный код, задействовав невиртуальный вызов.
        // - Безопасность и предсказуемость. Состояние класса должно быть надежно защищено. Если класс не запечатан, производный класс может изменить его состояние, воспользовавшись незащищенными полями или методами базового класса, изменяющими его доступные незакрытые поля.
        // Вот несколько правил, которым я следую при проектировании классов:
        // - Если класс не предназначен для наследования, я всегда явно объявляю его запечатанным.
        // - Все поля данных класса всегда объявляются закрытыми, и в этом я никогда не уступлю.
        // - Методы, свойства и события класса я всегда объявляю закрытыми и невиртуальными.
        // - В ООП есть проверенный временем принцип: «лучший метод борьбы со сложностью — добавление новых типов».
        // рекомендующее определять общедоступные вложенные типы в области видимости файла или сборки.

        // Работа с виртуальными методами при управлении версиями типов
        // В частности, следует быть очень осторожными при добавлении и изменении членов базового типа.
        // Если бы компилятор по умолчанию считал методы переопределениями (как С++), разработчики типа BetterPhone не смогли бы использовать в нем имена методов Dial и EstablishConnection. 


        // !!!
    }
}
