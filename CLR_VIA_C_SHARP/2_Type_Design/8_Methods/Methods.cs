using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._8_Methods
{
    class Methods
    {
        public static void main()
        {
            test_rational();
            test_extension();
        }

        private static void test_rational()
        {
            Rational r1 = 5; // Неявное приведение Int32 к Rational
            Rational r2 = 2.5F; // Неявное приведение Single к Rational
            Int32 x = (Int32)r1; // Явное приведение Rational к Int32
            Single s = (Single)r2; // Явное приведение Rational к Single
        }

        private static void test_extension()
        {
            // Инициализирующая строка
            StringBuilder sb = new StringBuilder("Hello. My name is Jeff.");
            // Замена точки восклицательным знаком
            // и получение номера символа в первом предложении (5)
            // Int32 index = StringBuilderExtensions.IndexOf(sb.Replace('.', '!'), '!');

            // Замена точки восклицательным знаком
            // и получение номера символа в первом предложении (5)
            Int32 index = sb.Replace('.', '!').IndexOf('!');
        }
    }

    public class SomeType { }
    // эквивалентно
    public class SomeType1
    {
        public SomeType1() : base() { }
    }

    internal sealed class SomeType2
    {
        private Int32 m_x = 5;
    }

    internal sealed class SomeType3
    {
        // Здесь нет кода, явно инициализирующего поля
        private Int32 m_x;
        private String m_s;
        private Double m_d;
        private Byte m_b;
        // Код этого конструктора инициализирует поля значениями по умолчанию
        // Этот конструктор должен вызываться всеми остальными конструкторами
        public SomeType3()
        {
            m_x = 5;
            m_s = "Hi there";
            m_d = 3.14159;
            m_b = 0xff;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значение m_x
        public SomeType3(Int32 x)
            : this()
        {
            m_x = x;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значение m_s
        public SomeType3(String s)
            : this()
        {
            m_s = s;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значения m_x и m_s
        public SomeType3(Int32 x, String s)
            : this()
        {
            m_x = x;
            m_s = s;
        }
    }

    internal struct Point
    {
        public Int32 m_x, m_y;
    }

    internal sealed class Rectangle
    {
        public Point m_topLeft, m_bottomRight;
    }

    internal struct Point1
    {
        public Int32 m_x, m_y;
        public Point1(Int32 x, Int32 y)
        {
            m_x = x;
            m_y = y;
        }

        // что будет в резуьтате если будет такой конструктор?
        // код не скомпилируеться
        //public Point1()
        //{
        //    m_x = m_y = 5;
        //}
    }

    internal sealed class Rectangle1
    {
        public Point1 m_topLeft, m_bottomRight;
        public Rectangle1()
        {
            // В C# оператор new, использованный для создания экземпляра значимого
            // типа, вызывает конструктор для инициализации полей значимого типа
            m_topLeft = new Point1(1, 2);
            m_bottomRight = new Point1(100, 200);
        }
    }

    internal struct SomeValType
    {
        // В значимый тип нельзя подставлять инициализацию экземплярных полей
        // не компилируеться
        // private Int32 m_x = 5;
    }

    internal struct SomeValType1
    {
        private Int32 m_x, m_y;
        // C# допускает наличие у значимых типов конструкторов с параметрами
        public SomeValType1(Int32 x)
        {
            m_x = x;
            m_y = x;
            // Обратите внимание: поле m_y здесь не инициализируется
        }
    }

    internal struct SomeValType2
    {
        private Int32 m_x, m_y;
        // C# позволяет значимым типам иметь конструкторы с параметрами
        public SomeValType2(Int32 x)
        {
            // Выглядит необычно, но компилируется прекрасно,
            // и все поля инициализируются значениями 0 или null
            this = new SomeValType2();
            m_x = x; // Присваивает m_x значение x
            // Обратите внимание, что поле m_y было инициализировано нулем
        }
    }

    internal sealed class SomeRefType3
    {
        static SomeRefType3()
        {
            // Исполняется при первом обращении к ссылочному типу SomeRefType
        }
    }

    internal struct SomeValType3
    {
        // C# на самом деле допускает определять для значимых типов
        // конструкторы без параметров
        static SomeValType3()
        {
            // Исполняется при первом обращении к значимому типу SomeValType
        }
    }

    internal struct SomeValType4
    {
        static SomeValType4()
        {
            Console.WriteLine("This never gets displayed");
        }
        public Int32 m_x;
    }

    internal sealed class SomeType4
    {
        private static Int32 s_x = 5;
    }

    // Эквивалентно
    internal sealed class SomeType5
    {
        private static Int32 s_x;
        static SomeType5() { s_x = 5; }
    }

    internal sealed class SomeType6
    {
        private static Int32 s_x = 5;
        static SomeType6()
        {
            s_x = 10;
        }
    }

    public sealed class Complex
    {
        public static Complex operator +(Complex c1, Complex c2) { return new Complex(); }
        public static Complex Add(Complex c1, Complex c2) { return (c1 + c2); }
    }

    public sealed class Rational
    {
        // Создает Rational из Int32
        public Rational(Int32 num) {  }
        // Создает Rational из Single
        public Rational(Single num) {  }
        // Преобразует Rational в Int32
        public Int32 ToInt32() { return 5; }
        // Преобразует Rational в Single
        public Single ToSingle() { return 5; }

        // Неявно создает Rational из Int32 и возвращает полученный объект
        public static implicit operator Rational(Int32 num)
        {
            return new Rational(num);
        }
        // Неявно создает Rational из Single и возвращает полученный объект
        public static implicit operator Rational(Single num)
        {
            return new Rational(num);
        }
        // Явно возвращает объект типа Int32, полученный из Rational
        public static explicit operator Int32(Rational r)
        {
            return r.ToInt32();
        }
        // Явно возвращает объект типа Single, полученный из Rational
        public static explicit operator Single(Rational r)
        {
            return r.ToSingle();
        }
    }

    public static class StringBuilderExtensions
    {
        public static Int32 IndexOf(this StringBuilder sb, Char value)
        {
            for (Int32 index = 0; index < sb.Length; index++)
                if (sb[index] == value) return index;
            return -1;
        }
    }

    // Конструкторы экземпляров и классы (ссылочные типы)
    // Конструкторы — это специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений, входящих в метаданные, методы-конструкторы всегда отмечают сочетанием .ctor.
    // При создании экземпляра объекта ссылочного типа выделяется память для полей данных экземпляра и инициализируются служебные поля (указатель на объект-тип и индекс блока синхронизации), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.
    // При конструировании объекта ссылочного типа выделяемая для него память всегда обнуляется до вызова конструктора экземпляра типа. Любые поля, не задаваемые конструктором явно, гарантированно содержат 0 или null.
    // В отличие от других методов конструкторы экземпляров не наследуются. Иначе говоря, у класса есть только те конструкторы экземпляров, которые определены в этом классе. Невозможность наследования означает, что к конструктору экземпляров нельзя применять модификаторы virtual, new, override, sealed и abstract.
    // Если определить класс без явно заданных конструкторов, многие компиляторы (в том числе компилятор C#) создадут конструктор по умолчанию (без параметров), реализация которого просто вызывает конструктор без параметров базового класса.
    // Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой (public). Если в базовом классе нет конструктора без параметров, производный класс должен явно вызвать конструктор базового класса, иначе компилятор вернет ошибку. Для статических классов (запечатанных и абстрактных) компилятор не создает конструктор по умолчанию.
    // В случае верифицируемого кода конструктор экземпляров должен вызывать конструктор базового класса до обращения к какому-либо из унаследованных от него полей.
    // Многие компиляторы, включая C#, генерируют вызов конструктора базового класса автоматически, поэтому вам, как правило, об этом можно не беспокоиться. В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров. Этот конструктор ничего не делает — просто возвращает управление по той простой причине, что в System.Object не определено никаких экземплярных полей данных, поэтому конструктору просто нечего делать. 
    // В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта. Кроме того, конструктор обычно не вызывается при десериализации объекта. Код десериализации выделяет память для объекта без вызова конструктора, используя метод GetUninitializedObject или GetSafeUninitializedObject типа System.Runtime.Serialization.FormatterServices.
    // Внимание
    // Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный метод переопределен в типе, экземпляр которого создается, происходит реализация производного типа, но к этому моменту еще не завершилась инициализация всех полей в иерархии. В таких обстоятельствах последствия вызова виртуального метода непредсказуемы.
    // Примечание
    // Компилятор инициализирует все поля при помощи соответствующего синтаксиса перед вызовом конструктора базового класса для поддержания представления о том, что все поля имеют корректные значения, обозначенные в исходном коде. Потенциальная проблема может возникнуть в тех случаях, когда конструктор базового класса вызывает виртуальный метод, осуществляющий обратный вызов в метод, определенный в производном классе. В этом случае поля инициализируются при помощи соответствующего синтаксиса перед вызовом виртуального метода. 
    // Поскольку в показанном ранее классе определены три конструктора, компилятор трижды генерирует код, инициализирующий поля m_x, m_s и m_d: по одному разу для каждого из конструкторов. Если имеется несколько инициализируемых экземплярных полей и множество перегруженных методов-конструкторов, стоит подумать о том, чтобы определить поля без инициализации; создать единственный конструктор, выполняющий общую инициализацию, и заставить каждый методконструктор явно вызывать конструктор, выполняющий общую инициализацию.
    // Следующий пример иллюстрирует использование способности C# явно заставлять один конструктор вызывать другой конструктор посредством зарезервированного слова this.

    // Конструкторы экземпляров и структуры (значимые типы)
    // Конструкторы значимых типов (struct) работают иначе, чем ссылочных (class). CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому, по большому счету, конструкторы у значимого типа можно не определять. Фактически многие компиляторы (включая C#) не определяют для значимых типов конструкторы по умолчанию, не имеющие параметров.
    // Из соображений повышения производительности CLR не пытается вызвать конструктор для каждого экземпляра значимого типа, содержащегося в объекте ссылочного типа. Однако, как отмечалось ранее, поля значимого типа инициализируются нулями/null.
    // Вообще говоря, CLR позволяет программистам определять конструкторы для значимых типов, но эти конструкторы выполняются лишь при наличии кода, явно вызывающего один из них, например, как в конструкторе объекта Rectangle
    // Многие разработчики (особенно с опытом программирования на С++) решат, что компилятор C# поместит в конструктор Rectangle код, автоматически вызывающий конструктор структуры Point по умолчанию, не имеющий параметров, для двух полей Rectangle. Однако, чтобы повысить быстродействие приложения во время выполнения, компилятор C# не сгенерирует такой код автоматически. Фактически большинство компиляторов никогда не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров. Чтобы принудительно исполнить конструктор значимого типа без параметров, разработчик должен добавить код его явного вызова. 
    // С учетом сказанного можно ожидать, что поля m_x и m_y обеих структур Point из объекта Rectangle в показанном коде будут инициализированы нулевыми значениями, так как в этой программе нет явного вызова конструктора Point.
    // Примечание
    // В поля значимого типа обязательно заносятся значения 0 или null, если значимый тип вложен в объект ссылочного типа. Однако гарантии, что поля значимых типов, работающие со стеком, будут инициализированы значениями 0 или null, нет. Чтобы код был верифицируемым, перед чтением любого поля значимого типа, работающего со стеком, нужно записать в него значение. Если код сможет прочитать значение поля значимого типа до того, как туда будет записано какое-то значение, может нарушиться безопасность. C# и другие компиляторы, генерирующие верифицируемый код, гарантируют, что поля любых значимых типов, работающие со стеком, перед чтением обнуляются или хотя бы в них записываются некоторые значения. Поэтому при верификации во время выполнения исключение выдано не будет. Однако обычно можно предполагать, что поля значимых типов инициализируются нулевыми значениями, а все сказанное в этом примечании можно полностью игнорировать.
    // нельзя создавать инициализаторы экземплярных полей в структурах
    // Кроме того, поскольку верифицируемый код перед чтением любого поля значимого типа требует записывать в него какое-либо значение, любой конструктор, определенный для значимого типа, должен инициализировать все поля этого типа. Следующий тип определяет конструктор для значимого типа, но не может инициализировать все его поля:
    // В конструкторе значимого типа this представляет экземпляр значимого типа и ему можно приписать значение нового экземпляра значимого типа, у которого все поля инициализированы нулями. В конструкторах ссылочного типа указатель this считается доступным только для чтения и присваивать ему значение нельзя.

    // Конструкторы типов
    // Помимо конструкторов экземпляров, CLR поддерживает конструкторы типов (также известные как статические конструкторы, конструкторы классов и инициализаторы типов).
    // Обратите внимание, что конструкторы типов определяют так же, как конструкторы экземпляров без параметров за исключением того, что их помечают как статические. Кроме того, конструкторы типов всегда должны быть закрытыми (C# делает их закрытыми автоматически).
    // Конструкторы типов всегда должны быть закрытыми, чтобы код разработчика не смог их вызвать, напротив, в то же время среда CLR всегда способна вызвать конструктор типа.
    // Внимание
    // Хотя конструктор типа можно определить в значимом типе, этого никогда не следует делать, так как иногда CLR не вызывает статический конструктор значимого типа.
    // У вызова конструктора типа есть некоторые особенности. При компиляции метода JIT-компилятор обнаруживает типы, на которые есть ссылки из кода. Если в каком-либо из типов определен конструктор, JIT-компилятор проверяет был ли исполнен конструктор типа в данном домене приложений. Если нет, JITкомпилятор создает в IL-коде вызов конструктора типа. Если же код уже исполнялся, JIT-компилятор вызова конструктора типа не создает, так как «знает», что тип уже инициализирован. был ли исполнен конструктор типа в данном домене приложений.
    // Примечание
    // Поскольку CLR гарантирует, что конструктор типа выполняется только однажды в каждом домене приложений, а также обеспечивает его безопасность по отношению к потокам, конструктор типа лучше всего подходит для инициализации всех объектов-одиночек (singleton), необходимых для существования типа.
    // В рамках одного потока возможна неприятная ситуация, когда существует два конструктора типа, содержащих перекрестно ссылающийся код. Например, конструктор типа ClassA содержит код, ссылающийся на ClassB, а последний содержит конструктор типа, ссылающийся на ClassA. Даже в таких условиях CLR заботится, чтобы код конструкторов типов выполнился лишь однажды, но исполняющая среда не в состоянии обеспечить завершение исполнения конструктора типа ClassA до начала исполнения конструктора типа ClassB. При написании кода следует избегать подобных ситуаций.
    // Наконец, если конструктор типа генерирует необрабатываемое исключение, CLR считает такой тип непригодным. При попытке обращения к любому полю или методу такого типа возникает исключение System.TypeInitializationException.
    // Код конструктора типа может обращаться только к статическим полям типа; обычно это делается, чтобы их инициализировать. Как и в случае экземплярных полей, C# предлагает простой синтаксис:
    // C# не позволяет в значимых типах использовать синтаксис инициализации полей на месте, но разрешает это в статических полях. Иначе говоря, если в приведенном ранее коде заменить class на struct, код откомпилируется и будет работать, как задумано.
    // Конструктор типа не должен вызывать конструктор базового класса. Этот вызов не обязателен, так как ни одно статическое поле типа не используется совместно с базовым типом и не наследуется от него.
    // ПримечАние
    // В ряде языков, таких как Java, предполагается, что при обращении к типу будет вызван его конструктор, а также конструкторы всех его базовых типов. Кроме того, интерфейсы, реализованные этими типами, тоже должны вызывать свои конструкторы. CLR не поддерживает такую семантику, но позволяет компиляторам и разработчикам предоставлять поддержку подобной семантики через метод RunClassConstructor, предоставляемый типом System.Runtime.CompilerServices.RuntimeHelpers. Компилятор любого языка, требующего подобную семантику, генерирует в конструкторе типа код, вызывающий этот метод для всех базовых типов. При использовании метода RunClassConstructor для вызова конструктора типа CLR определяет, был ли он исполнен ранее, и если да, то не вызывает его снова.
    // Здесь компилятор C# генерирует единственный метод-конструктор типа, который сначала инициализирует поле s_x значением 5, затем — значением 10. Иначе говоря, при генерации IL-кода конструктора типа компилятор C# сначала генерирует код, инициализирующий статические поля, затем обрабатывает явный код, содержащийся внутри метода-конструктора типа.
    // Внимание
    // Иногда разработчики спрашивают меня: можно ли исполнить код во время выгрузки типа? Во-первых, следует знать, что типы выгружаются только при закрытии домена приложений. Когда домен приложений закрывается, объект, идентифицирующий тип, становится недоступным, и уборщик мусора освобождает занятую им память. Многим разработчикам такой сценарий дает основание полагать, что можно добавить к типу статический метод Finalize, автоматически вызываемый при выгрузке типа. Увы, CLR не поддерживает статические методы Finalize. Однако не все потеряно: если при закрытии домена приложений нужно исполнить некоторый код, можно зарегистрировать метод обратного вызова для события DomainUnload типа System.AppDomain.
    
    // Методы перегруженных операторов
    // С точки зрения CLR перегруженные операторы представляют собой просто методы.
    // Спецификация CLR требует, чтобы перегруженные операторные методы были открытыми и статическими. Дополнительно C# (и многие другие языки) требует, чтобы у операторного метода тип, по крайней мере, одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод.
    // Унарные операторы С# и CLS-совместимые имена соответствующих методов
    // Оператор C# - Имя специального метода - Рекомендуемое CLS-совместимое имя метода
    // + op_UnaryPlus Plus
    // - op_UnaryNegation Negate
    // ! op_LogicalNot Not
    // ~ op_OnesComplement OnesComplement
    // ++ op_Increment Increment
    // -- op_Decrement Decrement
    // Нет op_True IsTrue { get; }
    // Нет op_False IsFalse { get; }
    // Бинарные операторы и их CLS-совместимые имена методов
    // Оператор C# - Имя специального метода - Рекомендуемое CLS-совместимое имя метода
    // + op_Addition Add
    // - op_Subtraction Subtract
    // * op_Multiply Multiply
    // / op_Division Divide
    // % op_Modulus Mod
    // & op_BitwiseAnd BitwiseAnd
    // | op_BitwiseOr BitwiseOr
    // ^ op_ExclusiveOr Xor
    // << op_LeftShift LeftShift
    // >> op_RightShift RightShift
    // == op_Equality Equals
    // != op_Inequality Equals
    // < op_LessThan Compare
    // > op_GreaterThan Compare
    // <= op_LessThanOrEqual Compare
    // >= op_GreaterThanOrEqual Compare
    // ПримечАние
    // Если изучить фундаментальные типы библиотеки классов . NET Framework (FCL) — Int32, Int64, UInt32 и т. д., — можно заметить, что они не определяют методы пере- груженных операторов. Дело в том, что компиляторы целенаправленно ищут операции с этими примитивными типами и генерируют IL-команды, манипулирующие экземплярами этих типов. Если бы эти типы поддерживали соответствующие методы, а компиляторы генерировали вызывающий их код, то каждый такой вызов снижал бы быстродействие во время выполнения. Кроме того, чтобы реализовать ожидаемое действие, такой метод в конечном итоге все равно исполнял бы те же инструкции языка IL. Для вас это означает следующее: если язык, на котором вы пишете, не поддерживает какой-либо из фундаментальных типов FCL, вы не сможете выполнять действия над экземплярами этого типа. 
    
    // Операторы и взаимодействие языков программирования
    // Особое мнение автора о правилах Microsoft, связанных с именами методов операторов
    // ПримечАние
    // Примером типа, в котором перегружаются операторы и используются дружественные имена методов в соответствии с правилами Microsoft, может служить класс System.Decimal библиотеки FCL.

    // Методы операторов преобразования
    // Однако иногда требуется преобразовать объект одного типа в совершенно другой тип. Например, класс System.Xml.Linq.XElement позволяет преобразовать элемент XML в Boolean, (U)Int32, (U)Int64, Single, Double, Decimal, String, DateTime, DateTimeOffset, TimeSpan, Guid или эквивалент любого из этих типов, допускающий присваивание null (кроме String).
    // Также можно представить, что в FCL есть тип данных Rational, в который удобно преобразовывать объекты типа Int32 или Single. Более того, было бы полезно иметь возможность выполнить обратное преобразование объекта Rational в Int32 или Single.
    // Некоторые (например, C#) наряду с этим поддерживают перегрузку операторов преобразования — методы, преобразующие объекты одного типа в объекты другого типа.
    // Ключевое слово implicit указывает компилятору C#, что наличие в исходном тексте явного приведения типов не обязательно для генерации кода, вызывающего метод оператора преобразования. Ключевое слово explicit позволяет компилятору вызывать метод только тогда, когда в исходном тексте происходит явное приведение типов.
    // ПримечАние
    // Два метода с именем op_Explicit принимают одинаковый параметр — объект типа Rational. Но эти методы возвращают значения разных типов: Int32 и Single соответственно. Это пример пары методов, отличающихся лишь типом возвращаемого значения. CLR в полном объеме поддерживает возможность определения нескольких методов, отличающихся только типами возвращаемых значений. Однако эта возможность используется лишь очень немногими языками. Как вы, вероятно, знаете, C++, C#, Visual Basic и Java не позволяют определять методы, различающиеся только типом возвращаемого значения. Лишь несколько языков (например, IL) позволяют разработчику явно выбирать, какой метод вызвать. Конечно, IL-программистам не следует использовать эту возможность, так как определенные таким образом методы будут недоступны для вызова из программ, написанных на других языках программирования. И хотя C# не предоставляет эту возможность программисту, внутренние механизмы компилятора все равно используют ее, если в типе определены методы операторов преобразования.
    // ПримечАние
    // С# генерирует код вызова операторов неявного преобразования в случае, когда используется выражение приведения типов. Однако операторы неявного преобразования никогда не вызываются, если используется оператор as или is.
    // System.Decimal - для того, чтобы разобраться

    // Методы расширения
    // А сейчас я попробую объяснить, что именно делают методы расширения. Они позволяют вам определить статический метод, который вызывается посредством синтаксиса экземплярного метода. Иначе говоря, мы можем определить собственный метод IndexOf — и три проблемы, упомянутые выше, исчезнут. Для того чтобы превратить метод IndexOf в метод расширения, мы просто добавим ключевое слово this перед первым аргументом: 
    // Компилятор увидит следующий код:
    // Int32 index = sb.IndexOf('X'); // c 235



    // !!!


}
