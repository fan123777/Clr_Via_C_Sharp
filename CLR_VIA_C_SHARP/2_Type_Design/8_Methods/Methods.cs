using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._8_Methods
{
    class Methods
    {
        public static void main()
        {
            test_rational();
            test_extension();
            test_extension1();
            test_partial_methods();
            Testing testing = new Testing();
            testing.main();
        }

        private static void test_rational()
        {
            Rational r1 = 5; // Неявное приведение Int32 к Rational
            Rational r2 = 2.5F; // Неявное приведение Single к Rational
            Int32 x = (Int32)r1; // Явное приведение Rational к Int32
            Single s = (Single)r2; // Явное приведение Rational к Single
        }

        private static void test_extension()
        {
            // Инициализирующая строка
            StringBuilder sb = new StringBuilder("Hello. My name is Jeff.");
            // Замена точки восклицательным знаком
            // и получение номера символа в первом предложении (5)
            // Int32 index = StringBuilderExtensions.IndexOf(sb.Replace('.', '!'), '!');

            // Замена точки восклицательным знаком
            // и получение номера символа в первом предложении (5)
            Int32 index = sb.Replace('.', '!').IndexOf('!');

        }

        private static void test_extension1()
        {
            // sb равно null
            StringBuilder sb = null;

            // Вызов метода выражения: исключение NullReferenceException НЕ БУДЕТ
            // выдано при вызове IndexOf
            // Исключение NullReferenceException будет вброшено внутри цикла IndexOf
            // sb.IndexOf('X');

            // Вызов экземплярного метода: исключение NullReferenceException БУДЕТ
            // вброшено при вызове Replace
            //sb.Replace('.', '!');

            // Показывает каждый символ в каждой строке консоли
            "Grant".ShowItems();

            // Показывает каждую строку в каждой строке консоли
            new[] { "Jeff", "Kristin" }.ShowItems();

            // Показывает каждый Int32 в каждой строчке консоли.
            new List<Int32>() { 1, 2, 3 }.ShowItems();

            Action<Object> action = o => Console.WriteLine(o.GetType());
            // Выдает NullReferenceException
            action.InvokeAndCatch<NullReferenceException>(null);
            // Поглощает NullReferenceException

            // Cоздание делегата Action, ссылающегося на статический метод расширения
            // ShowItems; первый аргумент инициализируется ссылкой на строку "Jeff"
            Action a = "Jeff".ShowItems;

            // Вызов делегата, вызывающего ShowItems и передающего
            // ссылку на строку "Jeff"
            a();
        }

        private static void test_partial_methods()
        {

        }
    }

    public class SomeType { }
    // эквивалентно
    public class SomeType1
    {
        public SomeType1() : base() { }
    }

    internal sealed class SomeType2
    {
        private Int32 m_x = 5;
    }

    internal sealed class SomeType3
    {
        // Здесь нет кода, явно инициализирующего поля
        private Int32 m_x;
        private String m_s;
        private Double m_d;
        private Byte m_b;
        // Код этого конструктора инициализирует поля значениями по умолчанию
        // Этот конструктор должен вызываться всеми остальными конструкторами
        public SomeType3()
        {
            m_x = 5;
            m_s = "Hi there";
            m_d = 3.14159;
            m_b = 0xff;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значение m_x
        public SomeType3(Int32 x)
            : this()
        {
            m_x = x;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значение m_s
        public SomeType3(String s)
            : this()
        {
            m_s = s;
        }
        // Этот конструктор инициализирует поля значениями по умолчанию,
        // а затем изменяет значения m_x и m_s
        public SomeType3(Int32 x, String s)
            : this()
        {
            m_x = x;
            m_s = s;
        }
    }

    internal struct Point
    {
        public Int32 m_x, m_y;
    }

    internal sealed class Rectangle
    {
        public Point m_topLeft, m_bottomRight;
    }

    internal struct Point1
    {
        public Int32 m_x, m_y;
        public Point1(Int32 x, Int32 y)
        {
            m_x = x;
            m_y = y;
        }

        // что будет в резуьтате если будет такой конструктор?
        // код не скомпилируеться
        //public Point1()
        //{
        //    m_x = m_y = 5;
        //}
    }

    internal sealed class Rectangle1
    {
        public Point1 m_topLeft, m_bottomRight;
        public Rectangle1()
        {
            // В C# оператор new, использованный для создания экземпляра значимого
            // типа, вызывает конструктор для инициализации полей значимого типа
            m_topLeft = new Point1(1, 2);
            m_bottomRight = new Point1(100, 200);
        }
    }

    internal struct SomeValType
    {
        // В значимый тип нельзя подставлять инициализацию экземплярных полей
        // не компилируеться
        // private Int32 m_x = 5;
    }

    internal struct SomeValType1
    {
        private Int32 m_x, m_y;
        // C# допускает наличие у значимых типов конструкторов с параметрами
        public SomeValType1(Int32 x)
        {
            m_x = x;
            m_y = x;
            // Обратите внимание: поле m_y здесь не инициализируется
        }
    }

    internal struct SomeValType2
    {
        private Int32 m_x, m_y;
        // C# позволяет значимым типам иметь конструкторы с параметрами
        public SomeValType2(Int32 x)
        {
            // Выглядит необычно, но компилируется прекрасно,
            // и все поля инициализируются значениями 0 или null
            this = new SomeValType2();
            m_x = x; // Присваивает m_x значение x
            // Обратите внимание, что поле m_y было инициализировано нулем
        }
    }

    internal sealed class SomeRefType3
    {
        static SomeRefType3()
        {
            // Исполняется при первом обращении к ссылочному типу SomeRefType
        }
    }

    internal struct SomeValType3
    {
        // C# на самом деле допускает определять для значимых типов
        // конструкторы без параметров
        static SomeValType3()
        {
            // Исполняется при первом обращении к значимому типу SomeValType
        }
    }

    internal struct SomeValType4
    {
        static SomeValType4()
        {
            Console.WriteLine("This never gets displayed");
        }
        public Int32 m_x;
    }

    internal sealed class SomeType4
    {
        private static Int32 s_x = 5;
    }

    // Эквивалентно
    internal sealed class SomeType5
    {
        private static Int32 s_x;
        static SomeType5() { s_x = 5; }
    }

    internal sealed class SomeType6
    {
        private static Int32 s_x = 5;
        static SomeType6()
        {
            s_x = 10;
        }
    }

    public sealed class Complex
    {
        public static Complex operator +(Complex c1, Complex c2) { return new Complex(); }
        public static Complex Add(Complex c1, Complex c2) { return (c1 + c2); }
    }

    public sealed class Rational
    {
        // Создает Rational из Int32
        public Rational(Int32 num) {  }
        // Создает Rational из Single
        public Rational(Single num) {  }
        // Преобразует Rational в Int32
        public Int32 ToInt32() { return 5; }
        // Преобразует Rational в Single
        public Single ToSingle() { return 5; }

        // Неявно создает Rational из Int32 и возвращает полученный объект
        public static implicit operator Rational(Int32 num)
        {
            return new Rational(num);
        }
        // Неявно создает Rational из Single и возвращает полученный объект
        public static implicit operator Rational(Single num)
        {
            return new Rational(num);
        }
        // Явно возвращает объект типа Int32, полученный из Rational
        public static explicit operator Int32(Rational r)
        {
            return r.ToInt32();
        }
        // Явно возвращает объект типа Single, полученный из Rational
        public static explicit operator Single(Rational r)
        {
            return r.ToSingle();
        }
    }

    public static class StringBuilderExtensions
    {
        public static Int32 IndexOf(this StringBuilder sb, Char value)
        {
            for (Int32 index = 0; index < sb.Length; index++)
                if (sb[index] == value) return index;
            return -1;
        }

        public static void ShowItems<T>(this IEnumerable<T> collection)
        {
            foreach (var item in collection)
                Console.WriteLine(item);
        }

        public static void InvokeAndCatch<TException>(this Action<Object> d, Object o)
        where TException : Exception
        {
            try { d(o); }
            catch (TException) { }
        }
    }

    namespace partial_method
    {
        // Сгенерированный код в некотором файле с исходным кодом:
        internal class Base
        {
            private String m_name;
            // Вызывается перед изменением поля m_name
            protected virtual void OnNameChanging(String value)
            {
            }
            public String Name
            {
                get { return m_name; }
                set
                {
                    // Информирует класс о возможных изменениях
                    OnNameChanging(value.ToUpper());
                    m_name = value; // Изменение поля
                }
            }
        }

        // Написанный программистом код из другого файла
        internal class Derived : Base
        {
            protected override void OnNameChanging(string value)
            {
                if (String.IsNullOrEmpty(value))
                    throw new ArgumentNullException("value");
            }
        }
    }

    namespace partial_method_1
    {
        // Сгенерированный при помощи инструмента программный код
        internal sealed partial class Base
        {
            private String m_name;
            // Это объявление с определением частичного метода вызывается
            // перед изменением поля m_name
            partial void OnNameChanging(String value);
            public String Name
            {
                get { return m_name; }
                set
                {
                    // Информирование класса о потенциальном изменении
                    OnNameChanging(value.ToUpper());
                    m_name = value; // Изменение поля
                }
            }
        }
        // Написанный программистом код, содержащийся в другом файле
        internal sealed partial class Base
        {
            // Это объявление с реализацией частичного метода вызывается перед тем,
            // как будет изменено поле m_name
            partial void OnNameChanging(String value)
            {
                if (String.IsNullOrEmpty(value))
                    throw new ArgumentNullException("value");
            }
        }
    }

    // Конструкторы экземпляров и классы (ссылочные типы)
    // Конструкторы — это специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений, входящих в метаданные, методы-конструкторы всегда отмечают сочетанием .ctor.
    // При создании экземпляра объекта ссылочного типа выделяется память для полей данных экземпляра и инициализируются служебные поля (указатель на объект-тип и индекс блока синхронизации), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.
    // При конструировании объекта ссылочного типа выделяемая для него память всегда обнуляется до вызова конструктора экземпляра типа. Любые поля, не задаваемые конструктором явно, гарантированно содержат 0 или null.
    // В отличие от других методов конструкторы экземпляров не наследуются. Иначе говоря, у класса есть только те конструкторы экземпляров, которые определены в этом классе. Невозможность наследования означает, что к конструктору экземпляров нельзя применять модификаторы virtual, new, override, sealed и abstract.
    // Если определить класс без явно заданных конструкторов, многие компиляторы (в том числе компилятор C#) создадут конструктор по умолчанию (без параметров), реализация которого просто вызывает конструктор без параметров базового класса.
    // Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой (public). Если в базовом классе нет конструктора без параметров, производный класс должен явно вызвать конструктор базового класса, иначе компилятор вернет ошибку. Для статических классов (запечатанных и абстрактных) компилятор не создает конструктор по умолчанию.
    // В случае верифицируемого кода конструктор экземпляров должен вызывать конструктор базового класса до обращения к какому-либо из унаследованных от него полей.
    // Многие компиляторы, включая C#, генерируют вызов конструктора базового класса автоматически, поэтому вам, как правило, об этом можно не беспокоиться. В конечном счете всегда вызывается открытый конструктор объекта System.Object без параметров. Этот конструктор ничего не делает — просто возвращает управление по той простой причине, что в System.Object не определено никаких экземплярных полей данных, поэтому конструктору просто нечего делать. 
    // В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта. Кроме того, конструктор обычно не вызывается при десериализации объекта. Код десериализации выделяет память для объекта без вызова конструктора, используя метод GetUninitializedObject или GetSafeUninitializedObject типа System.Runtime.Serialization.FormatterServices.
    // Внимание
    // Нельзя вызывать какие-либо виртуальные методы конструктора, которые могут повлиять на создаваемый объект. Причина проста: если вызываемый виртуальный метод переопределен в типе, экземпляр которого создается, происходит реализация производного типа, но к этому моменту еще не завершилась инициализация всех полей в иерархии. В таких обстоятельствах последствия вызова виртуального метода непредсказуемы.
    // Примечание
    // Компилятор инициализирует все поля при помощи соответствующего синтаксиса перед вызовом конструктора базового класса для поддержания представления о том, что все поля имеют корректные значения, обозначенные в исходном коде. Потенциальная проблема может возникнуть в тех случаях, когда конструктор базового класса вызывает виртуальный метод, осуществляющий обратный вызов в метод, определенный в производном классе. В этом случае поля инициализируются при помощи соответствующего синтаксиса перед вызовом виртуального метода. 
    // Поскольку в показанном ранее классе определены три конструктора, компилятор трижды генерирует код, инициализирующий поля m_x, m_s и m_d: по одному разу для каждого из конструкторов. Если имеется несколько инициализируемых экземплярных полей и множество перегруженных методов-конструкторов, стоит подумать о том, чтобы определить поля без инициализации; создать единственный конструктор, выполняющий общую инициализацию, и заставить каждый методконструктор явно вызывать конструктор, выполняющий общую инициализацию.
    // Следующий пример иллюстрирует использование способности C# явно заставлять один конструктор вызывать другой конструктор посредством зарезервированного слова this.

    // Конструкторы экземпляров и структуры (значимые типы)
    // Конструкторы значимых типов (struct) работают иначе, чем ссылочных (class). CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому, по большому счету, конструкторы у значимого типа можно не определять. Фактически многие компиляторы (включая C#) не определяют для значимых типов конструкторы по умолчанию, не имеющие параметров.
    // Из соображений повышения производительности CLR не пытается вызвать конструктор для каждого экземпляра значимого типа, содержащегося в объекте ссылочного типа. Однако, как отмечалось ранее, поля значимого типа инициализируются нулями/null.
    // Вообще говоря, CLR позволяет программистам определять конструкторы для значимых типов, но эти конструкторы выполняются лишь при наличии кода, явно вызывающего один из них, например, как в конструкторе объекта Rectangle
    // Многие разработчики (особенно с опытом программирования на С++) решат, что компилятор C# поместит в конструктор Rectangle код, автоматически вызывающий конструктор структуры Point по умолчанию, не имеющий параметров, для двух полей Rectangle. Однако, чтобы повысить быстродействие приложения во время выполнения, компилятор C# не сгенерирует такой код автоматически. Фактически большинство компиляторов никогда не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров. Чтобы принудительно исполнить конструктор значимого типа без параметров, разработчик должен добавить код его явного вызова. 
    // С учетом сказанного можно ожидать, что поля m_x и m_y обеих структур Point из объекта Rectangle в показанном коде будут инициализированы нулевыми значениями, так как в этой программе нет явного вызова конструктора Point.
    // Примечание
    // В поля значимого типа обязательно заносятся значения 0 или null, если значимый тип вложен в объект ссылочного типа. Однако гарантии, что поля значимых типов, работающие со стеком, будут инициализированы значениями 0 или null, нет. Чтобы код был верифицируемым, перед чтением любого поля значимого типа, работающего со стеком, нужно записать в него значение. Если код сможет прочитать значение поля значимого типа до того, как туда будет записано какое-то значение, может нарушиться безопасность. C# и другие компиляторы, генерирующие верифицируемый код, гарантируют, что поля любых значимых типов, работающие со стеком, перед чтением обнуляются или хотя бы в них записываются некоторые значения. Поэтому при верификации во время выполнения исключение выдано не будет. Однако обычно можно предполагать, что поля значимых типов инициализируются нулевыми значениями, а все сказанное в этом примечании можно полностью игнорировать.
    // нельзя создавать инициализаторы экземплярных полей в структурах
    // Кроме того, поскольку верифицируемый код перед чтением любого поля значимого типа требует записывать в него какое-либо значение, любой конструктор, определенный для значимого типа, должен инициализировать все поля этого типа. Следующий тип определяет конструктор для значимого типа, но не может инициализировать все его поля:
    // В конструкторе значимого типа this представляет экземпляр значимого типа и ему можно приписать значение нового экземпляра значимого типа, у которого все поля инициализированы нулями. В конструкторах ссылочного типа указатель this считается доступным только для чтения и присваивать ему значение нельзя.

    // Конструкторы типов
    // Помимо конструкторов экземпляров, CLR поддерживает конструкторы типов (также известные как статические конструкторы, конструкторы классов и инициализаторы типов).
    // Обратите внимание, что конструкторы типов определяют так же, как конструкторы экземпляров без параметров за исключением того, что их помечают как статические. Кроме того, конструкторы типов всегда должны быть закрытыми (C# делает их закрытыми автоматически).
    // Конструкторы типов всегда должны быть закрытыми, чтобы код разработчика не смог их вызвать, напротив, в то же время среда CLR всегда способна вызвать конструктор типа.
    // Внимание
    // Хотя конструктор типа можно определить в значимом типе, этого никогда не следует делать, так как иногда CLR не вызывает статический конструктор значимого типа.
    // У вызова конструктора типа есть некоторые особенности. При компиляции метода JIT-компилятор обнаруживает типы, на которые есть ссылки из кода. Если в каком-либо из типов определен конструктор, JIT-компилятор проверяет был ли исполнен конструктор типа в данном домене приложений. Если нет, JITкомпилятор создает в IL-коде вызов конструктора типа. Если же код уже исполнялся, JIT-компилятор вызова конструктора типа не создает, так как «знает», что тип уже инициализирован. был ли исполнен конструктор типа в данном домене приложений.
    // Примечание
    // Поскольку CLR гарантирует, что конструктор типа выполняется только однажды в каждом домене приложений, а также обеспечивает его безопасность по отношению к потокам, конструктор типа лучше всего подходит для инициализации всех объектов-одиночек (singleton), необходимых для существования типа.
    // В рамках одного потока возможна неприятная ситуация, когда существует два конструктора типа, содержащих перекрестно ссылающийся код. Например, конструктор типа ClassA содержит код, ссылающийся на ClassB, а последний содержит конструктор типа, ссылающийся на ClassA. Даже в таких условиях CLR заботится, чтобы код конструкторов типов выполнился лишь однажды, но исполняющая среда не в состоянии обеспечить завершение исполнения конструктора типа ClassA до начала исполнения конструктора типа ClassB. При написании кода следует избегать подобных ситуаций.
    // Наконец, если конструктор типа генерирует необрабатываемое исключение, CLR считает такой тип непригодным. При попытке обращения к любому полю или методу такого типа возникает исключение System.TypeInitializationException.
    // Код конструктора типа может обращаться только к статическим полям типа; обычно это делается, чтобы их инициализировать. Как и в случае экземплярных полей, C# предлагает простой синтаксис:
    // C# не позволяет в значимых типах использовать синтаксис инициализации полей на месте, но разрешает это в статических полях. Иначе говоря, если в приведенном ранее коде заменить class на struct, код откомпилируется и будет работать, как задумано.
    // Конструктор типа не должен вызывать конструктор базового класса. Этот вызов не обязателен, так как ни одно статическое поле типа не используется совместно с базовым типом и не наследуется от него.
    // ПримечАние
    // В ряде языков, таких как Java, предполагается, что при обращении к типу будет вызван его конструктор, а также конструкторы всех его базовых типов. Кроме того, интерфейсы, реализованные этими типами, тоже должны вызывать свои конструкторы. CLR не поддерживает такую семантику, но позволяет компиляторам и разработчикам предоставлять поддержку подобной семантики через метод RunClassConstructor, предоставляемый типом System.Runtime.CompilerServices.RuntimeHelpers. Компилятор любого языка, требующего подобную семантику, генерирует в конструкторе типа код, вызывающий этот метод для всех базовых типов. При использовании метода RunClassConstructor для вызова конструктора типа CLR определяет, был ли он исполнен ранее, и если да, то не вызывает его снова.
    // Здесь компилятор C# генерирует единственный метод-конструктор типа, который сначала инициализирует поле s_x значением 5, затем — значением 10. Иначе говоря, при генерации IL-кода конструктора типа компилятор C# сначала генерирует код, инициализирующий статические поля, затем обрабатывает явный код, содержащийся внутри метода-конструктора типа.
    // Внимание
    // Иногда разработчики спрашивают меня: можно ли исполнить код во время выгрузки типа? Во-первых, следует знать, что типы выгружаются только при закрытии домена приложений. Когда домен приложений закрывается, объект, идентифицирующий тип, становится недоступным, и уборщик мусора освобождает занятую им память. Многим разработчикам такой сценарий дает основание полагать, что можно добавить к типу статический метод Finalize, автоматически вызываемый при выгрузке типа. Увы, CLR не поддерживает статические методы Finalize. Однако не все потеряно: если при закрытии домена приложений нужно исполнить некоторый код, можно зарегистрировать метод обратного вызова для события DomainUnload типа System.AppDomain.
    
    // Методы перегруженных операторов
    // С точки зрения CLR перегруженные операторы представляют собой просто методы.
    // Спецификация CLR требует, чтобы перегруженные операторные методы были открытыми и статическими. Дополнительно C# (и многие другие языки) требует, чтобы у операторного метода тип, по крайней мере, одного из параметров или возвращаемого значения совпадал с типом, в котором определен операторный метод.
    // Унарные операторы С# и CLS-совместимые имена соответствующих методов
    // Оператор C# - Имя специального метода - Рекомендуемое CLS-совместимое имя метода
    // + op_UnaryPlus Plus
    // - op_UnaryNegation Negate
    // ! op_LogicalNot Not
    // ~ op_OnesComplement OnesComplement
    // ++ op_Increment Increment
    // -- op_Decrement Decrement
    // Нет op_True IsTrue { get; }
    // Нет op_False IsFalse { get; }
    // Бинарные операторы и их CLS-совместимые имена методов
    // Оператор C# - Имя специального метода - Рекомендуемое CLS-совместимое имя метода
    // + op_Addition Add
    // - op_Subtraction Subtract
    // * op_Multiply Multiply
    // / op_Division Divide
    // % op_Modulus Mod
    // & op_BitwiseAnd BitwiseAnd
    // | op_BitwiseOr BitwiseOr
    // ^ op_ExclusiveOr Xor
    // << op_LeftShift LeftShift
    // >> op_RightShift RightShift
    // == op_Equality Equals
    // != op_Inequality Equals
    // < op_LessThan Compare
    // > op_GreaterThan Compare
    // <= op_LessThanOrEqual Compare
    // >= op_GreaterThanOrEqual Compare
    // ПримечАние
    // Если изучить фундаментальные типы библиотеки классов . NET Framework (FCL) — Int32, Int64, UInt32 и т. д., — можно заметить, что они не определяют методы пере- груженных операторов. Дело в том, что компиляторы целенаправленно ищут операции с этими примитивными типами и генерируют IL-команды, манипулирующие экземплярами этих типов. Если бы эти типы поддерживали соответствующие методы, а компиляторы генерировали вызывающий их код, то каждый такой вызов снижал бы быстродействие во время выполнения. Кроме того, чтобы реализовать ожидаемое действие, такой метод в конечном итоге все равно исполнял бы те же инструкции языка IL. Для вас это означает следующее: если язык, на котором вы пишете, не поддерживает какой-либо из фундаментальных типов FCL, вы не сможете выполнять действия над экземплярами этого типа. 
    
    // Операторы и взаимодействие языков программирования
    // Особое мнение автора о правилах Microsoft, связанных с именами методов операторов
    // ПримечАние
    // Примером типа, в котором перегружаются операторы и используются дружественные имена методов в соответствии с правилами Microsoft, может служить класс System.Decimal библиотеки FCL.

    // Методы операторов преобразования
    // Однако иногда требуется преобразовать объект одного типа в совершенно другой тип. Например, класс System.Xml.Linq.XElement позволяет преобразовать элемент XML в Boolean, (U)Int32, (U)Int64, Single, Double, Decimal, String, DateTime, DateTimeOffset, TimeSpan, Guid или эквивалент любого из этих типов, допускающий присваивание null (кроме String).
    // Также можно представить, что в FCL есть тип данных Rational, в который удобно преобразовывать объекты типа Int32 или Single. Более того, было бы полезно иметь возможность выполнить обратное преобразование объекта Rational в Int32 или Single.
    // Некоторые (например, C#) наряду с этим поддерживают перегрузку операторов преобразования — методы, преобразующие объекты одного типа в объекты другого типа.
    // Ключевое слово implicit указывает компилятору C#, что наличие в исходном тексте явного приведения типов не обязательно для генерации кода, вызывающего метод оператора преобразования. Ключевое слово explicit позволяет компилятору вызывать метод только тогда, когда в исходном тексте происходит явное приведение типов.
    // ПримечАние
    // Два метода с именем op_Explicit принимают одинаковый параметр — объект типа Rational. Но эти методы возвращают значения разных типов: Int32 и Single соответственно. Это пример пары методов, отличающихся лишь типом возвращаемого значения. CLR в полном объеме поддерживает возможность определения нескольких методов, отличающихся только типами возвращаемых значений. Однако эта возможность используется лишь очень немногими языками. Как вы, вероятно, знаете, C++, C#, Visual Basic и Java не позволяют определять методы, различающиеся только типом возвращаемого значения. Лишь несколько языков (например, IL) позволяют разработчику явно выбирать, какой метод вызвать. Конечно, IL-программистам не следует использовать эту возможность, так как определенные таким образом методы будут недоступны для вызова из программ, написанных на других языках программирования. И хотя C# не предоставляет эту возможность программисту, внутренние механизмы компилятора все равно используют ее, если в типе определены методы операторов преобразования.
    // ПримечАние
    // С# генерирует код вызова операторов неявного преобразования в случае, когда используется выражение приведения типов. Однако операторы неявного преобразования никогда не вызываются, если используется оператор as или is.
    // System.Decimal - для того, чтобы разобраться

    // Методы расширения
    // А сейчас я попробую объяснить, что именно делают методы расширения. Они позволяют вам определить статический метод, который вызывается посредством синтаксиса экземплярного метода. Иначе говоря, мы можем определить собственный метод IndexOf — и три проблемы, упомянутые выше, исчезнут. Для того чтобы превратить метод IndexOf в метод расширения, мы просто добавим ключевое слово this перед первым аргументом: 
    // Компилятор увидит следующий код:
    // Int32 index = sb.IndexOf('X'); 
    // Сначала он проверит класс StringBuilder или все его базовые классы, предоставляющие экземплярные методы с именем IndexOf и единственным параметром Char.
    // Если они не существуют, тогда компилятор будет искать любой статический класс с определенным методом IndexOf, у которого первый параметр соответствует типу выражения, используемого при вызове метода. Этот тип должен быть отмечен при помощи ключевого слова this. В данном примере выражением является sb типа StringBuilder. В этом случае компилятор ищет метод IndexOf с двумя параметрами: StringBuilder (отмеченное словом this) и Char. Компилятор найдет наш метод IndexOf и сгенерирует IL-код для вызова нашего статического метода. 
    
    // Правила и рекомендации
    // - Язык С# поддерживает только методы расширения, он не поддерживает свойств расширения, событий расширения, операторов расширения и т. д.
    // - Методы расширения (методы со словом this перед первым аргументом) должны быть объявлены в статическом необобщенном классе. Однако нет ограничения на имя этого класса, вы можете назвать его как вам угодно. Конечно, метод расширения должен иметь, по крайней мере, один параметр, и только первый параметр может быть отмечен ключевым словом this. 
    // - Компилятор C# ищет методы расширения, заданные только в статических классах, определенных в области видимости файла. Другими словами, если вы определили статический класс, унаследованный от другого класса, компилятор C# выдаст следующее сообщение (ошибка CS1109: метод расширения должен быть определен в статическом классе первого уровня, StringBuilderExtensions является вложенным классом).
    // - Так как статическим классам можно давать любые имена по вашему желанию, компилятору С# необходимо какое-то время для того, чтобы найти методы расширения; он просматривает все статические классы, определенные в области файла, и сканирует их статические методы. Для повышения производительности и для того, чтобы не рассматривать лишние в данных обстоятельствах методы расширения, компилятор C# требует «импортирования» методов расширения. Например, пусть кто-нибудь определил класс StringBuilderExtensions в пространстве имен Wintellect, тогда другой программист, которому нужно иметь доступ к методу расширения данного класса, в начале файла программного кода должен указать команду using Wintellect.
    // - Существует возможность определения в нескольких статических классах одинаковых методов расширения. Если компилятор выяснит, что существуют два и более методов расширения, то тогда он выдает следующее сообщение (ошибка CS0121: неоднозначный вызов следующих методов или свойств). должен применяться синтаксис статического метода с указанием имени статического класса, чтобы точно сообщить компилятору, какой именно метод нужно вызвать.
    // - Прибегать к этому механизму следует не слишком часто, так как он известен не всем разработчикам. Например, когда вы расширяете тип с методом расширения, вы действительно расширяете унаследованные типы с этим методом. Следовательно, вы не должны определять метод выражения, чей первый параметр - System.Object, так как этот метод будет вызываться для всех типов выражений, и соответствующие ссылки только будут загромождать окно IntelliSense.
    // - Существует потенциальная проблема с версиями. Если в будущем разработчики Microsoft добавят экземплярный метод IndexOf к классу StringBuilder с тем же прототипом, что и в моем примере, то когда я перекомпилирую свой программный код, компилятор свяжет с программой экземплярный метод IndexOf компании Microsoft вместо моего статического метода IndexOf. Из-за этого моя программа начнет себя по-другому. Эта проблема версий — еще одна причина, по которой этот механизм следует использовать осмотрительно.

    // Расширение разных типов методами расширения
    // Так как метод расширения на самом деле является вызовом статического метода, то среда CLR не генерирует код для проверки значения выражения, используемого для вызова метода
    // Вы можете определять методы расширения для интерфейсных типов
    // Внимание
    // Методы расширения являются краеугольным камнем предлагаемой Microsoft технологии Language Integrated Query (LINQ). В качестве хорошего примера класса с большим количеством методов расширения обратите внимание на статический класс System.Linq.Enumerable и все его статические методы расширения в документации Microsoft . NET Framework SDK. Каждый метод расширения в этом классе расширяет либо интерфейс IEnumerable, либо интерфейс IEnumerable<T>.
    // Методы расширения также можно определять и для типов-делегатов, например
    // Кроме того, можно добавлять методы расширения к перечислимым типам
    // Наконец, компилятор С# позволяет создавать делегатов, ссылающихся на метод расширения через объект

    // Атрибут расширения
    // В языке С#, когда вы помечаете первый параметр статичного метода ключевым словом this, компилятор применяет соответствующий атрибут к методу, и данный атрибут сохраняется в метаданных результирующего файла. Этот атрибут определен в сборке System.Core.dll и выглядит следующим образом:
    // Определен в пространстве имен System.Runtime.CompilerServices
    // [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class
    // | AttributeTargets.
    // Assembly)]
    // public sealed class ExtensionAttribute : Attribute
    // {
    // }
    // ПримечАние
    // Класс ExtensionAttribute определен в сборке System.Core.dll. Это означает, что результирующая сборка, сгенерированная компилятором, будет иметь ссылку на встроенную в нее библиотеку System.Core.dll, даже если не использовать какой-либо тип из System.Core.dll и даже если не ссылаться на него во время компиляции программного кода. Однако это не такая уже большая проблема, потому что ExtensionAttribute используется только один раз во время компиляции, и во время выполнения System.Core.dll не загрузится, пока приложение занято чем-либо другим в этой сборке.
    
    // Частичные методы
    // К сожалению, у представленного кода имеются два недостатка:
    // - Тип не должен быть запечатанным (sealed) классом. Нельзя использовать этот подход для запечатанных классов или для значимых типов (потому что значимые типы неявно запечатаны). К тому же нельзя использовать этот подход для статических методов, потому что они не могут переопределяться.
    // - Существует проблема эффективности. Тип, определяемый только для переопределения метода, понапрасну расходует некоторое количество системных ресурсов. И даже если вы не хотите переопределять поведение типа OnNameChanging, код базового класса по-прежнему вызовет виртуальный метод, который помимо возврата управления ничего больше не делает. Метод ToUpper вызывается и тогда, когда OnNameChanging получает доступ к переданным аргументам, и тогда, когда не получает.
    // - Для решения проблемы переопределения поведения можно задействовать частичные методы языка C#. В следующем коде для достижения той же семантики, что и в предыдущем коде, используются частичные методы.
    // В этом коде есть несколько мест, на которые необходимо обратить внимание
    // - Теперь класс запечатан (хотя это и не обязательно). В действительности, класс мог бы быть статическим классом или даже значимым типом.
    // - Код, сгенерированный программой, и код, написанный программистом, на самом деле являются двумя частичными определениями, которые в конце концов образуют одно определение типа
    // - Код, сгенерированный программой, представляет собой объявление частичного метода. Этот метод помечен ключевым словом partial и не имеет тела.
    // - Код, написанный программистом, реализует объявление частичного метода. Этот метод также помечен ключевым словом partial и тоже не имеет тела.
    // ПримечАние
    // В редакторе Visual Studio, если ввести partial и нажать пробел, в окне IntelliSense появятся объявления всех частичных методов вложенного типа, которые пока не имеют соответствия объявлениям выполняемого частичного метода. Вы легко можете выбрать частичный метод в IntelliSense-окне, и Visual Studio сгенерирует прототип метода автоматически. Это очень удобная функция, повышающая производитель- ность программирования.
    // У частичных методов имеется еще одно серьезное преимущество. Скажем, у вас теперь нет нужны модифицировать поведение типа, сгенерированного инструментом, и менять файл исходного кода. Если просто скомпилировать такой код, компилятор создаст IL-код и метаданные, как если бы сгенерированный программой код выглядел следующим образом:
    // Логический эквивалент сгенерированного инструментом кода в случае,
    // когда нет объявления выполняемого частичного метода
    // internal sealed class Base
    // {
    //     private String m_name;
    //     public String Name
    //     {
    //         get { return m_name; }
    //         set
    //         {
    //             m_name = value; // Измените поле
    //         }
    //     }
    // }
    // При отсутствии объявления выполняемого частичного метода компилятор не будет генерировать метаданные, представляющие частичный метод. К тому же компилятор не сгенерирует IL-команды вызова частичного метода, он не сгенерирует код, вычисляющий аргументы, которые необходимо передать частичному методу.
    // ПримечАние
    // Подобным образом частичные методы работают с атрибутом System.Diagnostics.ConditionalAttribute. Однако они работают только с одним типом, тогда как атрибут ConditionalAttribute может быть использован для необязательного вызова методов, определенных в другом типе.

    // Правила и рекомендации
    // Несколько дополнительных правил и рекомендаций, касающихся частичных методов.
    // - Частичные методы могут объявляться только внутри частичного класса или структуры.
    // - Частичные методы должны всегда иметь возвращаемый тип void и не могут иметь параметров, помеченных ключевым словом out. Эти ограничения связаны с тем, что во время выполнения программы метода не существует, и вы не можете инициализировать переменную, возвращаемую методом, потому что этого метода не существует. По той же причине нельзя использовать параметр, помеченный словом out, потому что иначе метод должен будет инициализировать этот параметр, но этого метода не существует. Частичный метод может иметь параметры, помеченные ключевым словом ref, а также универсальные параметры, экземплярные или статические, или даже параметры, помеченные как unsafe.
    // - Естественно, определяющее объявление частичного метода и его реализующее объявление должны иметь идентичные сигнатуры. И оба должны иметь настраивающиеся атрибуты, применяющиеся к ним, когда компилятор объединяет атрибуты обоих методов вместе. Все атрибуты, применяемые к параметрам, тоже объединяются.
    // - Если не существует реализующего объявления частичного метода, в вашем коде не может быть попыток создания делегата, ссылающегося на частичный метод. Это причина, по которой метод не существует во время выполнения программы. Компилятор выдаст следующее сообщение (ошибка CS0762: не могу создать делегата из метода 'Base.OnNameChanging(string)', потому что это частичный метод без реализующего объявления).
    // - Хотя частичные методы всегда считаются закрытыми, компилятор C# запрещает писать ключевое слово private перед объявлением частичного метода.


    // !!!
    // - foreach +
    // - Action ...
    // - => ... 
    // - типы делегаты ...
}
