using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace CLR_VIA_C_SHARP._2_Type_Design._9_Parameters
{
    class Parameters
    {
        public static void main()
        {
            test_named_parameters();
            ImplicitlyTypedLocalVariables();
            test_value_parameter();
            // test_reference_parameter();
            TestSwap();
            testRandomParameterNumber();
        }

        private static void test_named_parameters()
        {
            // 1. Аналогично: M(9, "A", default(DateTime), new Guid());
            M();
            // 2. Аналогично: M(8, "X", default(DateTime), new Guid());
            M(8, "X");
            // 3. Аналогично: M(5, "A", DateTime.Now, Guid.NewGuid());
            M(5, guid: Guid.NewGuid(), dt: DateTime.Now);
            // 4. Аналогично: M(0, "1", default(DateTime), new Guid());
            M(s_n++, s_n++.ToString());
            // 5. Аналогично: String t1 = "2"; Int32 t2 = 3;
            // M(t2, t1, default(DateTime), new Guid());
            M(s: (s_n++).ToString(), x: s_n++);

            // Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
            Int32 a = 5;
            M(x: ref a);
        }

        private static Int32 s_n = 0;

        private static void M(Int32 x = 9, String s = "A", DateTime dt = default(DateTime), Guid guid = new Guid())
        {
            Console.WriteLine("x={0}, s={1}, dt={2}, guid={3}", x, s, dt, guid);
        }

        private static void M(ref Int32 x)
        {
            
        }

        private static void ImplicitlyTypedLocalVariables()
        {
            var name = "Jeff";
            ShowVariableType(name); // Вывод: System.String
            // var n = null; // Ошибка
            var x = (String)null; // Допустимо, хотя и бесполезно
            ShowVariableType(x); // Вывод: System.String
            var numbers = new Int32[] { 1, 2, 3, 4 };
            ShowVariableType(numbers); // Вывод: System.Int32[]
            // Меньше символов при вводе сложных типов
            var collection = new Dictionary<String, Single>() { { "Grant", 4.0f } };
            // Вывод: System.Collections.Generic.Dictionary`2[System.String,System.Single]
            ShowVariableType(collection);
            foreach (var item in collection)
            {
                // Вывод: System.Collections.Generic.KeyValuePair 2 [System.String,System.Single]
                ShowVariableType(item);
            }
        }

        private static void ShowVariableType<T>(T t)
        {
            Console.WriteLine(typeof(T));
        }

        private static void test_value_parameter()
        {
            Int32 x; // Инициализация x
            GetVal(out x); // Инициализация x не обязательна
            Console.WriteLine(x); // Выводится 10

            Int32 x1 = 5; // Инициализация x
            AddVal(ref x1); // x требуется инициализировать
            Console.WriteLine(x1); // Выводится 15
        }

        private static void GetVal(out Int32 v)
        {
            v = 10; // Этот метод должен инициализировать переменную V
        }

        private static void AddVal(ref Int32 v)
        {
            v += 10; // Этот метод может использовать инициализированный параметр v
        }

        private static void test_reference_parameter()
        {
            FileStream fs; // Объект fs не инициализирован

            // Первый файл открывается для обработки
            StartProcessingFiles(out fs);

            // Продолжаем, пока остаются файлы для обработки
            for (; fs != null; ContinueProcessingFiles(ref fs))
            {
                // Обработка файла
                // fs.Read(...);
            }
        }

        private static void StartProcessingFiles(out FileStream fs)
        {
            string path = @"c:\temp\MyTest.txt";
            fs = File.Create(path); // в этом методе объект fs
            // должен инициализироваться
        }

        private static void ContinueProcessingFiles(ref FileStream fs)
        {
            fs.Close(); // Закрытие последнего обрабатываемого файла
            // Открыть следующий файл или вернуть null, если файлов больше нет
            // if (noMoreFilesToProcess) fs = null;
            // else fs = new FileStream (...);
        }

        public static void Swap(ref Object a, ref Object b)
        {
            Object t = b;
            b = a;
            a = t;
        }

        public sealed class Point
        {
            static void Add(Point p) {  }
            static void Add(ref Point p) {  }
        }

        private static void TestSwap()
        {
            String s1 = "Jeffrey";
            String s2 = "Richter";
            // Swap(ref s1, ref s2); // error, expected object, not string.
            Console.WriteLine(s1); // Выводит "Richter"
            Console.WriteLine(s2); // Выводит "Jeffrey"

            // Решение проблемы:
            // Тип передаваемых по ссылке переменных должен
            // соответствовать ожидаемому
            Object o1 = s1, o2 = s2;
            Swap(ref o1, ref o2);
            // Приведение объектов к строковому типу
            s1 = (String)o1;
            s2 = (String)o2;
        }

        public static void Swap<T>(ref T a, ref T b)
        {
            T t = b;
            b = a;
            a = t;
        }

        private static void testRandomParameterNumber()
        {
            // Выводит "15"
            Console.WriteLine(Add(new Int32[] { 1, 2, 3, 4, 5 }));

            // Выводит "15"
            Console.WriteLine(Add(1, 2, 3, 4, 5));

            // Обе строчки выводят "0"
            Console.WriteLine(Add()); // передает новый элемент Int32[0] методу Add
            Console.WriteLine(Add(null)); // передает методу Add значение null, что более эффективно (не выделяется память под массив)

            DisplayTypes(new Object(), new Random(), "Jeff", 5);
        }

        static Int32 Add(params Int32[] values)
        {
            // ПРИМЕЧАНИЕ: при необходимости этот массив
            // можно передать другим методам
            Int32 sum = 0;
            if (values != null)
            {
                for (Int32 x = 0; x < values.Length; x++)
                    sum += values[x];
            }
            return sum;
        }

        private static void DisplayTypes(params Object[] objects)
        {
            if (objects != null)
            {
                foreach (Object o in objects)
                    Console.WriteLine(o.GetType());
            }
        }

        // Рекомендуется в этом методе использовать параметр слабого типа
        public void ManipulateItems<T>(IEnumerable<T> collection)
        {

        }

        // Не рекомендуется в этом методе использовать параметр сильного типа
        public void ManipulateItems<T>(List<T> collection)
        {

        }

        // Рекомендуется в этом методе использовать параметр мягкого типа
        public void ProcessBytes(Stream someStream)
        {
            
        }

        // Не рекомендуется в этом методе использовать параметр сильного типа
        public void ProcessBytes(FileStream fileStream)
        {

        }

        // Гибкий вариант: в этом методе используется
        // мягкий тип возвращаемого объекта
        public IList<String> GetStringCollection()
        {
            return new List<String>();
        }

        // Негибкий вариант: в этом методе используется
        // сильный тип возвращаемого объекта
        public List<String> MyGetStringCollection()
        {
            return new List<String>();
        }
    }

    // Необязательные и именованные параметры
    // При выборе параметров метода некоторым из них (и даже всем) можно присваивать значения по умолчанию. В результате в вызывающем такой метод коде можно не указывать эти аргументы, а принимать уже имеющиеся значения. Кроме того, при вызове метода существует возможность указать аргументы, воспользовавшись именами их параметров. Следующий код демонстрирует применение как необязательных, так и именованных параметров
    // Передаваемые в метод аргументы компилятор рассматривает слева направо.
    // Передача аргументов с помощью именованных параметров опять же осуществляется компилятором слева направо.
    
    // Правила использования параметров
    // Определяя метод, задающий для части своих параметров значения по умолчанию, следует руководствоваться следующими правилами:
    // - Значения по умолчанию указываются для параметров методов, конструкторов методов и параметрических свойств (индексаторов C#). Также их можно указывать для параметров, являющихся частью определения делегатов. В результате при вызове этого типа делегата аргументы можно опускать, используя их значения по умолчанию.
    // - Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами. Другими словами, если указан параметр со значением по умолчанию, значения по умолчанию должны иметь и все параметры, расположенные справа от него. Например, если при определении метода M удалить значение по умолчанию ("A") для параметра s, компилятор выдаст сообщение об ошибке. Существует только одно исключение из правил — параметр массива, помеченный ключевым словом params (о котором мы подробно поговорим чуть позже). Он должен располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию. При этом сам массив значения по умолчанию иметь не может.
    // - Во время компиляции значения по умолчанию должны оставаться неизменными. То есть задавать значения по умолчанию можно для параметров примитивных типов. Сюда относятся также перечислимые типы и ссылочные типы, допускающие присвоение значения null. Для параметров произвольного значимого типа значение по умолчанию задается как экземпляр этого типа с полями, содержащими нули. Можно использовать как ключевое слово default, так и ключевое слово new, в обоих случаях генерируется одинаковый IL-код. С примерами обоих вариантов синтаксиса мы уже встречались в методе M при задании значений по умолчанию для параметров dt и guid соответственно.
    // - Запрещается переименовывать параметрические переменные, так как это влечет за собой необходимость редактирования вызывающего кода, который передает аргументы по имени параметра. Скажем, если в объявлении метода M переименовать переменную dt в dateTime, то третий вызов метода станет причиной появления следующего сообщения компилятора
    // - При вызове метода извне модуля изменение значения параметров по умолчанию является потенциально опасным. Вызывающая сторона использует значение по умолчанию в процессе работы. Если изменить его и не перекомпилировать код, содержащий вызов, в вызываемый метод будет передано прежнее значение. В качестве индикатора поведения можно использовать значение по умолчанию 0 или null. В результате исчезает необходимость повторной компиляции кода вызывающей стороны.
    // Не делайте так:
    // private static String MakePath(String filename = "Untitled") {
    // return String.Format(@"C:\{0}.txt", filename);
    // }
    // Используйте следующее решение:
    // private static String MakePath(String filename = null) {
    // // Здесь применяется оператор, поддерживающий
    // // значение null (??); см. главу 19
    // return String.Format(@"C:\{0}.txt", filename ?? "Untitled");
    // }
    // - Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.
    // Существуют также дополнительные правила вызова методов с использованием необязательных или именованных параметров:
    // - Аргументы можно передавать в произвольном порядке; но именованные аргументы должны находиться в конце списка.
    // - Передача аргумента по имени возможна для параметров, не имеющих значения по умолчанию, но при этом компилятору должны быть переданы все аргументы, необходимые для компиляции (c указанием их позиции или имени).
    // - В C# между запятыми не могут отсутствовать аргументы. Иначе говоря, запись M(1, ,DateTime.Now) недопустима, так как ведет к нечитабельному коду. Чтобы опустить аргумент для параметра со значением по умолчанию, передавайте аргументы по именам параметров.
    // - Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
    // ПримечАние
    // Синтаксис необязательных и именованных параметров в C# весьма удобен при написании кода, поддерживающего объектную модель COM из Microsoft Office. При вызове COM-компонентов C# позволяет опускать ключевые слова ref/out в процессе передачи аргументов по ссылке. Это еще больше упрощает код. Если же COM-компонент не вызывается, наличие рядом с аргументом ключевого слова ref/out обязательно.
    // 

    // Атрибут DefaultParameterValue и необязательные атрибуты
    // В C# параметрам со значением по умолчанию назначается настраиваемый атрибут System.Runtime.InteropServices.OptionalAttribute, сохраняющийся в метаданных итогового файла. Кроме того, компилятор применяет к параметру атрибут System.Runtime.InteropServices.DefaultParameterValueAttribute, опять же сохраняя его в метаданных итогового файла. После чего конструктору DefaultParameterValueAttribute передаются постоянные значения, указанные в первоначальном коде.
    // В итоге встречая код, вызывающий метод, в котором не хватает аргументов, компилятор проверяет, являются ли эти аргументы необязательными, берет их значения из метаданных и автоматически вставляет в вызов метода.
    
    // Неявно типизированные локальные переменные
    // В C# поддерживается возможность определения типа используемых в методе локальных переменных по типу используемого при их инициализации выражения
    // Тип параметра метода при помощи ключевого слова var объявлять нельзя. Ведь компилятор будет определять его, исходя из типа аргументов, передаваемых при вызове метода. Вызова же может вообще не быть или же, наоборот, их может быть несколько. Аналогично, нельзя объявлять при помощи этого ключевого слова тип поля. Для такого ограничения в C# существует множество причин. Одна из них - возможность обращения к полю из нескольких методов. Группа проектирования C# считает, что контракт (тип переменной) должен быть указан явно. Второй причиной является тот факт, что в данном случае анонимные типы начнут выходить за границы одного метода.
    // Внимание
    // Не путайте ключевые слова dynamic и var. Объявление локальной переменной с ключевым слово var является не более чем синтаксическим сокращением, заставляющим компилятор определить тип данных по выражению. Данное ключевое слово служит только для объявления локальных переменных внутри метода, в то время как ключевое слово dynamic используется для локальных переменных, полей и аргументов. Невозможно привести выражение к типу var, но такая операция вполне допустима для типа dynamic. Переменные, объявленные с ключевым словом var, должны инициализироваться явно, что не обязательно для переменных типа dynamic. 

    // Передача параметров в метод по ссылке
    // По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка (или указатель) на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта, а исходный экземпляр сохраняется неизменным.
    // Внимание
    // Следует знать тип каждого объекта, передаваемого методу в качестве параметра, поскольку манипулирующий параметрами код может существенно различаться в зависимости от типа параметров.
    // CLR также позволяет передавать параметры по ссылке, а не по значению. В C# это делается с помощью ключевых слов out и ref. Оба заставляют компилятор генерировать метаданные, описывающие параметр как переданный по ссылке. Компилятор использует эти метаданные для генерирования кода, передающего вместо самого параметра его адрес.
    // Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод. В этом случае вызванный метод не может прочитать значение параметра и должен записать его, прежде чем вернуть управление. Если же параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод может как читать, так и записывать значение параметра.
    // Поведение ссылочных и значимых типов при использовании ключевых слов out и ref различается значительно. Вот как это выглядит в случае значимого типа.
    // Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование экземплярных полей значимого типа при вызовах методов.
    // Внимание
    // Меня часто спрашивают, почему при вызовах методов в программах на C# надо в явном виде указывать ключевые слова out или ref. В конце концов, компилятор в состоянии самостоятельно определить, какое из ключевых слов ему требуется, а значит, должен корректно компилировать код. Однако разработчики C# сочли, что вызывающий код должен явно указывать свои намерения, чтобы при вызове метода сразу было ясно, что этот метод должен менять значение передаваемой переменной. 
    // Кроме того, CLR позволяет по-разному перегружать методы в зависимости от выбора параметра out или ref. Например, следующий код на C# вполне допустим и прекрасно компилируется:
    // Не допускается перегружать методы, отличающиеся только типом параметров (out или ref), так как результатом их JIT-компиляции становится идентичный код метаданных, представляющих сигнатуру методов. 
    // Со значимыми типами ключевые слова out и ref дают тот же результат, что и передача ссылочного типа по значению. Они позволяют методу управлять единственным экземпляром значимого типа. Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим указателем. В силу этих особенностей использование ключевых слов out и ref со ссылочными типами полезно, лишь когда метод собирается «вернуть» ссылку на известный ему объект. 
    // Еще один пример, демонстрирующий использование ключевого слова ref для реализации метода, меняющего местами два ссылочных типа:
    // Однако компилироваться этот код не будет: ведь переменные, передаваемые методу по ссылке, должны быть одного типа, объявленного в сигнатуре метода. Иначе говоря, метод Swap ожидает получить ссылки на тип Object, а не на тип String. Решение же нашей задачи выглядит следующим образом:
    // Однако, как оказалось, эти методы можно заставить работать при помощи обобщений. Вот так следует исправить показанный ранее метод Swap:
    // За другими примерами решения, использующими обобщения, обращайтесь к классу System.Threading.Interlocked с его методами CompareExchange и Exchange.
    
    // Передача переменного количества аргументов
    // Иногда разработчику удобно определить метод, способный принимать переменное число параметров. Например, тип System.String предлагает методы, выполняющие объединение произвольного числа строк, а также методы, при вызове которых можно задать набор единообразно форматируемых строк.
    // Такая форма вызова возможна благодаря ключевому слову params. Именно оно заставляет компилятор рассматривать параметр как экземпляр настраиваемого атрибута System.ParamArrayAttribute.
    // Ключевым словом params может быть помечен только последний параметр метода (ParamArrayAttribute). Он должен указывать на одномерный массив произвольного типа.
    // как написать метод, принимающий произвольное количество параметров любого типа? Ответ прост: достаточно отредактировать прототип метода, заставив его вместо Int32[] принимать Object[].
    // Внимание
    // Вызов метода, принимающего переменное число аргументов, снижает производительность, если, конечно, не передавать в явном виде значение null. В любом случае всем объектам массива нужно выделить место в куче и инициализировать элементы массива, а по завершении работы занятая массивом память должна быть очищена сборщиком мусора. Чтобы уменьшить негативное влияние этих операций на производительность, можно определить несколько перегруженных методов, в которых не используется ключевое слово params. За примерами обратитесь к методу Concat класса System.String, который перегружен следующим образом:
    // Как видите, для метода Concat определены несколько вариантов перегрузки, в которых ключевое слово params не используется. Здесь представлены наиболее распространенные варианты перегрузки, которые, собственно, и предназначены для повышения эффективности работы в стандартных ситуациях. Варианты перегрузки с ключевым словом params предназначены для более редких ситуаций, поскольку при этом страдает производительность. К счастью, такие ситуации возникают не так уж часто.

    // Типы параметров и возвращаемых значений
    // Объявляя тип параметров метода, нужно по возможности указывать «минимальные» типы, предпочитая интерфейсы базовым классам. Например, при написании метода, работающего с набором элементов, лучше всего объявить параметр метода, используя интерфейс IEnumerable<T> вместо сильного типа данных, например List<T>, или еще более сильного интерфейсного типа ICollection<T> или IList<T>:
    // Естественно, при создании метода, получающего список (а не просто любой перечислимый объект), нужно объявлять тип параметра как IList<T>, в то время как типа List<T> лучше избегать. Именно такой подход позволит вызывающему коду передавать массивы и другие объекты, тип которых реализует IList<T>.
    // Обратите внимание, что в приводимых примерах речь идет о коллекциях, созданных с использованием архитектуры интерфейсов. Этот же подход применим к классам, опирающимся на архитектуру базовых классов.

    // Константность
    // В некоторых языках, в том числе в неуправляемом языке C++, методы и параметры можно объявлять как константы. Этим вы запрещаете коду в экземплярном методе изменять поля объекта или объекты, передаваемые в метод. В CLR эта возможность не поддерживается.


    // !!!
    // - ? operator
    // - ??  operator оператор, поддерживающий значение null
    // - var
}
