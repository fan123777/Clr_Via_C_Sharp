using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._9_Parameters
{
    class Parameters
    {
        public static void main()
        {
            test_named_parameters();
            ImplicitlyTypedLocalVariables();
        }

        private static void test_named_parameters()
        {
            // 1. Аналогично: M(9, "A", default(DateTime), new Guid());
            M();
            // 2. Аналогично: M(8, "X", default(DateTime), new Guid());
            M(8, "X");
            // 3. Аналогично: M(5, "A", DateTime.Now, Guid.NewGuid());
            M(5, guid: Guid.NewGuid(), dt: DateTime.Now);
            // 4. Аналогично: M(0, "1", default(DateTime), new Guid());
            M(s_n++, s_n++.ToString());
            // 5. Аналогично: String t1 = "2"; Int32 t2 = 3;
            // M(t2, t1, default(DateTime), new Guid());
            M(s: (s_n++).ToString(), x: s_n++);

            // Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
            Int32 a = 5;
            M(x: ref a);
        }

        private static Int32 s_n = 0;

        private static void M(Int32 x = 9, String s = "A", DateTime dt = default(DateTime), Guid guid = new Guid())
        {
            Console.WriteLine("x={0}, s={1}, dt={2}, guid={3}", x, s, dt, guid);
        }

        private static void M(ref Int32 x)
        {
            
        }

        private static void ImplicitlyTypedLocalVariables()
        {
            var name = "Jeff";
            ShowVariableType(name); // Вывод: System.String
            // var n = null; // Ошибка
            var x = (String)null; // Допустимо, хотя и бесполезно
            ShowVariableType(x); // Вывод: System.String
            var numbers = new Int32[] { 1, 2, 3, 4 };
            ShowVariableType(numbers); // Вывод: System.Int32[]
            // Меньше символов при вводе сложных типов
            var collection = new Dictionary<String, Single>() { { "Grant", 4.0f } };
            // Вывод: System.Collections.Generic.Dictionary`2[System.String,System.Single]
            ShowVariableType(collection);
            foreach (var item in collection)
            {
                // Вывод: System.Collections.Generic.KeyValuePair 2 [System.String,System.Single]
                ShowVariableType(item);
            }
        }

        private static void ShowVariableType<T>(T t)
        {
            Console.WriteLine(typeof(T));
        }
    }

    // Необязательные и именованные параметры
    // При выборе параметров метода некоторым из них (и даже всем) можно присваивать значения по умолчанию. В результате в вызывающем такой метод коде можно не указывать эти аргументы, а принимать уже имеющиеся значения. Кроме того, при вызове метода существует возможность указать аргументы, воспользовавшись именами их параметров. Следующий код демонстрирует применение как необязательных, так и именованных параметров
    // Передаваемые в метод аргументы компилятор рассматривает слева направо.
    // Передача аргументов с помощью именованных параметров опять же осуществляется компилятором слева направо.
    
    // Правила использования параметров
    // Определяя метод, задающий для части своих параметров значения по умолчанию, следует руководствоваться следующими правилами:
    // - Значения по умолчанию указываются для параметров методов, конструкторов методов и параметрических свойств (индексаторов C#). Также их можно указывать для параметров, являющихся частью определения делегатов. В результате при вызове этого типа делегата аргументы можно опускать, используя их значения по умолчанию.
    // - Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами. Другими словами, если указан параметр со значением по умолчанию, значения по умолчанию должны иметь и все параметры, расположенные справа от него. Например, если при определении метода M удалить значение по умолчанию ("A") для параметра s, компилятор выдаст сообщение об ошибке. Существует только одно исключение из правил — параметр массива, помеченный ключевым словом params (о котором мы подробно поговорим чуть позже). Он должен располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию. При этом сам массив значения по умолчанию иметь не может.
    // - Во время компиляции значения по умолчанию должны оставаться неизменными. То есть задавать значения по умолчанию можно для параметров примитивных типов. Сюда относятся также перечислимые типы и ссылочные типы, допускающие присвоение значения null. Для параметров произвольного значимого типа значение по умолчанию задается как экземпляр этого типа с полями, содержащими нули. Можно использовать как ключевое слово default, так и ключевое слово new, в обоих случаях генерируется одинаковый IL-код. С примерами обоих вариантов синтаксиса мы уже встречались в методе M при задании значений по умолчанию для параметров dt и guid соответственно.
    // - Запрещается переименовывать параметрические переменные, так как это влечет за собой необходимость редактирования вызывающего кода, который передает аргументы по имени параметра. Скажем, если в объявлении метода M переименовать переменную dt в dateTime, то третий вызов метода станет причиной появления следующего сообщения компилятора
    // - При вызове метода извне модуля изменение значения параметров по умолчанию является потенциально опасным. Вызывающая сторона использует значение по умолчанию в процессе работы. Если изменить его и не перекомпилировать код, содержащий вызов, в вызываемый метод будет передано прежнее значение. В качестве индикатора поведения можно использовать значение по умолчанию 0 или null. В результате исчезает необходимость повторной компиляции кода вызывающей стороны.
    // Не делайте так:
    // private static String MakePath(String filename = "Untitled") {
    // return String.Format(@"C:\{0}.txt", filename);
    // }
    // Используйте следующее решение:
    // private static String MakePath(String filename = null) {
    // // Здесь применяется оператор, поддерживающий
    // // значение null (??); см. главу 19
    // return String.Format(@"C:\{0}.txt", filename ?? "Untitled");
    // }
    // - Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.
    // Существуют также дополнительные правила вызова методов с использованием необязательных или именованных параметров:
    // - Аргументы можно передавать в произвольном порядке; но именованные аргументы должны находиться в конце списка.
    // - Передача аргумента по имени возможна для параметров, не имеющих значения по умолчанию, но при этом компилятору должны быть переданы все аргументы, необходимые для компиляции (c указанием их позиции или имени).
    // - В C# между запятыми не могут отсутствовать аргументы. Иначе говоря, запись M(1, ,DateTime.Now) недопустима, так как ведет к нечитабельному коду. Чтобы опустить аргумент для параметра со значением по умолчанию, передавайте аргументы по именам параметров.
    // - Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
    // ПримечАние
    // Синтаксис необязательных и именованных параметров в C# весьма удобен при написании кода, поддерживающего объектную модель COM из Microsoft Office. При вызове COM-компонентов C# позволяет опускать ключевые слова ref/out в процессе передачи аргументов по ссылке. Это еще больше упрощает код. Если же COM-компонент не вызывается, наличие рядом с аргументом ключевого слова ref/out обязательно.
    // 

    // Атрибут DefaultParameterValue и необязательные атрибуты
    // В C# параметрам со значением по умолчанию назначается настраиваемый атрибут System.Runtime.InteropServices.OptionalAttribute, сохраняющийся в метаданных итогового файла. Кроме того, компилятор применяет к параметру атрибут System.Runtime.InteropServices.DefaultParameterValueAttribute, опять же сохраняя его в метаданных итогового файла. После чего конструктору DefaultParameterValueAttribute передаются постоянные значения, указанные в первоначальном коде.
    // В итоге встречая код, вызывающий метод, в котором не хватает аргументов, компилятор проверяет, являются ли эти аргументы необязательными, берет их значения из метаданных и автоматически вставляет в вызов метода.
    
    // Неявно типизированные локальные переменные
    // В C# поддерживается возможность определения типа используемых в методе локальных переменных по типу используемого при их инициализации выражения
    // Тип параметра метода при помощи ключевого слова var объявлять нельзя. Ведь компилятор будет определять его, исходя из типа аргументов, передаваемых при вызове метода. Вызова же может вообще не быть или же, наоборот, их может быть несколько. Аналогично, нельзя объявлять при помощи этого ключевого слова тип поля. Для такого ограничения в C# существует множество причин. Одна из них - возможность обращения к полю из нескольких методов. Группа проектирования C# считает, что контракт (тип переменной) должен быть указан явно. Второй причиной является тот факт, что в данном случае анонимные типы начнут выходить за границы одного метода.
    // Внимание
    // Не путайте ключевые слова dynamic и var. Объявление локальной переменной с ключевым слово var является не более чем синтаксическим сокращением, заставляющим компилятор определить тип данных по выражению. Данное ключевое слово служит только для объявления локальных переменных внутри метода, в то время как ключевое слово dynamic используется для локальных переменных, полей и аргументов. Невозможно привести выражение к типу var, но такая операция вполне допустима для типа dynamic. Переменные, объявленные с ключевым словом var, должны инициализироваться явно, что не обязательно для переменных типа dynamic. 

    // Передача параметров в метод по ссылке
    // По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка (или указатель) на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта, а исходный экземпляр сохраняется неизменным.
    // Внимание
    // Следует знать тип каждого объекта, передаваемого методу в качестве параметра, поскольку манипулирующий параметрами код может существенно различаться в зависимости от типа параметров.
    // 251...


    // !!!
    // - ? operator
    // - ??  operator оператор, поддерживающий значение null
    // - var
}
