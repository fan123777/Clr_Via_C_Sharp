using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CLR_VIA_C_SHARP._2_Type_Design._9_Parameters
{
    class Parameters
    {
        public static void main()
        {
            test_named_parameters();
            ImplicitlyTypedLocalVariables();
            test_value_parameter();
            test_reference_parameter();
        }

        private static void test_named_parameters()
        {
            // 1. Аналогично: M(9, "A", default(DateTime), new Guid());
            M();
            // 2. Аналогично: M(8, "X", default(DateTime), new Guid());
            M(8, "X");
            // 3. Аналогично: M(5, "A", DateTime.Now, Guid.NewGuid());
            M(5, guid: Guid.NewGuid(), dt: DateTime.Now);
            // 4. Аналогично: M(0, "1", default(DateTime), new Guid());
            M(s_n++, s_n++.ToString());
            // 5. Аналогично: String t1 = "2"; Int32 t2 = 3;
            // M(t2, t1, default(DateTime), new Guid());
            M(s: (s_n++).ToString(), x: s_n++);

            // Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
            Int32 a = 5;
            M(x: ref a);
        }

        private static Int32 s_n = 0;

        private static void M(Int32 x = 9, String s = "A", DateTime dt = default(DateTime), Guid guid = new Guid())
        {
            Console.WriteLine("x={0}, s={1}, dt={2}, guid={3}", x, s, dt, guid);
        }

        private static void M(ref Int32 x)
        {
            
        }

        private static void ImplicitlyTypedLocalVariables()
        {
            var name = "Jeff";
            ShowVariableType(name); // Вывод: System.String
            // var n = null; // Ошибка
            var x = (String)null; // Допустимо, хотя и бесполезно
            ShowVariableType(x); // Вывод: System.String
            var numbers = new Int32[] { 1, 2, 3, 4 };
            ShowVariableType(numbers); // Вывод: System.Int32[]
            // Меньше символов при вводе сложных типов
            var collection = new Dictionary<String, Single>() { { "Grant", 4.0f } };
            // Вывод: System.Collections.Generic.Dictionary`2[System.String,System.Single]
            ShowVariableType(collection);
            foreach (var item in collection)
            {
                // Вывод: System.Collections.Generic.KeyValuePair 2 [System.String,System.Single]
                ShowVariableType(item);
            }
        }

        private static void ShowVariableType<T>(T t)
        {
            Console.WriteLine(typeof(T));
        }

        private static void test_value_parameter()
        {
            Int32 x; // Инициализация x
            GetVal(out x); // Инициализация x не обязательна
            Console.WriteLine(x); // Выводится 10

            Int32 x1 = 5; // Инициализация x
            AddVal(ref x1); // x требуется инициализировать
            Console.WriteLine(x1); // Выводится 15
        }

        private static void GetVal(out Int32 v)
        {
            v = 10; // Этот метод должен инициализировать переменную V
        }

        private static void AddVal(ref Int32 v)
        {
            v += 10; // Этот метод может использовать инициализированный параметр v
        }

        private static void test_reference_parameter()
        {

        }

        public sealed class Point
        {
            static void Add(Point p) {  }
            static void Add(ref Point p) {  }
        }
    }

    // Необязательные и именованные параметры
    // При выборе параметров метода некоторым из них (и даже всем) можно присваивать значения по умолчанию. В результате в вызывающем такой метод коде можно не указывать эти аргументы, а принимать уже имеющиеся значения. Кроме того, при вызове метода существует возможность указать аргументы, воспользовавшись именами их параметров. Следующий код демонстрирует применение как необязательных, так и именованных параметров
    // Передаваемые в метод аргументы компилятор рассматривает слева направо.
    // Передача аргументов с помощью именованных параметров опять же осуществляется компилятором слева направо.
    
    // Правила использования параметров
    // Определяя метод, задающий для части своих параметров значения по умолчанию, следует руководствоваться следующими правилами:
    // - Значения по умолчанию указываются для параметров методов, конструкторов методов и параметрических свойств (индексаторов C#). Также их можно указывать для параметров, являющихся частью определения делегатов. В результате при вызове этого типа делегата аргументы можно опускать, используя их значения по умолчанию.
    // - Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами. Другими словами, если указан параметр со значением по умолчанию, значения по умолчанию должны иметь и все параметры, расположенные справа от него. Например, если при определении метода M удалить значение по умолчанию ("A") для параметра s, компилятор выдаст сообщение об ошибке. Существует только одно исключение из правил — параметр массива, помеченный ключевым словом params (о котором мы подробно поговорим чуть позже). Он должен располагаться после всех прочих параметров, в том числе имеющих значение по умолчанию. При этом сам массив значения по умолчанию иметь не может.
    // - Во время компиляции значения по умолчанию должны оставаться неизменными. То есть задавать значения по умолчанию можно для параметров примитивных типов. Сюда относятся также перечислимые типы и ссылочные типы, допускающие присвоение значения null. Для параметров произвольного значимого типа значение по умолчанию задается как экземпляр этого типа с полями, содержащими нули. Можно использовать как ключевое слово default, так и ключевое слово new, в обоих случаях генерируется одинаковый IL-код. С примерами обоих вариантов синтаксиса мы уже встречались в методе M при задании значений по умолчанию для параметров dt и guid соответственно.
    // - Запрещается переименовывать параметрические переменные, так как это влечет за собой необходимость редактирования вызывающего кода, который передает аргументы по имени параметра. Скажем, если в объявлении метода M переименовать переменную dt в dateTime, то третий вызов метода станет причиной появления следующего сообщения компилятора
    // - При вызове метода извне модуля изменение значения параметров по умолчанию является потенциально опасным. Вызывающая сторона использует значение по умолчанию в процессе работы. Если изменить его и не перекомпилировать код, содержащий вызов, в вызываемый метод будет передано прежнее значение. В качестве индикатора поведения можно использовать значение по умолчанию 0 или null. В результате исчезает необходимость повторной компиляции кода вызывающей стороны.
    // Не делайте так:
    // private static String MakePath(String filename = "Untitled") {
    // return String.Format(@"C:\{0}.txt", filename);
    // }
    // Используйте следующее решение:
    // private static String MakePath(String filename = null) {
    // // Здесь применяется оператор, поддерживающий
    // // значение null (??); см. главу 19
    // return String.Format(@"C:\{0}.txt", filename ?? "Untitled");
    // }
    // - Для параметров, помеченных ключевыми словами ref или out, значения по умолчанию не задаются.
    // Существуют также дополнительные правила вызова методов с использованием необязательных или именованных параметров:
    // - Аргументы можно передавать в произвольном порядке; но именованные аргументы должны находиться в конце списка.
    // - Передача аргумента по имени возможна для параметров, не имеющих значения по умолчанию, но при этом компилятору должны быть переданы все аргументы, необходимые для компиляции (c указанием их позиции или имени).
    // - В C# между запятыми не могут отсутствовать аргументы. Иначе говоря, запись M(1, ,DateTime.Now) недопустима, так как ведет к нечитабельному коду. Чтобы опустить аргумент для параметра со значением по умолчанию, передавайте аргументы по именам параметров.
    // - Вот как передать аргумент по имени параметра, требующего ключевого слова ref/out:
    // ПримечАние
    // Синтаксис необязательных и именованных параметров в C# весьма удобен при написании кода, поддерживающего объектную модель COM из Microsoft Office. При вызове COM-компонентов C# позволяет опускать ключевые слова ref/out в процессе передачи аргументов по ссылке. Это еще больше упрощает код. Если же COM-компонент не вызывается, наличие рядом с аргументом ключевого слова ref/out обязательно.
    // 

    // Атрибут DefaultParameterValue и необязательные атрибуты
    // В C# параметрам со значением по умолчанию назначается настраиваемый атрибут System.Runtime.InteropServices.OptionalAttribute, сохраняющийся в метаданных итогового файла. Кроме того, компилятор применяет к параметру атрибут System.Runtime.InteropServices.DefaultParameterValueAttribute, опять же сохраняя его в метаданных итогового файла. После чего конструктору DefaultParameterValueAttribute передаются постоянные значения, указанные в первоначальном коде.
    // В итоге встречая код, вызывающий метод, в котором не хватает аргументов, компилятор проверяет, являются ли эти аргументы необязательными, берет их значения из метаданных и автоматически вставляет в вызов метода.
    
    // Неявно типизированные локальные переменные
    // В C# поддерживается возможность определения типа используемых в методе локальных переменных по типу используемого при их инициализации выражения
    // Тип параметра метода при помощи ключевого слова var объявлять нельзя. Ведь компилятор будет определять его, исходя из типа аргументов, передаваемых при вызове метода. Вызова же может вообще не быть или же, наоборот, их может быть несколько. Аналогично, нельзя объявлять при помощи этого ключевого слова тип поля. Для такого ограничения в C# существует множество причин. Одна из них - возможность обращения к полю из нескольких методов. Группа проектирования C# считает, что контракт (тип переменной) должен быть указан явно. Второй причиной является тот факт, что в данном случае анонимные типы начнут выходить за границы одного метода.
    // Внимание
    // Не путайте ключевые слова dynamic и var. Объявление локальной переменной с ключевым слово var является не более чем синтаксическим сокращением, заставляющим компилятор определить тип данных по выражению. Данное ключевое слово служит только для объявления локальных переменных внутри метода, в то время как ключевое слово dynamic используется для локальных переменных, полей и аргументов. Невозможно привести выражение к типу var, но такая операция вполне допустима для типа dynamic. Переменные, объявленные с ключевым словом var, должны инициализироваться явно, что не обязательно для переменных типа dynamic. 

    // Передача параметров в метод по ссылке
    // По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передается ссылка (или указатель) на этот объект. То есть метод может изменить переданный объект, влияя на состояние вызывающего кода. Если параметром является экземпляр значимого типа, методу передается его копия. В этом случае метод получает собственную копию объекта, а исходный экземпляр сохраняется неизменным.
    // Внимание
    // Следует знать тип каждого объекта, передаваемого методу в качестве параметра, поскольку манипулирующий параметрами код может существенно различаться в зависимости от типа параметров.
    // CLR также позволяет передавать параметры по ссылке, а не по значению. В C# это делается с помощью ключевых слов out и ref. Оба заставляют компилятор генерировать метаданные, описывающие параметр как переданный по ссылке. Компилятор использует эти метаданные для генерирования кода, передающего вместо самого параметра его адрес.
    // Если параметр метода помечен ключевым словом out, вызывающий код может не инициализировать его, пока не вызван сам метод. В этом случае вызванный метод не может прочитать значение параметра и должен записать его, прежде чем вернуть управление. Если же параметр помечен ключевым словом ref, вызывающий код должен инициализировать его перед вызовом метода, а вызванный метод может как читать, так и записывать значение параметра.
    // Поведение ссылочных и значимых типов при использовании ключевых слов out и ref различается значительно. Вот как это выглядит в случае значимого типа.
    // Использование ключевого слова out со значимыми типами повышает эффективность кода, так как предотвращает копирование экземплярных полей значимого типа при вызовах методов.
    // Внимание
    // Меня часто спрашивают, почему при вызовах методов в программах на C# надо в явном виде указывать ключевые слова out или ref. В конце концов, компилятор в состоянии самостоятельно определить, какое из ключевых слов ему требуется, а значит, должен корректно компилировать код. Однако разработчики C# сочли, что вызывающий код должен явно указывать свои намерения, чтобы при вызове метода сразу было ясно, что этот метод должен менять значение передаваемой переменной. 
    // Кроме того, CLR позволяет по-разному перегружать методы в зависимости от выбора параметра out или ref. Например, следующий код на C# вполне допустим и прекрасно компилируется:
    // Не допускается перегружать методы, отличающиеся только типом параметров (out или ref), так как результатом их JIT-компиляции становится идентичный код метаданных, представляющих сигнатуру методов. 
    // Со значимыми типами ключевые слова out и ref дают тот же результат, что и передача ссылочного типа по значению. Они позволяют методу управлять единственным экземпляром значимого типа. Вызывающий код должен выделить память для этого экземпляра, а вызванный метод управляет выделенной памятью. В случае ссылочных типов вызывающий код выделяет память для указателя на передаваемый объект, а вызванный код управляет этим указателем. В силу этих особенностей использование ключевых слов out и ref со ссылочными типами полезно, лишь когда метод собирается «вернуть» ссылку на известный ему объект. 
    // 254




    // !!!
    // - ? operator
    // - ??  operator оператор, поддерживающий значение null
    // - var
}
